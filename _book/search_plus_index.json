{"./":{"url":"./","title":"Introduction","keywords":"","body":"GitBookGitBook My gitbook to record useful knowledge 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-07-13 09:36:41 "},"剑指offer/":{"url":"剑指offer/","title":"剑指offer","keywords":"","body":" 记录剑指offer刷题笔记 刷题进度表 TODO: 从尾到头打印链表 旋转数组的最小数字 22，24， 25，32(BFS)的递归写法 56-II 的第2个方法(自动机) 3 题后面的拓展题目没看也没写 4题的递归思路没有写 55-I 非递归自己可以写一下，剑指offer提供了递归写法 55-II 使用递归我们重复遍历了很多节点，因此我们采用后序遍历，但是自己没有写出来 54可以改进，时间效率太低 题号 题目名称 解决时间 疑问 笔记 数组中重复的数字 数组中重复的数字 二维数组中的查找 二维数组中的查找 替换空格 2020-07-25 替换空格 从尾到头打印链表 2020-07-18 从尾到头打印链表 重建二叉树 用两个栈实现队列 2020-07-18 两个栈实现队列 斐波那契数列 2020-07-15 斐波那契数列 青蛙跳台阶问题 2020-07-15 青蛙跳台阶问题 旋转数组的最小数字 矩阵中的路径 机器人的运动范围 剪绳子 2020-07-18 剪绳子 剪绳子 II 二进制中1的个数 2020-07-15 二进制中1的个数 数值的整数次方 打印从1到最大的n位数 删除链表的节点 删除链表的节点 正则表达式匹配 表示数值的字符串 调整数组顺序使奇数位于偶数前面 2020-07-19 调整数组顺序使奇数位于偶数前面 链表中倒数第k个节点 2020-07-18 链表中倒数第k个节点 反转链表 合并两个排序的链表 树的子结构 二叉树的镜像 2020-07-26 二叉树的镜像 对称的二叉树 顺时针打印矩阵 包含min函数的栈 包含min函数的栈 栈的压入、弹出序列 2020-07-19 栈的压入、弹出序列 从上到下打印二叉树 从上到下打印二叉树 II 从上到下打印二叉树 III 二叉搜索树的后序遍历序列 二叉树中和为某一值的路径 复杂链表的复制 二叉搜索树与双向链表 序列化二叉树 字符串的排列 数组中出现次数超过一半的数字 最小的k个数 数据流中的中位数 连续子数组的最大和 1～n整数中1出现的次数 数字序列中某一位的数字 把数组排成最小的数 把数字翻译成字符串 礼物的最大价值 礼物的最大价值 最长不含重复字符的子字符串 丑数 第一个只出现一次的字符 数组中的逆序对 两个链表的第一个公共节点 2020-07-18 两个链表的第一个公共节点 在排序数组中查找数字 I 0～n-1中缺失的数字 二叉搜索树的第k大节点 二叉树的深度 平衡二叉树 2020-07-30 平衡二叉树 数组中数字出现的次数 2020-07-18 数组中数字出现的次数 数组中数字出现的次数 II 2020-07-17 数组中数字出现的次数II 和为s的两个数字 2020-07-27 和为s的两个数字 和为s的连续正数序列 2020-08-01 和为s的连续正数序列 翻转单词顺序 2020-08-01 左旋转字符串 2020-08-01 滑动窗口的最大值 2020-08-01 滑动窗口的最大值 队列的最大值 2020-08-01 队列的最大值 n个骰子的点数 扑克牌中的顺子 圆圈中最后剩下的数字 股票的最大利润 2020-07-17 股票的最大利润 求1+2+…+n 不用加减乘除做加法 2020-07-18 不用加减乘除做加法 构建乘积数组 二叉搜索树的最近公共祖先 二叉树的最近公共祖先 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-08-03 15:01:55 "},"剑指offer/总结.html":{"url":"剑指offer/总结.html","title":"总结书上的笔记","keywords":"","body":"算法和数据操作位运算递归与循环算法和数据操作 排序和查找中应该重点掌握：二分查找，归并排序，快速排序 如果面试题要求在二维数据上搜索路径，我们可以尝试使用回溯法，当面试官限定不可以用递归时，我们考虑用栈模拟递归实现。 如果面试题是求某个问题的最优解，并且该问题可以分解为多个子问题，我们可以尝试使用动态规划，在自上而下的递归思路分析问题时，发现存在大量重复子问题，因此为了避免不必要的重复计算，我们使用从下往上的循环实现。一般就是使用一维或二维数组保存计算下来的最优解，接下来解决更大的问题 如果告诉面试官动态规划思路之后，面试官还在提醒说分解子问题的时候是不是存在某个特殊选择，如果采用这个特殊选择一定可以得到最优解，那么这意味着该面试题适用于贪婪算法。 位运算 把一个整数减去1之后再和原来的整数做位与运算，得到的结果相当于把整数的二进制表示中最右边的1编程0 一个数字左移1位之后右边补0，但是进行右移时，如果是无符号的则在左边补0，否则补上符号位(整数补0，负数补1)，算术右移补上符号位，逻辑右移不用补符号位 递归与循环 面试的时候，如果面试官没有特别要求，应聘者可以尽量多的采用递归方法编程。因为递归实现的代码简洁很多 递归缺点：递归是函数调用自身，而函数调用自身有时间和空间消耗，每一次函数调用，都要在内存占中分配空间以保存参数，返回地址以及临时变量，而且往栈中压入数据和弹出数据都需要时间。除此之外，递归涉及到了大量的重复计算。 通常应用动态规划解决问题时，我们都是采用递归的思路进行分析，但是在实现的时候我们采用从下往上来避免大量的重复计算。 除效率之外，递归还有可能引起更严重的问题：调用栈溢出，因为每个进程的栈容量有限，当递归调用层级太多，会超出栈容量。 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-07-15 09:30:51 "},"剑指offer/数组中重复的数字/code.html":{"url":"剑指offer/数组中重复的数字/code.html","title":"数组中重复的数字","keywords":"","body":"版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-07-25 08:13:23 "},"剑指offer/二维数组的查找/code.html":{"url":"剑指offer/二维数组的查找/code.html","title":"二维数组的查找","keywords":"","body":"版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-07-25 08:13:23 "},"剑指offer/替换空格/code.html":{"url":"剑指offer/替换空格/code.html","title":"替换空格","keywords":"","body":"版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-07-25 08:10:45 "},"剑指offer/从尾到头打印链表/code.html":{"url":"剑指offer/从尾到头打印链表/code.html","title":"从尾到头打印链表","keywords":"","body":"从尾到头打印链表方法一：方法二：从尾到头打印链表 方法一： 思路：使用栈存储遍历结果，之后再输出栈的结果。 衍生：既然想到使用栈，递归也是天然的栈，因此我们可以考虑使用递归 方法二： 思路：反转链表再打印。需要征得面试官同意是否可以更改链表 总结：对于使用栈，我们可以想到递归，因为递归也是栈的一种应用场景。同时对于方法二需要修改输入的链表，我们事先需要征得面试官同意 方法 时间复杂度 空间复杂度 方法一 o(n) o(n) 方法二 o(n) o(1) 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-07-18 20:50:28 "},"剑指offer/用两个栈实现队列/code.html":{"url":"剑指offer/用两个栈实现队列/code.html","title":"用两个栈实现队列","keywords":"","body":"用两个栈实现队列方法一：使用container/list方法二：使用切片用两个栈实现队列 思路： 准备1个输入数据的栈，1个输出数据的栈 当加入元素的时候直接加入到输入数据栈中 当弹出元素的时候，分为如下几种情况， 如果输出数据栈不为空，直接弹出 如果输出数据栈为空，将输入数据栈所有元素加入到输出数据栈中，再返回输出数据栈栈顶元素 方法一：使用container/list //执行用时：252 ms, 在所有 Go 提交中击败了 54.16% 的用户 //内存消耗：8.1 MB, 在所有 Go 提交中击败了 100.00% 的用户 type CQueue struct { InputStack, OutputStack *list.List } func Constructor() CQueue { return CQueue{list.New(), list.New()} } func (this *CQueue) AppendTail(value int) { //直接将元素加入到输入栈中 this.InputStack.PushBack(value) } func (this *CQueue) DeleteHead() int { //如果输出栈有元素，直接删除 //否则需要将输入栈全部元素导入到输出栈，然后删除输出栈的元素 if this.OutputStack.Len() == 0 { //以下3行代码必须这样写 //或者可以写成this.OutputStack.PushBack(this.InputStack.Remove(this.InputStack.Back())) for this.InputStack.Len() > 0 { this.OutputStack.PushBack(this.InputStack.Remove(this.InputStack.Back())) } } if this.OutputStack.Len() != 0 { return this.OutputStack.Remove(this.OutputStack.Back()).(int) } return -1 //说明输入栈以及输出栈没有任何内容 } 方法二：使用切片 //执行用时：256 ms, 在所有 Go 提交中击败了 47.47% 的用户 //内存消耗：8.3 MB, 在所有 Go 提交中击败了 100.00% 的用户 type CQueue struct { InputSlice []int OutputSlice []int } func Constructor() CQueue { return CQueue{ make([]int, 0), make([]int, 0), } } func (this *CQueue) AppendTail(value int) { this.InputSlice = append(this.InputSlice, value) } func (this *CQueue) DeleteHead() int { //得到InputSlice以及OutputSlice的大小 lengthInputSlice, lengthOutputSlice := len(this.InputSlice), len(this.OutputSlice) //如果输出有元素直接输出 if lengthOutputSlice > 0 { ele := this.OutputSlice[lengthOutputSlice-1] this.OutputSlice = this.OutputSlice[0:lengthOutputSlice-1] return ele } else { //如果输出没有元素将输入的元素全部加入进去 for lengthInputSlice > 0 { this.OutputSlice = append(this.OutputSlice, this.InputSlice[lengthInputSlice-1]) this.InputSlice = this.InputSlice[0:lengthInputSlice-1] lengthInputSlice, lengthOutputSlice = lengthInputSlice - 1, lengthOutputSlice + 1 } } if lengthOutputSlice > 0 { ele := this.OutputSlice[lengthOutputSlice-1] this.OutputSlice = this.OutputSlice[0:lengthOutputSlice-1] lengthOutputSlice = lengthOutputSlice - 1 return ele } //如果输入也没有元素返回-1 return -1 } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-07-18 22:30:41 "},"剑指offer/斐波那契数列/code.html":{"url":"剑指offer/斐波那契数列/code.html","title":"斐波那契数列","keywords":"","body":"斐波那契数列方法一：递归方法二：动态规划额外的补充斐波那契数列 注意题目要求：答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 原因：参考 方法一：递归 提交到LeetCode上超时 func fib(n int) int { //递归终止条件1 if n 方法二：动态规划 // 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 // 内存消耗：1.9 MB, 在所有 Go 提交中击败了100.00%的用户 func fib(n int) int { if n 对方法2代码的改进，参考 func fib(n int) int { a, b := 0, 1 for i := 0; i 额外的补充 除以上的两种方法之外还有另外的一种时间复杂度为O(log n)的解法，这里不再进行赘述。 总结：采用递归的思路分析问题，采用由下往上的思路解决问题 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-07-19 21:51:50 "},"剑指offer/青蛙跳台阶问题/code.html":{"url":"剑指offer/青蛙跳台阶问题/code.html","title":"青蛙跳台阶问题","keywords":"","body":"青蛙跳台阶问题青蛙跳台阶问题-II青蛙跳台阶问题 题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 思路与斐波那契数列一致，但是注意斐波那契数列中fib(0)=0，而这里numWays(0)返回1 注意斐波那契数列中fib(0)=0，而这里numWays(0)返回1 func numWays(n int) int { minusOneStep, minusTwoStep := 1, 1 for i := 0; i 注意题目中要求：答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 青蛙跳台阶问题-II 题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶........它也可以跳上n级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 跳上1级台阶：1 跳上2级台阶：2 跳上3级台阶：4 跳上4级台阶：8 跳上5级台阶：16 跳上6级台阶：32 跳上7级台阶：64 总结规律：跳上n级台阶：2^(n-1) 数学归纳法可以证明f(n)=2^(n-1) func numWays(n int) int { return (1 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-07-15 10:20:04 "},"剑指offer/二进制中1的个数/code.html":{"url":"剑指offer/二进制中1的个数/code.html","title":"二进制中1的个数","keywords":"","body":"二进制中1的个数方法一：方法二：拓展题目：一条语句判断1个数是不是2的整数次方输入两个整数m和n，计算需要改变m的二进制表示中的多少位才能得到n？二进制中1的个数 方法一： func hammingWeight2(num uint32) int { var flag uint32 = 1 count := 0 for i := 0; i 方法二： func hammingWeight(num uint32) int { count := 0 for num != 0{ count += 1 num = num & (num - 1) } return count } Tips：一个数字左移1位之后右边补0，但是进行右移时，如果是无符号的则在左边补0，否则补上符号位(整数补0，负数补1)，算术右移补上符号位，逻辑右移不用补符号位 这两个解法都是通用的，不仅仅针对于无符号整数，也针对有符号整数，方法一我们不希望右移，因为右移对于负数会补1，后面会陷入无限循环。所以我们可以设置一个flag不断左移进行判断每一位是否为1 拓展题目： 一条语句判断1个数是不是2的整数次方 如果这个数是2的整数次方，一定这个数不为0并且这个数的二进制表示中只有1个1 (num != 0) && (num & (num - 1) == 0) func isPowerOfTwo(num int) bool { if num != 0 && (num & (num - 1)) == 0 { return true } return false } 输入两个整数m和n，计算需要改变m的二进制表示中的多少位才能得到n？ 思路： 采用异或求两个数字二进制表示中的不同位 之后统计异或结果二进制表示中1的数目 func numOfChangeBits(m int, n int) int { //求两个数字的异或 ret := m ^ n //统计ret中位1的个数 count := 0 for ret != 0 { count += 1 ret &= (ret - 1) } return count } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-07-15 09:40:23 "},"剑指offer/删除链表的节点/code.html":{"url":"剑指offer/删除链表的节点/code.html","title":"删除链表的节点","keywords":"","body":"删除链表的节点自己写的代码LeetCode上的简洁解法删除链表的节点 思路： 如果要删除的节点是头节点，直接返回头节点的下一个节点 如果删除的是中间节点或者尾节点，通过遍历找到要删除节点的上一个节点，将指针指向要删除节点的下一个节点 自己写的代码 剑指offer函数参数传入了要删除的节点，因此不用再去遍历一次去确认要删除的节点是否在末尾 // 执行用时：4 ms, 在所有 Go 提交中击败了 75.15% 的用户 // 内存消耗：2.9 MB, 在所有 Go 提交中击败了 100.00% 的用户 func deleteNode(head *ListNode, val int) *ListNode { //首先判断链表是否为空 if head == nil { return nil } //如果删除头节点 if head.Val == val { //如果链表只有1个节点 if head.Next == nil { return nil } else { node := head.Next head.Next = nil return node } } node := head //否则找到要删除的节点的前一个节点 for node.Next != nil && node.Next.Val != val { node = node.Next } //如果没找到 if node.Next == nil { return head } //说明找到了 if node.Next.Next != nil { //说明删除的不是尾节点 node.Next = node.Next.Next } else { //说明要删除的是尾节点 node.Next = nil } return head } LeetCode上的简洁解法 func deleteNode(head *ListNode, val int) *ListNode { //如果删除的是头节点(包含只有1个节点以及多个节点) if head.Val==val{ return head.Next } //如果删除的是中间节点或者尾节点 for pre, p := head, head.Next; p != nil; p = p.Next{ if p.Val == val{ pre.Next = p.Next return head } pre = pre.Next } return head } 总结：删除链表中节点，如果函数传入了删除的节点，如果该节点位于中间，直接将值修改成后面节点的值，然后将指针指向下下个节点即可。 特殊情况： 链表只有1个节点，且删除该节点 链表中有多个节点，且删除头节点 链表中有多个节点，且删除尾节点 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-07-30 18:28:31 "},"剑指offer/调整数组顺序使奇数位于偶数前面/code.html":{"url":"剑指offer/调整数组顺序使奇数位于偶数前面/code.html","title":"调整数组顺序使奇数位于偶数前面","keywords":"","body":"调整数组顺序使奇数位于偶数前面调整数组顺序使奇数位于偶数前面 思路：采用双指针，左指针最开始指向数组最左边元素，右指针指向最右边元素。 条件1：当左指针指向的数为奇数，则左指针右移 条件2：当右指针指向的数为偶数，则右指针左移 当左指针指向的数为偶数，右指针指向的数为奇数则交换，同时移动左右指针，注意这个条件必须在最前面， 注意两个数交换必须在条件1和条件2之前，因为一旦移动，那么我们交换有可能左指针已经在右指针右边了 // 执行用时：24 ms, 在所有 Go 提交中击败了 87.81% 的用户 // 内存消耗：6.4 MB, 在所有 Go 提交中击败了 100.00% 的用户 func exchange(nums []int) []int { //如果给了一个空数组 //这个if成立的时候for循环也不会执行，因此这个if可以不写 if len(nums) == 0 { return []int{} } //odd用来做奇数，even用来做偶数 odd, even := 0, len(nums) - 1 for odd Tips：代码块1一定要在代码块2和代码块3前面，否则对于下面输入会报错 [11,9,3,7,16,4,2,0] ​ 错误将会输出 [11,9,3,16,7,4,2,0] ​ 预期结果是[11,9,3,7,16,4,2,0] 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-07-19 11:22:04 "},"剑指offer/链表中倒数第k个节点/code.html":{"url":"剑指offer/链表中倒数第k个节点/code.html","title":"链表中倒数第k个节点","keywords":"","body":"链表中倒数第k个节点方法一：栈存放遍历链表的数据方法二：两次遍历链表方法三[推荐]：双指针链表中倒数第k个节点 方法一：栈存放遍历链表的数据 衍生思路：递归 既然递归是天然的栈，我们不由想到使用递归解决 方法二：两次遍历链表 思路：第一次遍历链表统计长度，第二次遍历到第n - k + 1个节点(走n-k步)的时候就是我们想要的节点，直接返回 //执行用时：0 ms, 在所有 Go 提交中击败了100.00% 的用户 //内存消耗：2.2 MB, 在所有 Go 提交中击败了 100.00% 的用户 func getKthFromEnd(head *ListNode, k int) *ListNode { //如果链表为空或者k为非正数 if head == nil || k 方法三[推荐]：双指针 思路：使用双指针，保持两个指针的距离为k-1。 原因：第1个指针与第2个指针的距离为k-1，当第1个指针遍历到尾，第2个指针正好在倒数第k个节点上 //执行用时：0 ms, 在所有 Go 提交中击败了100.00% 的用户 //内存消耗：2.2 MB, 在所有 Go 提交中击败了 100.00% 的用户 //方法3：双指针，第1个指针先走k-1步，之后两个指针开始走，当第1个指针走到最后一个，第2个指针便是倒数第k个节点 func getKthFromEnd(head *ListNode, k int) *ListNode { //如果链表不存在怎么办 //如果k是一个非正数怎么办 if head == nil || k 方法三相比于方法二，只需要遍历一次链表，相比于方法一以及其衍生方法并且不需要额外的空间复杂度 总结：对于链表题目，双指针作为一种常用的解题思路有大量的应用，例如快慢指针，维持固定距离的两个指针等思想 链表无法高效获取长度，无法根据偏移快速访问元素，是链表的两个劣势。然而面试的时候经常碰见诸如获取倒数第k个元素，获取中间位置的元素，判断链表是否存在环，判断环的长度等和长度与位置有关的问题。这些问题都可以通过灵活运用双指针来解决。 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-07-18 15:43:57 "},"剑指offer/二叉树的镜像/code.html":{"url":"剑指offer/二叉树的镜像/code.html","title":"二叉树的镜像","keywords":"","body":"二叉树的镜像方法一：递归方法二：采用先序遍历反转二叉树的镜像 方法一：递归 思路：每次不断反转当前节点的左右子树，直到当前节点为空 // 执行用时：0 ms, 在所有 Go 提交中击败了 100.00% 的用户 // 内存消耗：2.1 MB, 在所有 Go 提交中击败了 100.00% 的用户 func mirrorTree(root *TreeNode) *TreeNode { if root == nil { return nil } //直接换 root.Left, root.Right = root.Right, root.Left mirrorTree(root.Left) mirrorTree(root.Right) return root } 方法二：采用先序遍历反转 思路： 采用先序遍历的方式，先弹出队列的队首，然后将当前节点的左右反转 如果当前节点的左边不为空，则将当前节点的左边加入队列 如果当前节点的右边不为空，则将当前节点的右边加入队列 // 执行用时：0 ms, 在所有 Go 提交中击败了 100.00% 的用户 // 内存消耗：2.1 MB, 在所有 Go 提交中击败了 100.00% 的用户 func mirrorTree(root *TreeNode) *TreeNode { if root == nil { return nil } queue := []*TreeNode{} queue = append(queue, root) for len(queue) > 0 { node := queue[0] queue = queue[1:] //反转node的左右 node.Left, node.Right = node.Right, node.Left //如果左不为空，则加入队列 if node.Left != nil { queue = append(queue, node.Left) } //如果右不为空，则加入队列 if node.Right != nil { queue = append(queue, node.Right) } } return root } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-07-26 09:54:46 "},"剑指offer/包含min函数的栈/code.html":{"url":"剑指offer/包含min函数的栈/code.html","title":"包含min函数的栈","keywords":"","body":"包含min函数的栈方法一：使用container/list方法二：使用slice包含min函数的栈 根据slice或container/list实现还有push的两种可能一共有4种解法 思路：根据加入的当前元素，在push时有如下两种可能 当加入的元素大于最小值栈顶元素，最小值栈顶元素不加入，否则加入 。弹出的时候需要将弹出的元素与最小值栈顶元素比较，如果相等，都弹出，否则只弹出数据栈的元素 当加入的元素大于最小值栈顶元素，最小值栈顶元素加入当前的最小值栈顶元素。弹出的时候一起弹出 方法一：使用container/list 思路：当加入的元素大于最小值栈顶元素，最小值栈顶元素加入当前的最小值栈顶元素 // 执行用时：20 ms, 在所有 Go 提交中击败了 79.64% 的用户 // 内存消耗：7.7 MB, 在所有 Go 提交中击败了 100.00% 的用户 type MinStack struct { //一个数据栈，一个最小值栈 DataStack, MinValueStack *list.List } /** initialize your data structure here. */ func Constructor() MinStack { return MinStack{list.New(), list.New()} } func (this *MinStack) Push(x int) { this.DataStack.PushBack(x) //如果最小值栈没有元素直接加入 if this.MinValueStack.Len() == 0 { this.MinValueStack.PushBack(x) return } //最小值栈不为空的情况 //如果x超过最小值，也要将最小值栈栈顶重新加入最小值栈栈顶 minValueStackTop := this.MinValueStack.Back().Value.(int) if x > minValueStackTop { this.MinValueStack.PushBack(minValueStackTop) } else { this.MinValueStack.PushBack(x) } } func (this *MinStack) Pop() { //如果数据栈没有内容直接不弹出 if this.DataStack.Len() != 0 { this.DataStack.Remove(this.DataStack.Back()) this.MinValueStack.Remove(this.MinValueStack.Back()) } } func (this *MinStack) Top() int { return this.DataStack.Back().Value.(int) } func (this *MinStack) Min() int { return this.MinValueStack.Back().Value.(int) } 方法二：使用slice 思路：当加入的元素大于最小值栈顶元素，最小值栈顶元素不加入，否则加入 。弹出的时候需要将弹出的元素与最小值栈顶元素比较，如果相等，都弹出，否则只弹出数据栈的元素 // 执行用时：24 ms, 在所有 Go 提交中击败了 45.81% 的用户 // 内存消耗：8.1 MB, 在所有 Go 提交中击败了 100.00% 的用户 type MinStack struct { DataStack, MinValueStack []int } /** initialize your data structure here. */ func Constructor() MinStack { return MinStack{[]int{}, []int{}} } func (this *MinStack) Push(x int) { this.DataStack = append(this.DataStack, x) //如果当前最小值栈为空，直接加入 if len(this.MinValueStack) == 0 { this.MinValueStack = append(this.MinValueStack, x) return } //如果x大于当前最小栈栈顶元素就不加入 if x 0 { //并且当数据栈栈顶元素等于最小值栈顶元素就弹出 if this.MinValueStack[len(this.MinValueStack) - 1] == this.DataStack[len(this.DataStack) - 1] { this.MinValueStack = this.MinValueStack[:len(this.MinValueStack) - 1] } this.DataStack = this.DataStack[:len(this.DataStack) - 1] } } func (this *MinStack) Top() int { return this.DataStack[len(this.DataStack) - 1] } func (this *MinStack) Min() int { return this.MinValueStack[len(this.MinValueStack) - 1] } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-07-19 09:49:46 "},"剑指offer/栈的压入、弹出序列/code.html":{"url":"剑指offer/栈的压入、弹出序列/code.html","title":"栈的压入、弹出序列","keywords":"","body":"栈的压入、弹出序列代码一：代码二：栈的压入、弹出序列 思路：使用一个辅助栈模拟真实栈的操作 步骤如下： 如果需要加入的切片不为空，就加入 辅助栈栈顶元素与弹出的元素一致，则弹出，循环此步骤直到辅助栈栈顶元素与弹出的元素不一致 循环1，2步骤，直到所有元素加入完成。 此时判断辅助栈是否为空，如果为空则返回true否则返回false 代码一： // 执行用时：8 ms, 在所有 Go 提交中击败了 82.92% 的用户 // 内存消耗：3.8 MB, 在所有 Go 提交中击败了 100.00% 的用户 func validateStackSequences(pushed []int, popped []int) bool { //记录输入两个slice的长度 lengthPushed, lengthPopped := len(pushed), len(popped) //如果两个长度不一致 if lengthPushed != lengthPopped { return false } //使用一个栈来模拟栈的行为 stack, length := []int{}, 0 //将pushed所有元素压入 for lengthPushed > 0 { //元素压入栈 stack, length = append(stack, pushed[0]), length + 1 //pushed删除该元素 pushed, lengthPushed = pushed[1:], lengthPushed - 1 //push元素之后比较压入的元素与pop元素是否同，如果同就弹出，否则继续压入 //不用判断lengthPopped是否为0，因为如果为0肯定stack也没有元素 for (length != 0) && (stack[length - 1] == popped[0]) { stack, length, popped, lengthPopped = stack[:length - 1], length - 1, popped[1:], lengthPopped - 1 } } //如果所有元素压入之后，stack的栈顶依然与popped的第1个元素不同，直接返回false //上述条件等价于如果栈中还有元素，直接返回false if length != 0 { return false } return true } 代码二： 优点：相比于代码一，使用for-range将pushed元素加入到stack // 执行用时：4 ms, 在所有 Go 提交中击败了 99.69% 的用户 // 内存消耗：3.8 MB, 在所有 Go 提交中击败了 100.00% 的用户 func validateStackSequences(pushed []int, popped []int) bool { //记录输入两个slice的长度 lengthPushed, lengthPopped := len(pushed), len(popped) //如果两个长度不一致 if lengthPushed != lengthPopped { return false } //使用一个栈来模拟栈的行为 stack, length := []int{}, 0 for _, value := range pushed { //元素压入栈 stack, length = append(stack, value), length + 1 //当前栈顶元素与popped的第一个元素一致，则删除 //不用判断lengthPopped是否为0，因为如果为0肯定stack也没有元素 for (length > 0) && (stack[length - 1] == popped[0]) { stack, length, popped, lengthPopped = stack[:length-1], length - 1, popped[1:], lengthPopped - 1 } } if length != 0 { return false } return true } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-07-19 21:00:01 "},"剑指offer/礼物的最大价值/code.html":{"url":"剑指offer/礼物的最大价值/code.html","title":"礼物的最大价值","keywords":"","body":"礼物的最大价值礼物的最大价值 思路：问题是求最大价值(最值)，同时是遍历一个二维数组，涉及到了大量的重复计算，因而我们可以考虑dp， 最入门的dp可以使用二维数组来存储结果 这里我们进行状态压缩，使用一维数组来存储结果 dp[i][j]表示第i, j位置的礼物最大价值 dp公式如下： dp[i][j] = grid[i][j]) 位于第一行第一列，只能赋值 dp[i][j] = dp[i][j-1] + grid[i][j] 位于第一行非第一列，只能从左边过来 dp[i][j] = dp[i-1][j] + grid[i][j] 位于其他行的第一列，只能从上边下来 dp[i][j] = max(dp[i-1][j] + grid[i][j], dp[i][j-1] + grid[i][j]) 当不在第一行第一列时 // 执行用时：8 ms, 在所有 Go 提交中击败了 89.81% 的用户 // 内存消耗：3.9 MB, 在所有 Go 提交中击败了 100.00% 的用户 func maxValue(grid [][]int) int { //如果行和列两个维度只要有一个为0就返回0 if len(grid) == 0 || len(grid[0]) == 0 { return 0 } valueArray := make([]int, len(grid[0])) //遍历多少次 for i := 0; i b { return a } return b } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-07-19 21:51:46 "},"剑指offer/两个链表的第一个公共节点/code.html":{"url":"剑指offer/两个链表的第一个公共节点/code.html","title":"两个链表的第一个公共节点","keywords":"","body":"两个链表的第一个公共节点方法一：第一个链表遍历完，指针指向第二个链表方法二：两个链表的第一个公共节点 方法一：第一个链表遍历完，指针指向第二个链表 思路：当我们第一个链表遍历完之后，指针指向第2个链表头。这样可以避免遍历链表获取链表长度 // 执行用时：44 ms, 在所有 Go 提交中击败了91.37% 的用户 // 内存消耗：7.9 MB, 在所有 Go 提交中击败了 100.00% 的用户 func getIntersectionNode(headA, headB *ListNode) *ListNode { //如果两个链表有一个为空，返回nil if headA == nil || headB == nil { return nil } //判断两个链表是否相交 //找到两个链表的交点 flag := 1 tempHeadA, tempHeadB := headA, headB for tempHeadA != tempHeadB { //当其中一个到达了末尾 if tempHeadB.Next == nil { tempHeadB = headA flag += 1 } if tempHeadA.Next == nil { tempHeadA = headB flag += 1 } //说明两个链表的头都已遍历完自己的链表和另外一个链表，并且其中一个又遍历完另一个链表 if flag > 3 { return nil } tempHeadA, tempHeadB = tempHeadA.Next, tempHeadB.Next } return tempHeadA; } 方法二： 思路：遍历两个链表分别获取其长度，然后其中长的链表先走长度差的步数 // 执行用时：44 ms, 在所有 Go 提交中击败了91.37% 的用户 // 内存消耗：7.9 MB, 在所有 Go 提交中击败了 100.00% 的用户 func getIntersectionNode(headA, headB *ListNode) *ListNode { //如果两个链表有一个为空，返回nil if headA == nil || headB == nil { return nil } //获取两个链表的长度 lenA, lenB := 1, 1 tempHeadA, tempHeadB := headA, headB for tempHeadA.Next != nil { tempHeadA, lenA = tempHeadA.Next, lenA + 1 } for tempHeadB.Next != nil { tempHeadB, lenB = tempHeadB.Next, lenB + 1 } //重置 tempHeadA, tempHeadB = headA, headB //第一个链表长 if lenA > lenB { for i := 0; i 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-07-18 22:33:44 "},"剑指offer/平衡二叉树/code.html":{"url":"剑指offer/平衡二叉树/code.html","title":"平衡二叉树","keywords":"","body":"平衡二叉树方法一：递归方法二：递归平衡二叉树 方法一：递归 获取当前节点左右子树的高度差是否小于等于1且大于等于1 再判断当前节点的左右子树是否平衡 该方法在获取高度差之后又要判断左右子树是否平衡，同时遍历了两次左右子树，因此效率不高。 // 执行用时：8 ms, 在所有 Go 提交中击败了 88.31% 的用户 // 内存消耗：5.7 MB, 在所有 Go 提交中击败了 100.00% 的用户 func isBalanced(root *TreeNode) bool { //需要注意的是空树也是平衡二叉树 if root == nil { return true } //获取左子树的深度，以及右子树的深度，然后判断差值的绝对值是否在-1 - 1之间 leftSubTreeDepth, rightSubTreeDepth := maxDepth(root.Left), maxDepth(root.Right) val := leftSubTreeDepth - rightSubTreeDepth if val >= -1 && val rightSubTreeDepth { return leftSubTreeDepth + 1 } return rightSubTreeDepth + 1 } 方法二：递归 相对于方法一，我们采用了后序遍历，当遍历到当前节点时，我们先判断左右子树是否平衡，在判断子树平衡的时候我们已经获取了左右子树的高度，此时根据差值判断是否平衡。 // 执行用时：4 ms, 在所有 Go 提交中击败了 98.69% 的用户 // 内存消耗：5.7 MB, 在所有 Go 提交中击败了 44.44% 的用户 func isBalancedCore(root *TreeNode, height *int) bool { //需要注意的是空树也是平衡二叉树 if root == nil { return true } leftSubTreeDepth, rightSubTreeDepth := 0, 0 //如果左子树平衡并且右子树平衡。如果都平衡，我们同时获取了左子树和右子树的深度 if (isBalancedCore(root.Left, &leftSubTreeDepth) && isBalancedCore(root.Right, &rightSubTreeDepth)) { diff := leftSubTreeDepth - rightSubTreeDepth if diff >= -1 && diff 0 { *height = leftSubTreeDepth + 1 } else { *height = rightSubTreeDepth + 1 } return true } } return false } func isBalanced(root *TreeNode) bool { //需要注意的是空树也是平衡二叉树 if root == nil { return true } height := 0 return isBalancedCore(root, &height) } 总结： 相比于方法一，方法二采用了后序遍历的方式，只需要遍历一次左右子树，不需要重复遍历。因此效率会比方法一高。方法一采用了自上向下的方式，包含了大量重复计算。 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-07-30 20:33:10 "},"剑指offer/数组中数字出现的次数/code.html":{"url":"剑指offer/数组中数字出现的次数/code.html","title":"数组中数字出现的次数","keywords":"","body":"数组中数字出现的次数最初版本：改进版本进阶进阶-2数组中数字出现的次数 思路：分组异或 最初版本： 思路：使用原数组，将其分成两部分，前面一部分[0, firstEndPoint]上所有的数字 在 xorRet中最右边为1的二进制位都为1。后面一部分都为的数字 在 xorRet中最右边为1的二进制位都为0 求出数组中所有数字的异或结果xorRet, 一定不为0，因为有两个只出现1次的数字。 根据xorRet中的某一个为1的二进制位(这里我们使用最右边为1的二进制位)将该数组中所有数字分成两组，一组在该二进制位上为1，另一组为0 之后第一组中所有数字进行异或得到的结果便是其中一个只出现一次的数字，另一个以此类推 //执行用时：24 ms, 在所有 Go 提交中击败了62.56% 的用户 //内存消耗：6 MB, 在所有 Go 提交中击败了 100.00% 的用户 func singleNumbers(nums []int) []int { //得到两个只出现1次数字的异或结果 xorRet := 0 for _, val := range nums { xorRet ^= val } //从右到左找到异或结果不为1的那个二进制位 //通过这一个二进制位划分成两个数组， bitMask := 1 for i := 0; i 该方法缺点： 遍历了3次数组 同时对元素组进行了修改，需要提前问面试官是否可以修改原数组 改进版本 //执行用时：20 ms, 在所有 Go 提交中击败了89.35% 的用户 //内存消耗：6 MB, 在所有 Go 提交中击败了 100.00% 的用户 //上面方法的改进，只用遍历两次数组即可 func singleNumbers(nums []int) []int { //得到两个只出现1次数字的异或结果 xorRet := 0 for _, val := range nums { xorRet ^= val } //从右到左找到异或结果不为1的那个二进制位 //通过这一个二进制位划分成两个数组， bitMask := 1 for i := 0; i 改进： 只用遍历两次数组 进阶 //执行用时：20 ms, 在所有 Go 提交中击败了89.35% 的用户 //内存消耗：6 MB, 在所有 Go 提交中击败了 100.00% 的用户 func singleNumbers(nums []int) []int { //得到两个只出现1次数字的异或结果 xorRet := 0 for _, val := range nums { xorRet ^= val } //得到最右边的为1的二进制 xorRet = xorRet & (-xorRet) //相当于a = a &（~a+1 fmt.Println(xorRet) //上面得到的二进制位和数组中的所有数字与，得到两个结果1或0，可以划分成两个数组 ret1, ret2 := 0, 0 for i := 0; i 改进： 通过 x = x & -x* 找到最右边的二进制位1 返回切片的时候 不用直接make， 可以直接使用 return []int{ret1, ret2} 相当于返回一个长度为2的切片 *return* []int{ret1, ret2} 进阶-2 //执行用时：20 ms, 在所有 Go 提交中击败了89.35% 的用户 //内存消耗：6 MB, 在所有 Go 提交中击败了 100.00% 的用户 func singleNumbers(nums []int) []int { //得到两个只出现1次数字的异或结果 xorRet := 0 for _, val := range nums { xorRet ^= val } //得到最右边的为1的二进制 xorRet = xorRet & (-xorRet) //相当于a = a &（~a+1 //上面得到的二进制位和数组中的所有数字与，得到两个结果1或0，可以划分成两个数组 ret := make([]int, 2) for i := 0; i 改进：直接使用切片存储而不需要两个结果变量 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-07-19 07:27:51 "},"剑指offer/数组中数字出现的次数II/code.html":{"url":"剑指offer/数组中数字出现的次数II/code.html","title":"数组中数字出现的次数II","keywords":"","body":"数组中数字出现的次数II方法一方法二：有限状态自动机+位运算数组中数字出现的次数II 思路：所有数字出现了3次，那么我们可以将二进制位每一位的结果进行无进位相加，如果哪一位可以被3整除，则说明只出现一次的数字在该位上为0，否则为1 方法一 //自己的解法，也是和剑指offer一样的解法 func singleNumber(nums []int) int { if len(nums) 方法二：有限状态自动机+位运算 参考 func singleNumber2(nums []int) int { one, two := 0, 0 for _, e := range nums { one = ^two & (one^e) two = ^one & (two^e) } return one } 总结：两个方法时间复杂度都为o(1)，但整体上推荐方法二，详细解答点击上面的参考 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-07-18 10:19:08 "},"剑指offer/滑动窗口的最大值/code.html":{"url":"剑指offer/滑动窗口的最大值/code.html","title":"滑动窗口的最大值","keywords":"","body":"滑动窗口的最大值自己纸上手写的代码：(提交不通过)对上面版本的代码的错误改正：再改正：滑动窗口的最大值 思路：使用一个切片模拟窗口以及一个切片保存滑动窗口每次的最大值 初始时将前滑动窗口大小的元素中的元素按照如下规则加入最大值切片 若最大值切片没有元素，直接加入 若大于最大值切片的最后一个，则弹出最后一个元素，不断循环，直到最大值切片最后一个元素小于等于要加入的元素值 之后在加入当前遍历到的元素时，需要确保如下几种情况 滑动窗口最左边的元素没有越界 加入的元素如果比之前的大，就弹出，直到最大值切片最后一个元素小于等于要加入的元素值 此时就可以直接加入 自己纸上手写的代码：(提交不通过) //语法有问题：第2个for循环的里面那个for循环，可能为0，因此就会把索引设为-1，报错 //同时逻辑有点小问题，我们自己初始化了滑动窗口大小的元素，初始化完成之后，没有将初始化后的最大值加入到我们的结果中 func maxSlidingWindow(nums []int, k int) []int { //如果传入的数组大小小于窗口大小，我们需要问面试官如何处理 if len(nums) = k { //说明左边的元素超过了边界要弹出 window = window[1:] curLength -= 1 } for curLength 对上面版本的代码的错误改正： //提交之后报错：因为传入的数组以及滑动窗口大小可能为0 // 加了ret = append(ret, nums[window[0]])，改了for curLength != 0 && curLength func maxSlidingWindow(nums []int, k int) []int { //如果传入的数组大小小于窗口大小，我们需要问面试官如何处理 // if len(nums) = k { //说明左边的元素超过了边界要弹出 window = window[1:] curLength -= 1 } for curLength != 0 && curLength 再改正： // 执行用时：20 ms, 在所有 Go 提交中击败了 79.30% 的用户 // 内存消耗：6.3 MB, 在所有 Go 提交中击败了 41.67% 的用户 func maxSlidingWindow(nums []int, k int) []int { if len(nums) = k { //说明左边的元素超过了边界要弹出 window = window[1:] curLength -= 1 } for curLength != 0 && curLength 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-08-02 09:44:06 "},"剑指offer/队列的最大值/code.html":{"url":"剑指offer/队列的最大值/code.html","title":"队列的最大值","keywords":"","body":"队列的最大值队列的最大值 // 执行用时：96 ms, 在所有 Go 提交中击败了 96.81% 的用户 // 内存消耗：7.8 MB, 在所有 Go 提交中击败了 53.33% 的用户 思路：使用两个切片，一个保存数据，另一个保存最大值 当加入数据到队列时，如果比最大值切片中的最后一个元素大，则弹出最后一个，不断循环，直到最大值切片中最后一个元素大于等于要加入的数据值(类似于滑动窗口的最大值)。此时再加入数据值到数据切片与最大值切片。反之直接加入 当弹出数据元素的时候，如果该元素等于最大值切片的第一个元素，最大值切片也要弹出，反之只弹出数据切片中的元素 type MaxQueue struct { maximum []int data []int } func Constructor() MaxQueue { return MaxQueue{[]int{}, []int{}} } func (this *MaxQueue) Max_value() int { if len(this.maximum) this.maximum[length - 1] { //弹出小的,因为要加入的值比前面的值大 this.maximum = this.maximum[:length - 1] length -= 1 } this.data = append(this.data, value) this.maximum = append(this.maximum, value) } func (this *MaxQueue) Pop_front() int { if len(this.data) 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-08-01 20:07:07 "},"剑指offer/股票的最大利润/code.html":{"url":"剑指offer/股票的最大利润/code.html","title":"股票的最大利润","keywords":"","body":"股票的最大利润方法一：方法二：股票的最大利润 方法一： 思路：假设在当天买入，在后面找到最大值，差值与之前计算过的最大利润比较，如果大就更新。含有大量的重复计算 //执行用时：292 ms, 在所有 Go 提交中击败了5.2% 的用户 //内存消耗：3.1 MB, 在所有 Go 提交中击败了 100.00% 的用户 func maxProfit(prices []int) int { //这里没必要判断，因为for循环第1个会判断 //如果传入进来的价格数组长度为0,zh length := len(prices) // if length 方法二： 思路：假设当天卖出股票，那么在遍历到当天之前，我们需要使用minValue记录最小的值，同时记录maxProfit //执行用时：4 ms, 在所有 Go 提交中击败了97.06% 的用户 //内存消耗：3.1 MB, 在所有 Go 提交中击败了 100.00% 的用户 func maxProfit(prices []int) int { //如果传入进来的价格数组长度为0 length := len(prices) //if length maxProfit { maxProfit = prices[i] - minValue } //之后比较最小值 if minValue > prices[i] { minValue = prices[i] } } return maxProfit } 总结：两种方法如上所示，法一时间复杂度为o(n^2)，法二时间复杂度为o(n) 这道题目其实就是找到在数组中找到两个值，要求满足如下条件： 两个值有先后顺序 后面值减去前面值尽可能大，如果都为负直接返回0 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-07-18 10:21:23 "},"剑指offer/求1+2+...+n/code.html":{"url":"剑指offer/求1+2+...+n/code.html","title":"求1+2+...+n","keywords":"","body":"版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-07-18 09:40:37 "},"剑指offer/不用加减乘除做加法/code.html":{"url":"剑指offer/不用加减乘除做加法/code.html","title":"不用加减乘除做加法","keywords":"","body":"不用加减乘除做加法不用加减乘除做加法 思路：两个数相加，可以拆分成如下几步 计算进位的结果 计算不进位时的结果 将两个相加得到我们的结果 func add(a int, b int) int { //如果有一个为0 if a == 0 || b == 0 { return a ^ b } //如果两个都不为0 andRet, xorRet := a & b, a ^ b for andRet != 0 { andRet 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-07-18 11:31:41 "},"算法刷题总结/位运算.html":{"url":"算法刷题总结/位运算.html","title":"位运算","keywords":"","body":"把一个整数减去1之后再和原来的整数做位与运算，得到的结果相当于把整数的二进制表示中最右边的1编程0 一个数字左移1位之后右边补0，但是进行右移时，如果是无符号的则在左边补0，否则补上符号位(整数补0，负数补1)，算术右移补上符号位，逻辑右移不用补符号位 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-07-13 11:11:09 "},"算法刷题总结/递归与循环.html":{"url":"算法刷题总结/递归与循环.html","title":"递归与循环","keywords":"","body":"算法和数据操作位运算递归与循环算法和数据操作 排序和查找中应该重点掌握：二分查找，归并排序，快速排序 如果面试题要求在二维数据上搜索路径，我们可以尝试使用回溯法，当面试官限定不可以用递归时，我们考虑用栈模拟递归实现。 如果面试题是求某个问题的最优解，并且该问题可以分解为多个子问题，我们可以尝试使用动态规划，在自上而下的递归思路分析问题时，发现存在大量重复子问题，因此为了避免不必要的重复计算，我们使用从下往上的循环实现。一般就是使用一维或二维数组保存计算下来的最优解，接下来解决更大的问题 如果告诉面试官动态规划思路之后，面试官还在提醒说分解子问题的时候是不是存在某个特殊选择，如果采用这个特殊选择一定可以得到最优解，那么这意味着该面试题适用于贪婪算法。 位运算 把一个整数减去1之后再和原来的整数做位与运算，得到的结果相当于把整数的二进制表示中最右边的1编程0 一个数字左移1位之后右边补0，但是进行右移时，如果是无符号的则在左边补0，否则补上符号位(整数补0，负数补1)，算术右移补上符号位，逻辑右移不用补符号位 递归与循环 面试的时候，如果面试官没有特别要求，应聘者可以尽量多的采用递归方法编程。因为递归实现的代码简洁很多 递归缺点：递归是函数调用自身，而函数调用自身有时间和空间消耗，每一次函数调用，都要在内存占中分配空间以保存参数，返回地址以及临时变量，而且往栈中压入数据和弹出数据都需要时间。除此之外，递归涉及到了大量的重复计算。 通常应用动态规划解决问题时，我们都是采用递归的思路进行分析，但是在实现的时候我们采用从下往上来避免大量的重复计算。 除效率之外，递归还有可能引起更严重的问题：调用栈溢出，因为每个进程的栈容量有限，当递归调用层级太多，会超出栈容量。 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-07-15 09:26:50 "},"golang/":{"url":"golang/","title":"Golang学习","keywords":"","body":" 记录Golang学习历程 千峰教育韩茹老师课程：https://www.bilibili.com/video/BV1k4411G7yy?p=42 进度 时间 33-41 7-21 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-07-21 17:43:42 "},"golang/break_continue.html":{"url":"golang/break_continue.html","title":"break和continue的使用","keywords":"","body":"break以及continue的使用break以及continue的使用 break 或者 continue 都只是针对于紧挨break 或 continue 的内层循环 如果想要终止外层循环或者跳过可以给外层循环加上标签，之后使用语法：break 外层循环加的标签名 或 goto 外层循环加的标签名 首先要给我们想要中断的外层循环添加标签，之后在break或continue后面加上标签 //continue和break默认结束最里层的循环 //如果我们想要结束外层循环可以贴标签 out:for i := 0; i 打印结果如下： i = 0 j = 0 i = 0 j = 0 i = 1 j = 0 i = 2 j = 0 i = 3 j = 0 i = 4 j = 0 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-07-21 17:38:43 "},"golang/goto.html":{"url":"golang/goto.html","title":"goto语句","keywords":"","body":"goto语句应用场景goto语句 程序正常执行时会进入贴上标签的代码，并执行 语法：goto 标签 给代码贴上标签：标签: 代码 a := 10 loop: for a 打印结果如下： 10 11 12 13 14 16 17 18 19 123 应用场景 goto语句应用：统一错误处理 err := firstCheckError() if err != nil { goto onExit } err := secondCheckError() if err != nil { goto onExit } fmt.Println(\"done\") return onExit: fmt.Println(err) exitProcess() 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-07-21 17:33:43 "},"golang/randnum.html":{"url":"golang/randnum.html","title":"随机数","keywords":"","body":"随机数随机数 生成随机数需要设置不一样的种子，当我们种子不一样时就会产生不同的随机数，因此如果种子一样生成的随机数也会一样 通过rand.Seed(time.Now().Unix())设置随机数 package main import ( \"fmt\" \"math/rand\" \"time\" ) func main() { //因为随机数是根据种子生成的 rand.Seed(time.Now().Unix()) //种子固定以后就可以生成随机出 //生成[0, 31]的随机数 for i := 0; i 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-07-21 21:26:22 "},"golang/array.html":{"url":"golang/array.html","title":"数组","keywords":"","body":"数组的初步使用数组的初步使用 数组的语法定义： var 数组名 = [数组长度] 数据类型 {} var 数组名 = [数组长度] 数据类型 {初始元素(要求个数必须小于等于数组长度)} var 数组名 := [数组长度] 数据类型 {下标:元素值......} 数组名 := [...] 数据类型 {初始元素} 根据初始元素个数决定数据的长度 数组的长度表明了数组实际存放元素的个数，而容量则表示数组存放数字的最大个数 因为数组是固定长度的，数组的长度和容量是相等的。并且需要注意的是长度也是数组的属性，所以[3]int 与 [4]int是两种不同数据类型。因为数组的数据类型由数组的长度以及数组中元素的数据类型决定。 package main import \"fmt\" func main() { var array1 = [3]int {0, 1, 2} fmt.Println(array1) //[0 1 2] var array2 = [3]int {1} fmt.Println(array2) // [1 0 0] var array3 = [4]int {3:123} fmt.Println(array3) //[0 0 0 123] var array4 = [...]int {11, 9, 28, 900, 1332} fmt.Println(array4, len(array4), cap(array4)) //[11 9 28 900 1332] 5 5 } 数组是值类型，也就是当传递的时候会将值传递过去。引用类型是存储数据的内存地址。 值类型：基本数据类型 + 数组 + 结构体。可以使用==比较，前提是==左右两边是一致的数据类型，例如左边是[3]int右边是[4]int将会报错 引用类型：map + 切片 + channel ，也就是用make创建的都是引用类型，如果将另外一个该类型的变量传递过去，将会传递一个地址 num2 := 10 num3 := num2 num3 = 100 fmt.Println(num2, num3) //10, 100 因为基本数据类型都是值类型 //数组也是值类型 array := [3]int{1, 2, 3} array2 := array array2[0] = 100 fmt.Println(array, array2) //[1, 2, 3] [100, 2, 3] fmt.Println([3]int{1, 2, 3} == [4]int{0, 1, 2, 3}) //报错，因为数据类型就不匹配 fmt.Println([3]int{1, 2, 3} == [3]int{0, 1, 2}) //如果数据类型(包括数组长度以及元素的类型一致，才会依次比较下标对应位置的元素是否相同) 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-07-22 22:15:01 "},"golang/slice.html":{"url":"golang/slice.html","title":"切片","keywords":"","body":"切片切片创建从已有数组创建切片切片尾部添加元素切片遍历切片 切片同数组类似，也叫做变长数组或动态数组。 切片是一个引用类型的容器，因为切片本身不存储数据，是底层数组存取数据，因此指向了一个底层数组。可以使用fmt.Printf(\"%p\",切片名)查看切片指向的地址 切片即使元素个数超过cap也是可以的，因为会进行扩容。一旦扩容就会指向一个新的底层数组。同时每次扩容都会成倍增长。3->6->12->24->48 扩容过程：首先创建一个新的数组，将原来数组的内容拷贝到新的数组，然后添加新元素到新的数组 切片创建 使用make或者直接使用初始元素创建 func make(t Type, size ...IntergeType) Type 第一个参数：类型 第二个参数：长度len，切片实际存储的元素个数 第三个参数：容量cap，最多能够存储元素的个数 nums := make([]int, 4, 8) nums := []int {1, 2, 3, 4, 5} 从已有数组创建切片 此时切片指向该数组的一部分，此时修改数组或者修改切片都会造成另一方的修改。 nums := [10]int{1,2,3,4,5,6,7,8,9,10} //从头开始切片到底5个元素 s1 := nums[:5] //包含头不包含尾相当于从0取到5。，头不写则说明从头开始 fmt.Println(\"我们需要一个世界欢迎你但是我们需啊\") s2 := nums[6:] //如果取到最后则最后可以不写 s3 := s2 //s2存储的是nums[6]的地址，因此会将这个地址赋值一份给s3 案例代码： package main import \"fmt\" func main() { //创建数组 nums := [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10} //创建切片，切片指向的地址与数组的地址一致 s1 := nums[:5] //如果包含数组的头部则开始可以省略 s2 := nums[3:8] s3 := nums[5:] s4 := nums[:] fmt.Printf(\"s1 = %p, s2 = %p, s3 = %p, s4 = %p, nums = %p\\n\", s1, s2, s3, s4, &nums) fmt.Println() //长度和容量 fmt.Println(len(nums), cap(nums)) fmt.Println(len(s1), cap(s1)) fmt.Println(len(s2), cap(s2)) fmt.Println(len(s3), cap(s3)) fmt.Println(len(s4), cap(s4)) //修改数组中的一个元素,切片也会进行修改 nums[4] = 1000 fmt.Println(nums) fmt.Println(s1) fmt.Println(s2) fmt.Println(s3) fmt.Println(s4) //向s1添加元素 s1 = append(s1, 1, 1, 1, 1) //其实会修改数组后面的内容 fmt.Println(nums) fmt.Println(s1) fmt.Println(s2) fmt.Println(s3) //添加元素引起扩容,扩容会创建一个新的底层数组 s1 = append(s1, 99, 22, 33, 44) fmt.Println(nums) fmt.Println(s1) fmt.Println(s2) fmt.Println(s3) } 打印结果： s1 = 0xc00001e050, s2 = 0xc00001e068, s3 = 0xc00001e078, s4 = 0xc00001e050, nums = 0xc00001e050 10 10 5 10 5 7 5 5 10 10 [1 2 3 4 1000 6 7 8 9 10] [1 2 3 4 1000] [4 1000 6 7 8] [6 7 8 9 10] [1 2 3 4 1000 6 7 8 9 10] [1 2 3 4 1000 1 1 1 1 10] [1 2 3 4 1000 1 1 1 1] [4 1000 1 1 1] [1 1 1 1 10] [1 2 3 4 1000 1 1 1 1 10] [1 2 3 4 1000 1 1 1 1 99 22 33 44] [4 1000 1 1 1] [1 1 1 1 10] 切片尾部添加元素 如果要对长度以外的索引赋值需要使用内置函数append()添加，如果在长度以内的直接使用切片名[索引]赋值 由于append()添加后可能引起扩容，会返回一个切片的新地址，因此我们必须用原切片接收 方式1：append()后面可以加多个元素，将多个元素添加到切片中 方式2：append()后面可以加一个切片，将后面切片中的所有元素加入到切片中，并返回 nums = append(nums, 2, 3, 4) nums = append(nums2, nums...) 切片遍历 package main import \"fmt\" func main() { //定义一个切片 nums := []int{99, 18, 239, 109, 11, 3, 45} //遍历切片 //第一种方式遍历切片 for i := 0; i %d\\n\", i, val) } } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-07-22 15:31:56 "},"剑指offer/和为S的连续正数序列/code.html":{"url":"剑指offer/和为S的连续正数序列/code.html","title":"和为S的连续正数序列","keywords":"","body":"和为s的连续正数序列和为s的连续正数序列 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-08-03 15:02:16 "},"剑指offer/和为S的两个数字/code.html":{"url":"剑指offer/和为S的两个数字/code.html","title":"和为S的两个数字","keywords":"","body":"和为s的两个数字自己错误的解法：自己参照剑指offer思路写的代码和为s的两个数字 思路：给定了一个target，我们打印结束的条件肯定是找到target/2这个数字(也就是找到1到target中间的两个数字)，因为如果target为偶数，那么在target/2就结束了，并且如果target为奇数，也会在target/2结束，所以我们设置一个起始的值从1开始(因为是正数)，同时设置一个结束的值到2(因为连续)，并使用一个sum变量记录start到end之间的和。 步骤如下： 如果sum > target，那么肯定大了，sum-=small，同时我们将start右移1个单位 如果sum 如果sum == target，满足条件，我们组成start到end的一个切片，并将其放入结果中。之后因为后面还可能有满足条件的记录，因此我们将big++，不断重复如上步骤，直到small 自己错误的解法： 错误代码 找到一个就会返回结果 func findContinuousSequence(target int) [][]int { if target target { startVal, sum = startVal+1, sum-startVal fmt.Println(\"缩小值到目标值：\", startVal, endVal, sum) } else if sum 自己参照剑指offer思路写的代码 // 执行用时：0 ms, 在所有 Go 提交中击败了 100.00% 的用户 // 内存消耗：2.2 MB, 在所有 Go 提交中击败了 100.00% 的用户 //参照剑指offer思路代码写的 func findContinuousSequence2(target int) [][]int { if target > 1 for startVal 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-08-03 15:11:51 "},"剑指offer/对称的二叉树/code.html":{"url":"剑指offer/对称的二叉树/code.html","title":"对称的二叉树","keywords":"","body":"对称的二叉树对称的二叉树 思路：不断的递归遍历当前节点与另一个对应位置的节点，若当前节点与对应位置的节点满足如下条件： 当前节点与对应位置的节点都为空，返回true 当前节点与对应位置的节点有一个为空，返回false 当前节点的值与对应位置节点的值不等，返回false 如果到这里说明当前节点的值与对应位置节点的值相等，此时再递归比较当前节点的左子树与对应位置节点的右子树和当前节点的右子树与对应位置节点的左子树 // 执行用时：4 ms, 在所有 Go 提交中击败了 74.42% 的用户 // 内存消耗：2.9 MB, 在所有 Go 提交中击败了 100.00% 的用户 package main import \"fmt\" //参照剑指offer思路的写法 func isSymmetric(root *TreeNode) bool { return isSymmetricCore(root, root) } func isSymmetricCore(root1, root2 *TreeNode) bool { if root1 == nil && root2 == nil { return true } if root1 == nil || root2 == nil { return false } if root1.Val != root2.Val { return false } return isSymmetricCore(root1.Left, root2.Right) && isSymmetricCore(root1.Right, root2.Left) } func main() { } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-08-03 15:33:26 "}}
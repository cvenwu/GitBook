{"./":{"url":"./","title":"Introduction","keywords":"","body":"GitBookGitBook 记录>以及LeetCode刷题笔记 在线查看 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/":{"url":"剑指offer/","title":"剑指offer","keywords":"","body":" 记录剑指offer刷题笔记 刷题进度表 TODO: 从尾到头打印链表 旋转数组的最小数字 22，24， 25，32(BFS)的递归写法 56-II 的第2个方法(自动机) 3 题后面的拓展题目没看也没写 4题的递归思路没有写 55-I 非递归自己可以写一下，剑指offer提供了递归写法 55-II 使用递归我们重复遍历了很多节点，因此我们采用后序遍历，但是自己没有写出来 54可以改进，时间效率太低 题号 题目名称 解决时间 疑问 笔记 数组中重复的数字 数组中重复的数字 二维数组中的查找 二维数组中的查找 替换空格 2020-07-25 替换空格 从尾到头打印链表 2020-07-18 从尾到头打印链表 重建二叉树 用两个栈实现队列 2020-07-18 两个栈实现队列 斐波那契数列 2020-07-15 斐波那契数列 青蛙跳台阶问题 2020-07-15 青蛙跳台阶问题 旋转数组的最小数字 矩阵中的路径 2020-09-12 矩阵中的路径 机器人的运动范围 2020-09-12 机器人的运动范围 剪绳子 2020-07-18 剪绳子 剪绳子 II 二进制中1的个数 2020-07-15 二进制中1的个数 数值的整数次方 2020-08-07 数值的整数次方 打印从1到最大的n位数 删除链表的节点 删除链表的节点 正则表达式匹配 表示数值的字符串 调整数组顺序使奇数位于偶数前面 2020-07-19 调整数组顺序使奇数位于偶数前面 链表中倒数第k个节点 2020-07-18 链表中倒数第k个节点 反转链表 合并两个排序的链表 树的子结构 2020-09-12 树的子结构 二叉树的镜像 2020-07-26 二叉树的镜像 对称的二叉树 顺时针打印矩阵 2020-09-16 顺时针打印矩阵 包含min函数的栈 包含min函数的栈 栈的压入、弹出序列 2020-07-19 栈的压入、弹出序列 从上到下打印二叉树 2020-08-06 从上到下打印二叉树 从上到下打印二叉树 II 2020-08-06 从上到下打印二叉树II 从上到下打印二叉树 III 2020-08-06 从上到下打印二叉树III 重点：提交6次错5次 二叉搜索树的后序遍历序列 2020-08-07 二叉搜索树的后序遍历序列 二叉树中和为某一值的路径 2020-08-07 二叉树中和为某一值的路径 复杂链表的复制 2020-09-20 复杂链表的复制 二叉搜索树与双向链表 序列化二叉树 字符串的排列 数组中出现次数超过一半的数字 2020-09-08 数组中出现次数超过一半的数字 最小的k个数 2020-09-12 最小的k个数 数据流中的中位数 2020-09-20 数据流中的中位数 连续子数组的最大和 连续子数组的最大和 1～n整数中1出现的次数 数字序列中某一位的数字 把数组排成最小的数 把数字翻译成字符串 礼物的最大价值 礼物的最大价值 最长不含重复字符的子字符串 2020-09-20 最长不含重复字符的子字符串 丑数 2020-09-20 丑数 第一个只出现一次的字符 2020-08-08 第一个只出现一次的字符 数组中的逆序对 两个链表的第一个公共节点 2020-07-18 两个链表的第一个公共节点 在排序数组中查找数字 I 0～n-1中缺失的数字 数组中数值和下标相等的元素 2020-08-04 数组中数值和下标相等的元素 二叉搜索树的第k大节点 二叉搜索树的第k大节点 二叉树的深度 平衡二叉树 2020-07-30 平衡二叉树 数组中数字出现的次数 2020-07-18 数组中数字出现的次数 数组中数字出现的次数 II 2020-07-17 数组中数字出现的次数II 和为s的两个数字 2020-07-27 和为s的两个数字 和为s的连续正数序列 2020-08-01 和为s的连续正数序列 翻转单词顺序 2020-08-01 翻转单词顺序 左旋转字符串 2020-08-01 坐旋转字符串 滑动窗口的最大值 2020-08-01 滑动窗口的最大值 队列的最大值 2020-08-01 队列的最大值 n个骰子的点数 2020-09-1 扑克牌中的顺子 2020-09-13 扑克牌中的顺子 圆圈中最后剩下的数字 股票的最大利润 2020-07-17 股票的最大利润 求1+2+…+n 不用加减乘除做加法 2020-07-18 不用加减乘除做加法 构建乘积数组 二叉搜索树的最近公共祖先 2020-09-08 二叉搜索树的最近公共祖先 二叉树的最近公共祖先 2020-09-07 二叉树的最近公共祖先 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/总结.html":{"url":"剑指offer/总结.html","title":"总结书上的笔记","keywords":"","body":"算法和数据操作位运算递归与循环算法和数据操作 排序和查找中应该重点掌握：二分查找，归并排序，快速排序 如果面试题要求在二维数据上搜索路径，我们可以尝试使用回溯法，当面试官限定不可以用递归时，我们考虑用栈模拟递归实现。 如果面试题是求某个问题的最优解，并且该问题可以分解为多个子问题，我们可以尝试使用动态规划，在自上而下的递归思路分析问题时，发现存在大量重复子问题，因此为了避免不必要的重复计算，我们使用从下往上的循环实现。一般就是使用一维或二维数组保存计算下来的最优解，接下来解决更大的问题 如果告诉面试官动态规划思路之后，面试官还在提醒说分解子问题的时候是不是存在某个特殊选择，如果采用这个特殊选择一定可以得到最优解，那么这意味着该面试题适用于贪婪算法。 位运算 把一个整数减去1之后再和原来的整数做位与运算，得到的结果相当于把整数的二进制表示中最右边的1编程0 一个数字左移1位之后右边补0，但是进行右移时，如果是无符号的则在左边补0，否则补上符号位(整数补0，负数补1)，算术右移补上符号位，逻辑右移不用补符号位 递归与循环 面试的时候，如果面试官没有特别要求，应聘者可以尽量多的采用递归方法编程。因为递归实现的代码简洁很多 递归缺点：递归是函数调用自身，而函数调用自身有时间和空间消耗，每一次函数调用，都要在内存占中分配空间以保存参数，返回地址以及临时变量，而且往栈中压入数据和弹出数据都需要时间。除此之外，递归涉及到了大量的重复计算。 通常应用动态规划解决问题时，我们都是采用递归的思路进行分析，但是在实现的时候我们采用从下往上来避免大量的重复计算。 除效率之外，递归还有可能引起更严重的问题：调用栈溢出，因为每个进程的栈容量有限，当递归调用层级太多，会超出栈容量。 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/数组中重复的数字/code.html":{"url":"剑指offer/数组中重复的数字/code.html","title":"数组中重复的数字","keywords":"","body":"数组中重复的数字数组中重复的数字 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/二维数组的查找/code.html":{"url":"剑指offer/二维数组的查找/code.html","title":"二维数组的查找","keywords":"","body":"版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/替换空格/code.html":{"url":"剑指offer/替换空格/code.html","title":"替换空格","keywords":"","body":"替换空格替换空格 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/从尾到头打印链表/code.html":{"url":"剑指offer/从尾到头打印链表/code.html","title":"从尾到头打印链表","keywords":"","body":"从尾到头打印链表方法一：方法二：从尾到头打印链表 方法一： 思路：使用栈存储遍历结果，之后再输出栈的结果。 衍生：既然想到使用栈，递归也是天然的栈，因此我们可以考虑使用递归 方法二： 思路：反转链表再打印。需要征得面试官同意是否可以更改链表 总结：对于使用栈，我们可以想到递归，因为递归也是栈的一种应用场景。同时对于方法二需要修改输入的链表，我们事先需要征得面试官同意 方法 时间复杂度 空间复杂度 方法一 o(n) o(n) 方法二 o(n) o(1) 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/重建二叉树/code.html":{"url":"剑指offer/重建二叉树/code.html","title":"重建二叉树","keywords":"","body":"重建二叉树重建二叉树 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/用两个栈实现队列/code.html":{"url":"剑指offer/用两个栈实现队列/code.html","title":"用两个栈实现队列","keywords":"","body":"用两个栈实现队列方法一：使用container/list方法二：使用切片用两个栈实现队列 思路： 准备1个输入数据的栈，1个输出数据的栈 当加入元素的时候直接加入到输入数据栈中 当弹出元素的时候，分为如下几种情况， 如果输出数据栈不为空，直接弹出 如果输出数据栈为空，将输入数据栈所有元素加入到输出数据栈中，再返回输出数据栈栈顶元素 方法一：使用container/list //执行用时：252 ms, 在所有 Go 提交中击败了 54.16% 的用户 //内存消耗：8.1 MB, 在所有 Go 提交中击败了 100.00% 的用户 type CQueue struct { InputStack, OutputStack *list.List } func Constructor() CQueue { return CQueue{list.New(), list.New()} } func (this *CQueue) AppendTail(value int) { //直接将元素加入到输入栈中 this.InputStack.PushBack(value) } func (this *CQueue) DeleteHead() int { //如果输出栈有元素，直接删除 //否则需要将输入栈全部元素导入到输出栈，然后删除输出栈的元素 if this.OutputStack.Len() == 0 { //以下3行代码必须这样写 //或者可以写成this.OutputStack.PushBack(this.InputStack.Remove(this.InputStack.Back())) for this.InputStack.Len() > 0 { this.OutputStack.PushBack(this.InputStack.Remove(this.InputStack.Back())) } } if this.OutputStack.Len() != 0 { return this.OutputStack.Remove(this.OutputStack.Back()).(int) } return -1 //说明输入栈以及输出栈没有任何内容 } 方法二：使用切片 //执行用时：256 ms, 在所有 Go 提交中击败了 47.47% 的用户 //内存消耗：8.3 MB, 在所有 Go 提交中击败了 100.00% 的用户 type CQueue struct { InputSlice []int OutputSlice []int } func Constructor() CQueue { return CQueue{ make([]int, 0), make([]int, 0), } } func (this *CQueue) AppendTail(value int) { this.InputSlice = append(this.InputSlice, value) } func (this *CQueue) DeleteHead() int { //得到InputSlice以及OutputSlice的大小 lengthInputSlice, lengthOutputSlice := len(this.InputSlice), len(this.OutputSlice) //如果输出有元素直接输出 if lengthOutputSlice > 0 { ele := this.OutputSlice[lengthOutputSlice-1] this.OutputSlice = this.OutputSlice[0:lengthOutputSlice-1] return ele } else { //如果输出没有元素将输入的元素全部加入进去 for lengthInputSlice > 0 { this.OutputSlice = append(this.OutputSlice, this.InputSlice[lengthInputSlice-1]) this.InputSlice = this.InputSlice[0:lengthInputSlice-1] lengthInputSlice, lengthOutputSlice = lengthInputSlice - 1, lengthOutputSlice + 1 } } if lengthOutputSlice > 0 { ele := this.OutputSlice[lengthOutputSlice-1] this.OutputSlice = this.OutputSlice[0:lengthOutputSlice-1] lengthOutputSlice = lengthOutputSlice - 1 return ele } //如果输入也没有元素返回-1 return -1 } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/斐波那契数列/code.html":{"url":"剑指offer/斐波那契数列/code.html","title":"斐波那契数列","keywords":"","body":"斐波那契数列方法一：递归方法二：动态规划额外的补充斐波那契数列 注意题目要求：答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 原因：参考 方法一：递归 提交到LeetCode上超时 func fib(n int) int { //递归终止条件1 if n 方法二：动态规划 // 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 // 内存消耗：1.9 MB, 在所有 Go 提交中击败了100.00%的用户 func fib(n int) int { if n 对方法2代码的改进，参考 func fib(n int) int { a, b := 0, 1 for i := 0; i 额外的补充 除以上的两种方法之外还有另外的一种时间复杂度为O(log n)的解法，这里不再进行赘述。 总结：采用递归的思路分析问题，采用由下往上的思路解决问题 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/青蛙跳台阶问题/code.html":{"url":"剑指offer/青蛙跳台阶问题/code.html","title":"青蛙跳台阶问题","keywords":"","body":"青蛙跳台阶问题青蛙跳台阶问题-II青蛙跳台阶问题 题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 思路与斐波那契数列一致，但是注意斐波那契数列中fib(0)=0，而这里numWays(0)返回1 注意斐波那契数列中fib(0)=0，而这里numWays(0)返回1 func numWays(n int) int { minusOneStep, minusTwoStep := 1, 1 for i := 0; i 注意题目中要求：答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 青蛙跳台阶问题-II 题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶........它也可以跳上n级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 跳上1级台阶：1 跳上2级台阶：2 跳上3级台阶：4 跳上4级台阶：8 跳上5级台阶：16 跳上6级台阶：32 跳上7级台阶：64 总结规律：跳上n级台阶：2^(n-1) 数学归纳法可以证明f(n)=2^(n-1) func numWays(n int) int { return (1 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/矩阵中的路径/code.html":{"url":"剑指offer/矩阵中的路径/code.html","title":"矩阵中的路径","keywords":"","body":"剑指 Offer 12. 矩阵中的路径方法一：DFS方法二：dfs改进剑指 Offer 12. 矩阵中的路径 方法一：DFS 通过visited记录是否访问过 执行用时：8 ms, 在所有 Go 提交中击败了 30.06% 的用户 内存消耗：3.7 MB, 在所有 Go 提交中击败了 11.61% 的用户 func exist(board [][]byte, word string) bool { row, col := len(board), len(board[0]) visited := make([][]bool, row) for i := 0; i = row || rowIndex = col || colIndex 方法二：dfs改进 改进点：使用一个变量临时存储我们要遍历的字符，如果访问过将该节点的值置换为'/'，之后重新回到该节点将其替换为原来的值 执行用时：4 ms, 在所有 Go 提交中击败了 98.06% 的用户 内存消耗：3.3 MB, 在所有 Go 提交中击败了 85.61% 的用户 func exist(board [][]byte, word string) bool { row, col := len(board), len(board[0]) for i := 0; i = row || rowIndex = col || colIndex 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/机器人的运动范围/code.html":{"url":"剑指offer/机器人的运动范围/code.html","title":"机器人的运动范围","keywords":"","body":"剑指 Offer 13. 机器人的运动范围方法一：回溯方法二：回溯改进剑指 Offer 13. 机器人的运动范围 方法一：回溯 执行用时：0 ms, 在所有 Go 提交中击败了 100.00% 的用户 内存消耗：2.7 MB, 在所有 Go 提交中击败了 40.52% 的用户 func movingCount(m int, n int, k int) int { //定义一个visited数组，并且置默认值为false visited := make([][]bool, m) for i := 0; i = m || colIndex >= n || rowIndex k { return } visited[rowIndex][colIndex] = true backtrack(visited, rowIndex+1, colIndex, m, n, k) backtrack(visited, rowIndex-1, colIndex, m, n, k) backtrack(visited, rowIndex, colIndex+1, m, n, k) backtrack(visited, rowIndex, colIndex-1, m, n, k) return } //计算各位数的和 func getDigitSum(num int) int { sum := 0 for num != 0 { sum += (num % 10) num /= 10 } return sum } 方法二：回溯改进 改进： 修改backtrack函数的返回值，我们不需要统计visited为true的元素个数，我们直接调用它返回结果即可， 如果当前节点没有越界，数位之和小于k并且没有访问过就返回1 + 当前节点的上下左右递归 执行用时：0 ms, 在所有 Go 提交中击败了 100.00% 的用户 内存消耗：2.7 MB, 在所有 Go 提交中击败了 39.66% 的用户 func movingCount(m int, n int, k int) int { //定义一个visited数组，并且置默认值为false visited := make([][]bool, m) for i := 0; i = m || colIndex >= n || rowIndex k { return 0 } visited[rowIndex][colIndex] = true return 1 + backtrack(visited, rowIndex+1, colIndex, m, n, k) + backtrack(visited, rowIndex-1, colIndex, m, n, k) + backtrack(visited, rowIndex, colIndex+1, m, n, k) + backtrack(visited, rowIndex, colIndex-1, m, n, k) } //计算各位数的和 func getDigitSum(num int) int { sum := 0 for num != 0 { sum += (num % 10) num /= 10 } return sum } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/二进制中1的个数/code.html":{"url":"剑指offer/二进制中1的个数/code.html","title":"二进制中1的个数","keywords":"","body":"二进制中1的个数方法一：方法二：拓展题目：一条语句判断1个数是不是2的整数次方输入两个整数m和n，计算需要改变m的二进制表示中的多少位才能得到n？二进制中1的个数 方法一： func hammingWeight2(num uint32) int { var flag uint32 = 1 count := 0 for i := 0; i 方法二： func hammingWeight(num uint32) int { count := 0 for num != 0{ count += 1 num = num & (num - 1) } return count } Tips：一个数字左移1位之后右边补0，但是进行右移时，如果是无符号的则在左边补0，否则补上符号位(整数补0，负数补1)，算术右移补上符号位，逻辑右移不用补符号位 这两个解法都是通用的，不仅仅针对于无符号整数，也针对有符号整数，方法一我们不希望右移，因为右移对于负数会补1，后面会陷入无限循环。所以我们可以设置一个flag不断左移进行判断每一位是否为1 拓展题目： 一条语句判断1个数是不是2的整数次方 如果这个数是2的整数次方，一定这个数不为0并且这个数的二进制表示中只有1个1 (num != 0) && (num & (num - 1) == 0) func isPowerOfTwo(num int) bool { if num != 0 && (num & (num - 1)) == 0 { return true } return false } 输入两个整数m和n，计算需要改变m的二进制表示中的多少位才能得到n？ 思路： 采用异或求两个数字二进制表示中的不同位 之后统计异或结果二进制表示中1的数目 func numOfChangeBits(m int, n int) int { //求两个数字的异或 ret := m ^ n //统计ret中位1的个数 count := 0 for ret != 0 { count += 1 ret &= (ret - 1) } return count } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/数值的整数次方/code.html":{"url":"剑指offer/数值的整数次方/code.html","title":"数值的整数次方","keywords":"","body":"数值的整数次方数值的整数次方 思路：传入一个数以及对应的指数，返回数值的整数次方，有如下几种情况 指数为0，直接返回1 传入的数值为0，但是指数为负数，此时会让分母为0，返回-1，即错误情况 如果指数为负数，使用flag进行标记，转换为正数计算结果，最后返回的时候判断flag后确定是否返回倒数 之前写的错误代码： func myPow(x float64, n int) float64 { //如果x是0并且n等于负数，非法情况，返回-1 if x == 0 && n >1) if n&1 != 0 { //说明指数是奇数 ret = ret * ret * x } if flag { ret = 1.0 / ret } return ret } 错误原因在于： 第一次编写该代码，出错。错误原因在于if n&1 != 0这个代码块中，如果不为奇数，那么只会返回一个1，而不是ret*ret 正确代码： // 执行用时：0 ms, 在所有 Go 提交中击败了 100.00% 的用户 // 内存消耗：2 MB, 在所有 Go 提交中击败了 66.67% 的用户 func myPow(x float64, n int) float64 { //如果x是0并且n等于负数，非法情况，返回-1 if x == 0 && n >1) ret *= ret if n&1 != 0 { //说明指数是奇数 ret *= x } if flag { ret = 1.0 / ret } return ret } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/删除链表的节点/code.html":{"url":"剑指offer/删除链表的节点/code.html","title":"删除链表的节点","keywords":"","body":"删除链表的节点自己写的代码LeetCode上的简洁解法删除链表的节点 思路： 如果要删除的节点是头节点，直接返回头节点的下一个节点 如果删除的是中间节点或者尾节点，通过遍历找到要删除节点的上一个节点，将指针指向要删除节点的下一个节点 自己写的代码 剑指offer函数参数传入了要删除的节点，因此不用再去遍历一次去确认要删除的节点是否在末尾 // 执行用时：4 ms, 在所有 Go 提交中击败了 75.15% 的用户 // 内存消耗：2.9 MB, 在所有 Go 提交中击败了 100.00% 的用户 func deleteNode(head *ListNode, val int) *ListNode { //首先判断链表是否为空 if head == nil { return nil } //如果删除头节点 if head.Val == val { //如果链表只有1个节点 if head.Next == nil { return nil } else { node := head.Next head.Next = nil return node } } node := head //否则找到要删除的节点的前一个节点 for node.Next != nil && node.Next.Val != val { node = node.Next } //如果没找到 if node.Next == nil { return head } //说明找到了 if node.Next.Next != nil { //说明删除的不是尾节点 node.Next = node.Next.Next } else { //说明要删除的是尾节点 node.Next = nil } return head } LeetCode上的简洁解法 func deleteNode(head *ListNode, val int) *ListNode { //如果删除的是头节点(包含只有1个节点以及多个节点) if head.Val==val{ return head.Next } //如果删除的是中间节点或者尾节点 for pre, p := head, head.Next; p != nil; p = p.Next{ if p.Val == val{ pre.Next = p.Next return head } pre = pre.Next } return head } 总结：删除链表中节点，如果函数传入了删除的节点，如果该节点位于中间，直接将值修改成后面节点的值，然后将指针指向下下个节点即可。 特殊情况： 链表只有1个节点，且删除该节点 链表中有多个节点，且删除头节点 链表中有多个节点，且删除尾节点 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/调整数组顺序使奇数位于偶数前面/code.html":{"url":"剑指offer/调整数组顺序使奇数位于偶数前面/code.html","title":"调整数组顺序使奇数位于偶数前面","keywords":"","body":"调整数组顺序使奇数位于偶数前面调整数组顺序使奇数位于偶数前面 思路：采用双指针，左指针最开始指向数组最左边元素，右指针指向最右边元素。 条件1：当左指针指向的数为奇数，则左指针右移 条件2：当右指针指向的数为偶数，则右指针左移 当左指针指向的数为偶数，右指针指向的数为奇数则交换，同时移动左右指针，注意这个条件必须在最前面， 注意两个数交换必须在条件1和条件2之前，因为一旦移动，那么我们交换有可能左指针已经在右指针右边了 // 执行用时：24 ms, 在所有 Go 提交中击败了 87.81% 的用户 // 内存消耗：6.4 MB, 在所有 Go 提交中击败了 100.00% 的用户 func exchange(nums []int) []int { //如果给了一个空数组 //这个if成立的时候for循环也不会执行，因此这个if可以不写 if len(nums) == 0 { return []int{} } //odd用来做奇数，even用来做偶数 odd, even := 0, len(nums) - 1 for odd Tips：代码块1一定要在代码块2和代码块3前面，否则对于下面输入会报错 [11,9,3,7,16,4,2,0] ​ 错误将会输出 [11,9,3,16,7,4,2,0] ​ 预期结果是[11,9,3,7,16,4,2,0] 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/链表中倒数第k个节点/code.html":{"url":"剑指offer/链表中倒数第k个节点/code.html","title":"链表中倒数第k个节点","keywords":"","body":"链表中倒数第k个节点方法一：栈存放遍历链表的数据方法二：两次遍历链表方法三[推荐]：双指针链表中倒数第k个节点 方法一：栈存放遍历链表的数据 衍生思路：递归 既然递归是天然的栈，我们不由想到使用递归解决 方法二：两次遍历链表 思路：第一次遍历链表统计长度，第二次遍历到第n - k + 1个节点(走n-k步)的时候就是我们想要的节点，直接返回 //执行用时：0 ms, 在所有 Go 提交中击败了100.00% 的用户 //内存消耗：2.2 MB, 在所有 Go 提交中击败了 100.00% 的用户 func getKthFromEnd(head *ListNode, k int) *ListNode { //如果链表为空或者k为非正数 if head == nil || k 方法三[推荐]：双指针 思路：使用双指针，保持两个指针的距离为k-1。 原因：第1个指针与第2个指针的距离为k-1，当第1个指针遍历到尾，第2个指针正好在倒数第k个节点上 //执行用时：0 ms, 在所有 Go 提交中击败了100.00% 的用户 //内存消耗：2.2 MB, 在所有 Go 提交中击败了 100.00% 的用户 //方法3：双指针，第1个指针先走k-1步，之后两个指针开始走，当第1个指针走到最后一个，第2个指针便是倒数第k个节点 func getKthFromEnd(head *ListNode, k int) *ListNode { //如果链表不存在怎么办 //如果k是一个非正数怎么办 if head == nil || k 方法三相比于方法二，只需要遍历一次链表，相比于方法一以及其衍生方法并且不需要额外的空间复杂度 总结：对于链表题目，双指针作为一种常用的解题思路有大量的应用，例如快慢指针，维持固定距离的两个指针等思想 链表无法高效获取长度，无法根据偏移快速访问元素，是链表的两个劣势。然而面试的时候经常碰见诸如获取倒数第k个元素，获取中间位置的元素，判断链表是否存在环，判断环的长度等和长度与位置有关的问题。这些问题都可以通过灵活运用双指针来解决。 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/树的子结构/code.html":{"url":"剑指offer/树的子结构/code.html","title":"树的子结构","keywords":"","body":"剑指 Offer 26. 树的子结构方法一：DFS剑指 Offer 26. 树的子结构 方法一：DFS 参考剑指offer代码写的代码 思路：递归 首先判断当前A节点的值是否与b节点的值相等，如果相等执行判断结构是否相同的函数 如果不等，则递归到A的左子树是否包括b的结构 或 递归到A的右子树是否包括b的结构 执行用时：24 ms, 在所有 Go 提交中击败了 95.45% 的用户 内存消耗：7.3 MB, 在所有 Go 提交中击败了 13.54% 的用户 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func isSubStructure(A *TreeNode, B *TreeNode) bool { ret := false if A != nil && B != nil { //如果两个节点的值相同 if A.Val == B.Val { ret = hasSameSubTreeStructure(A, B) } //如果前面判断了A和B根相同是结构不同返回false,那么这次遍历左子树 if !ret { ret = isSubStructure(A.Left, B) } if !ret { ret = isSubStructure(A.Right, B) } } return ret } //B左右两个分支如果有，A一定要有且值要和B分支值相等 func hasSameSubTreeStructure(A, B *TreeNode) bool { //如果B空，返回true if B == nil { return true } //遍历到这里说明B不空，但此时A空了，直接返回false即可 if A == nil { return false } //两个节点都有值但是值不等，返回false if A.Val != B.Val { return false } //后面继续递归判断 return hasSameSubTreeStructure(A.Left, B.Left) && hasSameSubTreeStructure(A.Right, B.Right) } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/二叉树的镜像/code.html":{"url":"剑指offer/二叉树的镜像/code.html","title":"二叉树的镜像","keywords":"","body":"二叉树的镜像方法一：递归方法二：采用先序遍历反转二叉树的镜像 方法一：递归 思路：每次不断反转当前节点的左右子树，直到当前节点为空 // 执行用时：0 ms, 在所有 Go 提交中击败了 100.00% 的用户 // 内存消耗：2.1 MB, 在所有 Go 提交中击败了 100.00% 的用户 func mirrorTree(root *TreeNode) *TreeNode { if root == nil { return nil } //直接换 root.Left, root.Right = root.Right, root.Left mirrorTree(root.Left) mirrorTree(root.Right) return root } 方法二：采用先序遍历反转 思路： 采用先序遍历的方式，先弹出队列的队首，然后将当前节点的左右反转 如果当前节点的左边不为空，则将当前节点的左边加入队列 如果当前节点的右边不为空，则将当前节点的右边加入队列 // 执行用时：0 ms, 在所有 Go 提交中击败了 100.00% 的用户 // 内存消耗：2.1 MB, 在所有 Go 提交中击败了 100.00% 的用户 func mirrorTree(root *TreeNode) *TreeNode { if root == nil { return nil } queue := []*TreeNode{} queue = append(queue, root) for len(queue) > 0 { node := queue[0] queue = queue[1:] //反转node的左右 node.Left, node.Right = node.Right, node.Left //如果左不为空，则加入队列 if node.Left != nil { queue = append(queue, node.Left) } //如果右不为空，则加入队列 if node.Right != nil { queue = append(queue, node.Right) } } return root } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/对称的二叉树/code.html":{"url":"剑指offer/对称的二叉树/code.html","title":"对称的二叉树","keywords":"","body":"对称的二叉树对称的二叉树 思路：不断的递归遍历当前节点与另一个对应位置的节点，若当前节点与对应位置的节点满足如下条件： 当前节点与对应位置的节点都为空，返回true 当前节点与对应位置的节点有一个为空，返回false 当前节点的值与对应位置节点的值不等，返回false 如果到这里说明当前节点的值与对应位置节点的值相等，此时再递归比较当前节点的左子树与对应位置节点的右子树和当前节点的右子树与对应位置节点的左子树 // 执行用时：4 ms, 在所有 Go 提交中击败了 74.42% 的用户 // 内存消耗：2.9 MB, 在所有 Go 提交中击败了 100.00% 的用户 package main import \"fmt\" //参照剑指offer思路的写法 func isSymmetric(root *TreeNode) bool { return isSymmetricCore(root, root) } func isSymmetricCore(root1, root2 *TreeNode) bool { if root1 == nil && root2 == nil { return true } if root1 == nil || root2 == nil { return false } if root1.Val != root2.Val { return false } return isSymmetricCore(root1.Left, root2.Right) && isSymmetricCore(root1.Right, root2.Left) } func main() { } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/顺时针打印矩阵/code.html":{"url":"剑指offer/顺时针打印矩阵/code.html","title":"顺时针打印矩阵","keywords":"","body":"剑指 Offer 29. 顺时针打印矩阵方法：四个角不断定边界不断缩小范围剑指 Offer 29. 顺时针打印矩阵 方法：四个角不断定边界不断缩小范围 参考 思路：通过左上角，右上角，左下角，右下角4个点不断收缩来确定打印范围 func spiralOrder(matrix [][]int) []int { if len(matrix) == 0 || len(matrix[0]) == 0 { return nil } l, r, t, d := 0, len(matrix[0])-1, 0, len(matrix)-1 res := []int{} for { //打印上面一行 for i := l; i d { break } for i := t; i r { break } for i := r; i >= l; i-- { res = append(res, matrix[d][i]) } d -= 1 if t > d { break } for i := d; i >= t; i-- { res = append(res, matrix[i][l]) } l += 1 if l > r { break } } return res } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/包含min函数的栈/code.html":{"url":"剑指offer/包含min函数的栈/code.html","title":"包含min函数的栈","keywords":"","body":"包含min函数的栈方法一：使用container/list方法二：使用slice包含min函数的栈 根据slice或container/list实现还有push的两种可能一共有4种解法 思路：根据加入的当前元素，在push时有如下两种可能 当加入的元素大于最小值栈顶元素，最小值栈顶元素不加入，否则加入 。弹出的时候需要将弹出的元素与最小值栈顶元素比较，如果相等，都弹出，否则只弹出数据栈的元素 当加入的元素大于最小值栈顶元素，最小值栈顶元素加入当前的最小值栈顶元素。弹出的时候一起弹出 方法一：使用container/list 思路：当加入的元素大于最小值栈顶元素，最小值栈顶元素加入当前的最小值栈顶元素 // 执行用时：20 ms, 在所有 Go 提交中击败了 79.64% 的用户 // 内存消耗：7.7 MB, 在所有 Go 提交中击败了 100.00% 的用户 type MinStack struct { //一个数据栈，一个最小值栈 DataStack, MinValueStack *list.List } /** initialize your data structure here. */ func Constructor() MinStack { return MinStack{list.New(), list.New()} } func (this *MinStack) Push(x int) { this.DataStack.PushBack(x) //如果最小值栈没有元素直接加入 if this.MinValueStack.Len() == 0 { this.MinValueStack.PushBack(x) return } //最小值栈不为空的情况 //如果x超过最小值，也要将最小值栈栈顶重新加入最小值栈栈顶 minValueStackTop := this.MinValueStack.Back().Value.(int) if x > minValueStackTop { this.MinValueStack.PushBack(minValueStackTop) } else { this.MinValueStack.PushBack(x) } } func (this *MinStack) Pop() { //如果数据栈没有内容直接不弹出 if this.DataStack.Len() != 0 { this.DataStack.Remove(this.DataStack.Back()) this.MinValueStack.Remove(this.MinValueStack.Back()) } } func (this *MinStack) Top() int { return this.DataStack.Back().Value.(int) } func (this *MinStack) Min() int { return this.MinValueStack.Back().Value.(int) } 方法二：使用slice 思路：当加入的元素大于最小值栈顶元素，最小值栈顶元素不加入，否则加入 。弹出的时候需要将弹出的元素与最小值栈顶元素比较，如果相等，都弹出，否则只弹出数据栈的元素 // 执行用时：24 ms, 在所有 Go 提交中击败了 45.81% 的用户 // 内存消耗：8.1 MB, 在所有 Go 提交中击败了 100.00% 的用户 type MinStack struct { DataStack, MinValueStack []int } /** initialize your data structure here. */ func Constructor() MinStack { return MinStack{[]int{}, []int{}} } func (this *MinStack) Push(x int) { this.DataStack = append(this.DataStack, x) //如果当前最小值栈为空，直接加入 if len(this.MinValueStack) == 0 { this.MinValueStack = append(this.MinValueStack, x) return } //如果x大于当前最小栈栈顶元素就不加入 if x 0 { //并且当数据栈栈顶元素等于最小值栈顶元素就弹出 if this.MinValueStack[len(this.MinValueStack) - 1] == this.DataStack[len(this.DataStack) - 1] { this.MinValueStack = this.MinValueStack[:len(this.MinValueStack) - 1] } this.DataStack = this.DataStack[:len(this.DataStack) - 1] } } func (this *MinStack) Top() int { return this.DataStack[len(this.DataStack) - 1] } func (this *MinStack) Min() int { return this.MinValueStack[len(this.MinValueStack) - 1] } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/栈的压入、弹出序列/code.html":{"url":"剑指offer/栈的压入、弹出序列/code.html","title":"栈的压入、弹出序列","keywords":"","body":"栈的压入、弹出序列代码一：代码二：栈的压入、弹出序列 思路：使用一个辅助栈模拟真实栈的操作 步骤如下： 如果需要加入的切片不为空，就加入 辅助栈栈顶元素与弹出的元素一致，则弹出，循环此步骤直到辅助栈栈顶元素与弹出的元素不一致 循环1，2步骤，直到所有元素加入完成。 此时判断辅助栈是否为空，如果为空则返回true否则返回false 代码一： // 执行用时：8 ms, 在所有 Go 提交中击败了 82.92% 的用户 // 内存消耗：3.8 MB, 在所有 Go 提交中击败了 100.00% 的用户 func validateStackSequences(pushed []int, popped []int) bool { //记录输入两个slice的长度 lengthPushed, lengthPopped := len(pushed), len(popped) //如果两个长度不一致 if lengthPushed != lengthPopped { return false } //使用一个栈来模拟栈的行为 stack, length := []int{}, 0 //将pushed所有元素压入 for lengthPushed > 0 { //元素压入栈 stack, length = append(stack, pushed[0]), length + 1 //pushed删除该元素 pushed, lengthPushed = pushed[1:], lengthPushed - 1 //push元素之后比较压入的元素与pop元素是否同，如果同就弹出，否则继续压入 //不用判断lengthPopped是否为0，因为如果为0肯定stack也没有元素 for (length != 0) && (stack[length - 1] == popped[0]) { stack, length, popped, lengthPopped = stack[:length - 1], length - 1, popped[1:], lengthPopped - 1 } } //如果所有元素压入之后，stack的栈顶依然与popped的第1个元素不同，直接返回false //上述条件等价于如果栈中还有元素，直接返回false if length != 0 { return false } return true } 代码二： 优点：相比于代码一，使用for-range将pushed元素加入到stack // 执行用时：4 ms, 在所有 Go 提交中击败了 99.69% 的用户 // 内存消耗：3.8 MB, 在所有 Go 提交中击败了 100.00% 的用户 func validateStackSequences(pushed []int, popped []int) bool { //记录输入两个slice的长度 lengthPushed, lengthPopped := len(pushed), len(popped) //如果两个长度不一致 if lengthPushed != lengthPopped { return false } //使用一个栈来模拟栈的行为 stack, length := []int{}, 0 for _, value := range pushed { //元素压入栈 stack, length = append(stack, value), length + 1 //当前栈顶元素与popped的第一个元素一致，则删除 //不用判断lengthPopped是否为0，因为如果为0肯定stack也没有元素 for (length > 0) && (stack[length - 1] == popped[0]) { stack, length, popped, lengthPopped = stack[:length-1], length - 1, popped[1:], lengthPopped - 1 } } if length != 0 { return false } return true } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/从上到下打印二叉树/code.html":{"url":"剑指offer/从上到下打印二叉树/code.html","title":"从上到下打印二叉树","keywords":"","body":"从上到下打印二叉树使用container/list使用slice从上到下打印二叉树 思路：直接使用BFS 即可 使用container/list // 执行用时：0 ms, 在所有 Go 提交中击败了100.00% 的用户 // 内存消耗：2.7 MB, 在所有 Go 提交中击败了 100.00% 的用户 func levelOrder(root *TreeNode) []int { //如果根节点为空 if root == nil { return []int{} } queue := list.New() queue.PushBack(root) ret := []int{} for queue.Front() != nil { node := queue.Remove(queue.Front()) ret = append(ret, node.(*TreeNode).Val) if node.(*TreeNode).Left != nil { queue.PushBack(node.(*TreeNode).Left) } if node.(*TreeNode).Right != nil { queue.PushBack(node.(*TreeNode).Right) } } return ret } 使用slice // 执行用时：0 ms, 在所有 Go 提交中击败了100.00% 的用户 // 内存消耗：2.7 MB, 在所有 Go 提交中击败了 100.00% 的用户 func levelOrder(root *TreeNode) []int { //如果根节点为空 if root == nil { return nil } queue := []*TreeNode{root} ret := []int{} for len(queue) != 0 { node := queue[0] ret = append(ret, node.Val) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } queue = queue[1:] } return ret } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/从上到下打印二叉树II/code.html":{"url":"剑指offer/从上到下打印二叉树II/code.html","title":"从上到下打印二叉树II","keywords":"","body":"从上到下打印二叉树II方法一：使用双重循环方法二：使用两个变量 (剑指offer思路)从上到下打印二叉树II 方法一：使用双重循环 这里利用了一个小技巧：我们每次使用len(queue)就可以获取当前层的个数 例如：最开始只有一个根节点，当弹出根节点，加入两个子节点之后，使用len()又获取到了第2层的节点个数，以此类推 // 执行用时：0 ms, 在所有 Go 提交中击败了100.00% 的用户 // 内存消耗：2.8 MB, 在所有 Go 提交中击败了 47.4% 的用户 func levelOrder(root *TreeNode) [][]int { //如果根节点为空 if root == nil { return nil } queue := []*TreeNode{root} ret := [][]int{} for len(queue) != 0 { currentLevelRet := []int{} length := len(queue) for i := 0; i 方法二：使用两个变量 (剑指offer思路) 思路：使用两个变量toBePrinted, nextLevel 分别表示当前层剩余的待打印节点的个数以及下一层要打印的个数，当toBePrinted等于0时，说明当前层打印完成，添加当前层的结果到最终的结果中，同时将nextLevel赋值给toBePrinted之后将nextLevel赋值0，开始下一层 // 执行用时：0 ms, 在所有 Go 提交中击败了100.00% 的用户 // 内存消耗：2.8 MB, 在所有 Go 提交中击败了 37.04% 的用户 func levelOrder(root *TreeNode) [][]int { //如果根节点为空 if root == nil { return nil } queue := []*TreeNode{root} ret := [][]int{} toBePrinted, nextLevel := 1, 0 temp := []int{} for toBePrinted != 0 { temp, toBePrinted = append(temp, queue[0].Val), toBePrinted-1 if queue[0].Left != nil { queue = append(queue, queue[0].Left) nextLevel += 1 } if queue[0].Right != nil { queue = append(queue, queue[0].Right) nextLevel += 1 } queue = queue[1:] if toBePrinted == 0 { //表明当前层打完 toBePrinted = nextLevel nextLevel = 0 ret = append(ret, temp) temp = []int{} } } return ret } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/从上到下打印二叉树III/code.html":{"url":"剑指offer/从上到下打印二叉树III/code.html","title":"从上到下打印二叉树III","keywords":"","body":"从上到下打印二叉树III方法一：剑指offer思路，使用两个栈方法2：对层次遍历中的部分层进行反转从上到下打印二叉树III 方法一：剑指offer思路，使用两个栈 思路： 假设第1层为根节点，也就是奇数层 我们用奇数栈保存奇数层要打印的节点，偶数栈保存偶数层要打印的节点 如果当前打印的是奇数层的节点，则按照先加入该节点的左子节点到偶数栈，再加入该节点的右子节点到偶数栈 如果当前打印的是偶数层的节点，则按照先加入该节点的右子节点到奇数栈，再加入该节点的左子节点到奇数栈 // 执行用时：0 ms, 在所有 Go 提交中击败了100.00% 的用户 // 内存消耗：2.7 MB, 在所有 Go 提交中击败了 100.0% 的用户 func levelOrder(root *TreeNode) [][]int { if root == nil { return nil } flag := true //表明是奇数栈 ret := [][]int{} oddStack, evenStack := []*TreeNode{root}, []*TreeNode{} for len(oddStack) != 0 || len(evenStack) != 0 { currentLevelRet := []int{} if flag { for len(oddStack) != 0 { node := oddStack[len(oddStack)-1] currentLevelRet = append(currentLevelRet, node.Val) if node.Left != nil { evenStack = append(evenStack, node.Left) } if node.Right != nil { evenStack = append(evenStack, node.Right) } oddStack = oddStack[:len(oddStack)-1] } } else { for len(evenStack) != 0 { node := evenStack[len(evenStack)-1] currentLevelRet = append(currentLevelRet, node.Val) if node.Right != nil { oddStack = append(oddStack, node.Right) } if node.Left != nil { oddStack = append(oddStack, node.Left) } evenStack = evenStack[:len(evenStack)-1] } } flag = !flag ret = append(ret, currentLevelRet) } return ret } 方法2：对层次遍历中的部分层进行反转 假设根节点在第0层，我们需要在奇数层遍历完之后将反转的结果加入到最终的结果中 // 执行用时：0 ms, 在所有 Go 提交中击败了100.00% 的用户 // 内存消耗：2.8 MB, 在所有 Go 提交中击败了 57.89% 的用户 func levelOrder(root *TreeNode) [][]int { //如果根节点为空 if root == nil { return nil } queue := []*TreeNode{root} ret := [][]int{} level := 1 for len(queue) != 0 { currentLevelRet := []int{} length := len(queue) for i := 0; i 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/二叉树中和为某一值的路径/code.html":{"url":"剑指offer/二叉树中和为某一值的路径/code.html","title":"二叉树中和为某一值的路径","keywords":"","body":"二叉树中和为某一值的路径二叉树中和为某一值的路径 思路：关键点。采用先序遍历遍历树，同时记录路径，用来帮助我们返回 首先路径中加入当前节点，并将当前节点的值加入到和中 如果当前节点没有左右子树并且和与我们的目标值一致，则打印路径到返回的结果中 如果有左子树，则继续遍历左子树 如果有右子树，则继续遍历右子树， 到达这里说明左右子树符合条件的路径已经打印完成，此时我们从路径中去除当前节点并且将和减去当前节点的值 // 执行用时：4 ms, 在所有 Go 提交中击败了 92.53% 的用户 // 内存消耗：4.5 MB, 在所有 Go 提交中击败了 79.49% 的用户 func pathSum(root *TreeNode, sum int) [][]int { //因为传入的节点值可能为负数并且最后求的和也会是负数，所以不需要判断sum 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/复杂链表的复制/code.html":{"url":"剑指offer/复杂链表的复制/code.html","title":"复杂链表的复制","keywords":"","body":"剑指 Offer 35. 复杂链表的复制方法一：暴力方法二：使用一个哈希表映射方法三【推荐】：时间复杂度为O(N)空间复杂度O(1)剑指 Offer 35. 复杂链表的复制 方法一：暴力 时间复杂度为O(N^2) 空间复杂度O(1) 方法二：使用一个哈希表映射 时间复杂度为O(N) 空间复杂度O(N) 方法三【推荐】：时间复杂度为O(N)空间复杂度O(1) ​ 步骤： 1. 将每个节点复制到后面，同时random指向之前源指针的指向 2. 修正每个新添加节点的random指向。注意：最后两个节点处理要特殊 3. 将两个链表提取出来，注意：最后两个节点处理要特殊 执行用时：0 ms, 在所有 Go 提交中击败了 100.00% 的用户 内存消耗：3.4 MB, 在所有 Go 提交中击败了 40.65% 的用户 type Node struct { Val int Next *Node Random *Node } func copyRandomList(head *Node) *Node { //如果链表为空 if head == nil { return nil } //第1步：在每个节点后边建立一个节点，并连接起来 cur := head for cur != nil { cur.Next = &Node{ Val: cur.Val, Next: cur.Next, Random: cur.Random, } cur = cur.Next.Next } //第2步：将新建立的每个节点的Random指针指向正确方向 cur = head.Next for cur != nil { if cur.Random != nil { cur.Random = cur.Random.Next } //如果是最后一个节点 if cur.Next != nil { cur = cur.Next.Next } else { break } } //第3步：将奇数节点与偶数节点对应的两个链表分开 cur = head.Next odd, even := head, head.Next for odd != nil { if even.Next != nil { odd.Next, even.Next = odd.Next.Next, even.Next.Next odd, even = odd.Next, even.Next } else { //如果最后两个节点 odd.Next = odd.Next.Next break } } return cur } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/二叉搜索树与双向链表/code.html":{"url":"剑指offer/二叉搜索树与双向链表/code.html","title":"二叉搜索树与双向链表","keywords":"","body":"剑指 Offer 36. 二叉搜索树与双向链表方法：剑指 Offer 36. 二叉搜索树与双向链表 由于Leetcode没有Go的提交，所以使用了python 方法： 思路：对树进行中序遍历，正好是按照升序的。 在中序遍历过程中，我们做如下几件事情： 记录上一次访问过的节点，此时我们要让当前节点的左指针指向上一次访问节点，并且上一次访问节点的右指针指向当前节点 记录我们访问的第一个节点，是链表的头节点，到时候我们要进行返回， 当中序遍历完成之后，此时上一个节点指向的便是右子树的最右节点，也是我们想要的那个节点，但是此时我们要让head与上一个节点（当前指向右子树的最右节点）进行连接。 class Solution: def treeToDoublyList(self, root: 'Node') -> 'Node': if root is None: return None self.head, self.prev = None, None def dfs(root, head, prev): if root.left is not None: dfs(root.left, self.head, self.prev) if self.head is None: self.head = root else: # 说明此时不是第1个节点 root.left, self.prev.right = self.prev, root self.prev = root if root.right is not None: dfs(root.right, self.head, self.prev) dfs(root, self.head, self.prev) # 此时head指向头节点，prev指向最后一个节点 self.head.left, self.prev.right = self.prev, self.head return self.head 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/字符串的排列/code.html":{"url":"剑指offer/字符串的排列/code.html","title":"字符串的排列","keywords":"","body":"剑指 Offer 38. 字符串的排列方法：回溯+剪枝剑指 Offer 38. 字符串的排列 方法：回溯+剪枝 重点：参考 参考 思路：因为当前循环一定是固定当前某一个位置，只不过通过循环将后面的元素交换到这里来，如果交换前发现已经和前面我们固定过的字符(我们存在了map中)重复，我们就直接跳过， 例如：aab 我们第1个固定a之后，如果将第2个a与第1个a交换，此时其实都是在一个函数的一个循环中，无非不过i为1, index为0，准备交换之前发现，要固定的字符第2个a之前我们已经固定过了，所以就不交换了 执行用时：52 ms, 在所有 Go 提交中击败了 79.85% 的用户 内存消耗：7.6 MB, 在所有 Go 提交中击败了 45.19% 的用户 func permutation(s string) []string { if len(s) == 0 { return []string{} } ret := []string{} backtrack([]byte(s), 0, &ret) return ret } func backtrack(content []byte, index int, ret *[]string) { //回溯结束条件，如果index为content的长度，说明我们要加入结果 if len(content) == index { *ret = append(*ret, string(content)) } mymap := make(map[byte]bool) //否则我们要不断做选择 for i := index; i 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/数组中出现次数超过一半的数字/code.html":{"url":"剑指offer/数组中出现次数超过一半的数字/code.html","title":"数组中出现次数超过一半的数字","keywords":"","body":"版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/最小的k个数/code.html":{"url":"剑指offer/最小的k个数/code.html","title":"最小的k个数","keywords":"","body":"剑指 Offer 40. 最小的k个数方法一：方法二：方法三：方法四：参考剑指 Offer 40. 最小的k个数 方法三适合处理海量数据，方法四(时间复杂度：O(N)。空间复杂度：O(1))需要修改传入的数组 思路： 方法一： 思路：直接用最快的排序方法排好序后取前k个或者后k个元素即可 时间复杂度：O(n * logn) 空间复杂度：O(1) func getLeastNumbers(arr []int, k int) []int { return QuickSort(arr)[:k] } func QuickSort(nums []int) []int { quickSort(nums, 0, len(nums)-1) return nums } func quickSort(nums []int, low int, high int) { var pivotkey int //优化1：尾递归优化 for low = nums[low] { low++ } //低处找到大的直接赋值给high nums[high] = nums[low] } //最后low == high nums[low] = dummyVal return low } func swap(nums []int, i int, j int) { nums[i], nums[j] = nums[j], nums[i] } 方法二： 思路：冒泡排序每次都会将1个元素放置到最终位置上，我们可以冒泡k趟 时间复杂度：O(k * n) 空间复杂度：O(1) func getLeastNumbers(arr []int, k int) []int { //需要冒泡k次 for i := 1; i = i-1; j-- { if arr[j] > arr[j+1] { arr[j+1], arr[j] = arr[j], arr[j+1] } } } return arr[:k] } 方法三： 思路：构建一个容量为k的堆，不断遍历数据，插入后进行调整，最后依次返回组合成我们要的结果 **适合处理海量数据**** 时间复杂度：O(n*logk) 空间复杂度：O(K) type IntHeap []int //Heap Interface //type Interface interface { // sort.Interface // Push(x interface{}) // 向末尾添加元素 // Pop() interface{} // 从末尾删除元素 //} func (h *IntHeap) Push(x interface{}) { *h = append(*h, x.(int)) } func (h *IntHeap) Pop() interface{} { old := *h n := len(old) x := old[n-1] *h = old[0 : n-1] return x } // Sort Interface //type Interface interface { // // Len方法返回集合中的元素个数 // Len() int // // Less方法报告索引i的元素是否比索引j的元素小 // Less(i, j int) bool // // Swap方法交换索引i和j的两个元素 // Swap(i, j int) //} func (h IntHeap) Len() int { return len(h) } //表明是一个小顶堆 func (h IntHeap) Less(i, j int) bool { return h[i] 方法四： 思路：随机选择，通过减治的思想利用快速排序中的partition方法可以对我们要求的那个划分轴进行快速选择， 算法导论中提过，我们有成熟的时间复杂度为O(n)的算法来获取任意第k大的数，也就是基于partition的随机选择方法 时间复杂度：O(N) 空间复杂度：O(1) **会对传入的切片进行修改**** func partition(arr []int, start int, end int) int { rand.Seed(time.Now().UnixNano()) index := rand.Intn(end-start+1) + start val := arr[index] arr[index], arr[start] = arr[start], arr[index] for start = arr[start] { start++ } arr[end] = arr[start] } arr[start] = val return start } func getLeastNumbers(arr []int, k int) []int { //特殊情况 if len(arr) == 0 || k = len(arr) { return arr } index := partition(arr, 0, len(arr)-1) for index != k-1 { if index > k-1 { //说明在左边 index = partition(arr, 0, index-1) } else if index 参考 58沈剑讲解 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/数据流中的中位数/code.html":{"url":"剑指offer/数据流中的中位数/code.html","title":"数据流中的中位数","keywords":"","body":"剑指 Offer 41. 数据流中的中位数方法：最小堆+最大堆剑指 Offer 41. 数据流中的中位数 方法：最小堆+最大堆 执行用时：96 ms, 在所有 Go 提交中击败了 99.07% 的用户 内存消耗：13.9 MB, 在所有 Go 提交中击败了 88.00% 的用户 思路：我们初始化的时候将第1个元素加入最大堆，之后每次元素个数相同的时候再加入我们都要让最大堆比最小堆多1个 如果此时加入的元素比最大堆的堆顶大， 如果两个堆元素相同，加入最小堆，之后最小堆调整后弹出堆顶加入最大堆 如果最大堆比最小堆多1个，加入最小堆 如果此时加入的元素比最大堆的堆顶小， 如果两个堆元素相同，加入最大堆 如果最大堆比最小堆已经多了1个，则加入最大堆，调整之后弹出最大堆的堆顶加入到最小堆 type MinHeap []int type MaxHeap []int //*************************************小根堆 func (h MinHeap) Len() int { return len(h) } //小根堆，前面比后面小 func (h MinHeap) Less(i, j int) bool { return h[i] h[j] } func (h MaxHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *MaxHeap) Push(x interface{}) { *h = append(*h, x.(int)) } func (h *MaxHeap) Pop() interface{} { val := (*h)[len(*h)-1] *h = (*h)[:len(*h)-1] return val } type MedianFinder struct { minHeap *MinHeap maxHeap *MaxHeap } /** initialize your data structure here. */ func Constructor() MedianFinder { minHeap := &MinHeap{} maxHeap := &MaxHeap{} heap.Init(&MinHeap{}) heap.Init(&MaxHeap{}) return MedianFinder{ minHeap: minHeap, maxHeap: maxHeap, } } func (this *MedianFinder) AddNum(num int) { //将元素加入最小堆， //如果两个堆都没有元素就直接加入 if this.minHeap.Len() == 0 && this.maxHeap.Len() == 0 { heap.Push(this.maxHeap, num) return } // if num >= (*this.maxHeap)[0] { if this.minHeap.Len() == this.maxHeap.Len() { heap.Push(this.minHeap, num) heap.Push(this.maxHeap, heap.Pop(this.minHeap)) } else { heap.Push(this.minHeap, num) } } else if num 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/连续子数组的最大和/code.html":{"url":"剑指offer/连续子数组的最大和/code.html","title":"连续子数组的最大和","keywords":"","body":"连续子数组的最大和方法一：找规律方法二：dp连续子数组的最大和 方法一：找规律 思路：剑指offer 如果前面一个数的连续子数组最大和大于0，则将其加上当前数，并与已经保存的最大连续子数组的和比较，如果大就替换* 如果前面一个数的连续子数组最大和小于0，则将连续子数组的最大和赋值为当前数，并与已经保存的最大连续子数组的和比较，如果大就替换* func maxSubArray(nums []int) int { if nums == nil || len(nums) 0 { curSum += nums[i] } else { curSum = nums[i] } if curSum > greatesSubArraySum { greatesSubArraySum = curSum } } return greatesSubArraySum } 方法二：dp 用函数f(i)表示以第i个数字结尾的子数组的最大和，那么我们最后的结果便是max(f[i]), 其中 0 f[i] = pData[i] 当 i == 0 || f[i-1] f[i] = f[i-1] + pData[i] 当i > 0 && f[i-1] > 0 这个公式的意义便是： 当以第i-1个数字结尾的子数组的最大和为小于0时，如果将第i个数字与第i-1个数字结尾的子数组的最大和相加将会小于第i个数字，所以这种情况下，第i个数字结尾的连续子数组最大和便是自己 如果第i-1个数字结尾的子数组的最大和大于0，那么第i个数字累加就得到以第i个数字结尾的子数组中所有数字的和 func max(nums []int) int { max := nums[0] for i := 0; i 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/数字序列中某一位的数字/code.html":{"url":"剑指offer/数字序列中某一位的数字/code.html","title":"数字序列中某一位的数字","keywords":"","body":"剑指 Offer 44. 数字序列中某一位的数字方法：剑指 Offer 44. 数字序列中某一位的数字 方法： 思路： 首先要找的位数在几位数之间，找到在几位数之后，从该数字开始，然后我们可以直接找到我们要的那个数，但是在第几位还是要根据取模来进行判断 例子：假设我们要找的是第194位数字， 过程： 位数为1时，只有10个位，所以我们要让位数+1，从后面找184位 位数为2时，只有180个位，所以我们要让位数+1，从后面找4个位 位数为3时，可以找到，找的数从3位数的起始100开始，我们要从后面找4位，直接定位到我们要的那个数字100 + 4 / 3 然后从101开始找我们要的那个位，该位在 101中的第 4 % 3 个位置上，也就是第1个位置(我们位置是从0开始的)，所以0就是我们要找的 执行用时：0 ms, 在所有 Go 提交中击败了 100.00% 的用户 内存消耗：1.9 MB, 在所有 Go 提交中击败了 53.33% 的用户 func countDigit(digit int) int { if digit == 1 { return 10 } start := 1 for i := 0; i 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/把数组排成最小的数/code.html":{"url":"剑指offer/把数组排成最小的数/code.html","title":"把数组排成最小的数","keywords":"","body":"剑指 Offer 45. 把数组排成最小的数方法：剑指 Offer 45. 把数组排成最小的数 方法： 注意：Golang中整数转换为字符串不可以使用string(整数)，必须使用strconv.Itoa(一个int的数)来将int转换为字符串 思路：将数组中的所有元素转换为字符串，按照我们自定义的排序规则进行排序， 步骤： 对传入的整数数组中的所有元素转换为字符串 对该字符串数组使用排序规则进行排序，这里我们实现排序接口中的三个方法 对排序后的结果拼接得到我们最终的结果并返回 返回的结果：排序之后对所有字符串中的元素进行拼接便是我们想要的结果 具体接口的实现参考 执行用时：4 ms, 在所有 Go 提交中击败了 83.83% 的用户 内存消耗：2.5 MB, 在所有 Go 提交中击败了 68.10% 的用户 type myData []string func (d myData) Len() int { return len(d) } func (d myData) Swap(i, j int) { d[i], d[j] = d[j], d[i] } func (d myData) Less(i, j int) bool { num1, _ := strconv.Atoi(d[i]+d[j]) num2, _ := strconv.Atoi(d[j]+d[i]) return num1 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/把数字翻译成字符串/code.html":{"url":"剑指offer/把数字翻译成字符串/code.html","title":"把数字翻译成字符串","keywords":"","body":"剑指 Offer 46. 把数字翻译成字符串方法：dp剑指 Offer 46. 把数字翻译成字符串 方法：dp 因为涉及到了重复计算，所以我们采用dp来进行计算 假设字符串为numString 步骤： base case ：dp[0] = 1, dp[1] = 1 或 2(条件是倒数2个字符为10-25之间) 状态：dp[i] 表示前i+1位翻译成字符串的结果数 转移方程： 1. `dp[i] = dp[i-1]` 如果`numString[i-1:i+1]`不在10-25之间 2. `dp[i-1] + dp[i-2]` 如果`numString[i-1:i+1]`在10-25之间 我们要的结果：dp数组的最后一个 优化【状态压缩】：发现使用3个滚动变量就可以进行状态优化来完成我们整个功能 执行用时：0 ms, 在所有 Go 提交中击败了 100.00% 的用户 内存消耗：1.9 MB, 在所有 Go 提交中击败了 57.14% 的用户 func translateNum(num int) int { if num = 0 && num = \"10\" && numString = \"10\" && numString[i-1:i+1] 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/礼物的最大价值/code.html":{"url":"剑指offer/礼物的最大价值/code.html","title":"礼物的最大价值","keywords":"","body":"礼物的最大价值礼物的最大价值 思路：问题是求最大价值(最值)，同时是遍历一个二维数组，涉及到了大量的重复计算，因而我们可以考虑dp， 最入门的dp可以使用二维数组来存储结果 这里我们进行状态压缩，使用一维数组来存储结果 dp[i][j]表示第i, j位置的礼物最大价值 dp公式如下： dp[i][j] = grid[i][j]) 位于第一行第一列，只能赋值 dp[i][j] = dp[i][j-1] + grid[i][j] 位于第一行非第一列，只能从左边过来 dp[i][j] = dp[i-1][j] + grid[i][j] 位于其他行的第一列，只能从上边下来 dp[i][j] = max(dp[i-1][j] + grid[i][j], dp[i][j-1] + grid[i][j]) 当不在第一行第一列时 // 执行用时：8 ms, 在所有 Go 提交中击败了 89.81% 的用户 // 内存消耗：3.9 MB, 在所有 Go 提交中击败了 100.00% 的用户 func maxValue(grid [][]int) int { //如果行和列两个维度只要有一个为0就返回0 if len(grid) == 0 || len(grid[0]) == 0 { return 0 } valueArray := make([]int, len(grid[0])) //遍历多少次 for i := 0; i b { return a } return b } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/丑数/code.html":{"url":"剑指offer/丑数/code.html","title":"丑数","keywords":"","body":"剑指 Offer 49. 丑数方法一【自己的代码】：动态规划方法二：参考LeetCode他人解法剑指 Offer 49. 丑数 方法一【自己的代码】：动态规划 步骤： base case : dp[0] = 1 因为第1个丑数是0 状态定义：dp[i]表示第i+1个丑数 状态转移方程：dp[i] = min(dp[a]*2, dp[b]*3, dp[c]*5)要求dp[a]*2, dp[b]*3, dp[c]*5 都要大于dp[i] 结果：返回dp数组的最后一个元素即可 func nthUglyNumber(n int) int { //意味着输入不合法 if n dp[b] * 3 { min, minVal = b, 3 } if dp[min] * minVal > dp[c] * 5 { min, minVal = c, 5 } dp = append(dp, dp[min] * minVal) //谁指向的数乘以质因子最小谁就+1 if dp[i] == dp[a]*2 { a++ } if dp[i] == dp[b]*3 { b++ } if dp[i] == dp[c]*5 { c++ } } return dp[n-1] } 方法二：参考LeetCode他人解法 执行用时：4 ms, 在所有 Go 提交中击败了 63.93% 的用户 内存消耗：6.3 MB, 在所有 Go 提交中击败了 5.19% 的用户 注意：因为b会指向4，而a会指向6，所以到时候dp[a]2 == dp[b]3 所以，此时将值加入之后，我们要让a,b都要右移 func nthUglyNumber(n int) int { //意味着输入不合法 if n 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/第一个只出现一次的字符/code.html":{"url":"剑指offer/第一个只出现一次的字符/code.html","title":"第一个只出现一次的字符","keywords":"","body":"第一个只出现一次的字符第一个只出现一次的字符 思路：通过自定义的一个map来统计字符出现次数，两次遍历我们自定义map来获得最终结果。有一定的片面性，因为一个字符占8个字节，因此总共有256种可能，所以我们采用了一个长度为256的数组来自定义map。将字符对应的ASCII码值作为map的键 // 执行用时：8 ms, 在所有 Go 提交中击败了 82.52% 的用户 // 内存消耗：5.9 MB, 在所有 Go 提交中击败了 7.32% 的用户 func firstUniqChar(s string) byte { if len(s) 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/数组中的逆序对/code.html":{"url":"剑指offer/数组中的逆序对/code.html","title":"数组中的逆序对","keywords":"","body":"剑指 Offer 51. 数组中的逆序对方法：merge的时候进行统计剑指 Offer 51. 数组中的逆序对 方法：merge的时候进行统计 思路：参考自己的博客文章 执行用时：172 ms, 在所有 Go 提交中击败了 16.19% 的用户 内存消耗：8.5 MB, 在所有 Go 提交中击败了 31.28% 的用户 func reversePairs(nums []int) int { return MergeSort(nums) } func MergeSort(nums []int) int { if nums == nil || len(nums) >1加速运算 mid := l + (r-l)>>1 //分治 return mergeSort(nums, l, mid) + mergeSort(nums, mid+1, r) + merge(nums, l, mid, r) //合并两部分[l,mid] [mid+1,r] } func merge(nums []int, l, mid, r int) int { i, j := l, mid+1 //申请一个辅助数组 help := make([]int, r-l+1) index := 0 ret := 0 //谁小填谁移谁 for i nums[j] { //产生逆序对 help[index] = nums[j] ret += (mid - i + 1) j++ } else { help[index] = nums[i] i++ } index++ } //移动剩下的一部分 //注意下面两个是for循环，不是if //另外注意的是下面两个for循环有且只有一个可以被执行 for i r for i := l; i 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/两个链表的第一个公共节点/code.html":{"url":"剑指offer/两个链表的第一个公共节点/code.html","title":"两个链表的第一个公共节点","keywords":"","body":"两个链表的第一个公共节点方法一：第一个链表遍历完，指针指向第二个链表方法二：两个链表的第一个公共节点 方法一：第一个链表遍历完，指针指向第二个链表 思路：当我们第一个链表遍历完之后，指针指向第2个链表头。这样可以避免遍历链表获取链表长度 // 执行用时：44 ms, 在所有 Go 提交中击败了91.37% 的用户 // 内存消耗：7.9 MB, 在所有 Go 提交中击败了 100.00% 的用户 func getIntersectionNode(headA, headB *ListNode) *ListNode { //如果两个链表有一个为空，返回nil if headA == nil || headB == nil { return nil } //判断两个链表是否相交 //找到两个链表的交点 flag := 1 tempHeadA, tempHeadB := headA, headB for tempHeadA != tempHeadB { //当其中一个到达了末尾 if tempHeadB.Next == nil { tempHeadB = headA flag += 1 } if tempHeadA.Next == nil { tempHeadA = headB flag += 1 } //说明两个链表的头都已遍历完自己的链表和另外一个链表，并且其中一个又遍历完另一个链表 if flag > 3 { return nil } tempHeadA, tempHeadB = tempHeadA.Next, tempHeadB.Next } return tempHeadA; } 方法二： 思路：遍历两个链表分别获取其长度，然后其中长的链表先走长度差的步数 // 执行用时：44 ms, 在所有 Go 提交中击败了91.37% 的用户 // 内存消耗：7.9 MB, 在所有 Go 提交中击败了 100.00% 的用户 func getIntersectionNode(headA, headB *ListNode) *ListNode { //如果两个链表有一个为空，返回nil if headA == nil || headB == nil { return nil } //获取两个链表的长度 lenA, lenB := 1, 1 tempHeadA, tempHeadB := headA, headB for tempHeadA.Next != nil { tempHeadA, lenA = tempHeadA.Next, lenA + 1 } for tempHeadB.Next != nil { tempHeadB, lenB = tempHeadB.Next, lenB + 1 } //重置 tempHeadA, tempHeadB = headA, headB //第一个链表长 if lenA > lenB { for i := 0; i 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/二叉搜索树的第k大节点/code.html":{"url":"剑指offer/二叉搜索树的第k大节点/code.html","title":"二叉搜索树的第k大节点","keywords":"","body":"二叉搜索树的第k大节点二叉搜索树的第k大节点 思路：中序遍历后返回倒数第k个节点 // 执行用时：16 ms, 在所有 Go 提交中击败了 30.26% 的用户 // 内存消耗：6.3 MB, 在所有 Go 提交中击败了 25.00% 的用户 package main import \"fmt\" //思路：返回中序遍历生成的序列中的第k个节点 func InorderTraverse(root *TreeNode, ret *[]int) { if root == nil { return } InorderTraverse(root.Left, ret) *ret = append(*ret, root.Val) InorderTraverse(root.Right, ret) } func kthLargest(root *TreeNode, k int) int { ret := &[]int{} InorderTraverse(root, ret) //说明没找到第k大节点 if k len(*ret) { return -1 } return (*ret)[len(*ret) - k] } func main() { } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/平衡二叉树/code.html":{"url":"剑指offer/平衡二叉树/code.html","title":"平衡二叉树","keywords":"","body":"平衡二叉树方法一：递归方法二：递归平衡二叉树 方法一：递归 获取当前节点左右子树的高度差是否小于等于1且大于等于1 再判断当前节点的左右子树是否平衡 该方法在获取高度差之后又要判断左右子树是否平衡，同时遍历了两次左右子树，因此效率不高。 // 执行用时：8 ms, 在所有 Go 提交中击败了 88.31% 的用户 // 内存消耗：5.7 MB, 在所有 Go 提交中击败了 100.00% 的用户 func isBalanced(root *TreeNode) bool { //需要注意的是空树也是平衡二叉树 if root == nil { return true } //获取左子树的深度，以及右子树的深度，然后判断差值的绝对值是否在-1 - 1之间 leftSubTreeDepth, rightSubTreeDepth := maxDepth(root.Left), maxDepth(root.Right) val := leftSubTreeDepth - rightSubTreeDepth if val >= -1 && val rightSubTreeDepth { return leftSubTreeDepth + 1 } return rightSubTreeDepth + 1 } 方法二：递归 相对于方法一，我们采用了后序遍历，当遍历到当前节点时，我们先判断左右子树是否平衡，在判断子树平衡的时候我们已经获取了左右子树的高度，此时根据差值判断是否平衡。 // 执行用时：4 ms, 在所有 Go 提交中击败了 98.69% 的用户 // 内存消耗：5.7 MB, 在所有 Go 提交中击败了 44.44% 的用户 func isBalancedCore(root *TreeNode, height *int) bool { //需要注意的是空树也是平衡二叉树 if root == nil { return true } leftSubTreeDepth, rightSubTreeDepth := 0, 0 //如果左子树平衡并且右子树平衡。如果都平衡，我们同时获取了左子树和右子树的深度 if (isBalancedCore(root.Left, &leftSubTreeDepth) && isBalancedCore(root.Right, &rightSubTreeDepth)) { diff := leftSubTreeDepth - rightSubTreeDepth if diff >= -1 && diff 0 { *height = leftSubTreeDepth + 1 } else { *height = rightSubTreeDepth + 1 } return true } } return false } func isBalanced(root *TreeNode) bool { //需要注意的是空树也是平衡二叉树 if root == nil { return true } height := 0 return isBalancedCore(root, &height) } 总结： 相比于方法一，方法二采用了后序遍历的方式，只需要遍历一次左右子树，不需要重复遍历。因此效率会比方法一高。方法一采用了自上向下的方式，包含了大量重复计算。 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/数组中数字出现的次数/code.html":{"url":"剑指offer/数组中数字出现的次数/code.html","title":"数组中数字出现的次数","keywords":"","body":"数组中数字出现的次数最初版本：改进版本进阶进阶-2数组中数字出现的次数 思路：分组异或 最初版本： 思路：使用原数组，将其分成两部分，前面一部分[0, firstEndPoint]上所有的数字 在 xorRet中最右边为1的二进制位都为1。后面一部分都为的数字 在 xorRet中最右边为1的二进制位都为0 求出数组中所有数字的异或结果xorRet, 一定不为0，因为有两个只出现1次的数字。 根据xorRet中的某一个为1的二进制位(这里我们使用最右边为1的二进制位)将该数组中所有数字分成两组，一组在该二进制位上为1，另一组为0 之后第一组中所有数字进行异或得到的结果便是其中一个只出现一次的数字，另一个以此类推 //执行用时：24 ms, 在所有 Go 提交中击败了62.56% 的用户 //内存消耗：6 MB, 在所有 Go 提交中击败了 100.00% 的用户 func singleNumbers(nums []int) []int { //得到两个只出现1次数字的异或结果 xorRet := 0 for _, val := range nums { xorRet ^= val } //从右到左找到异或结果不为1的那个二进制位 //通过这一个二进制位划分成两个数组， bitMask := 1 for i := 0; i 该方法缺点： 遍历了3次数组 同时对元素组进行了修改，需要提前问面试官是否可以修改原数组 改进版本 //执行用时：20 ms, 在所有 Go 提交中击败了89.35% 的用户 //内存消耗：6 MB, 在所有 Go 提交中击败了 100.00% 的用户 //上面方法的改进，只用遍历两次数组即可 func singleNumbers(nums []int) []int { //得到两个只出现1次数字的异或结果 xorRet := 0 for _, val := range nums { xorRet ^= val } //从右到左找到异或结果不为1的那个二进制位 //通过这一个二进制位划分成两个数组， bitMask := 1 for i := 0; i 改进： 只用遍历两次数组 进阶 //执行用时：20 ms, 在所有 Go 提交中击败了89.35% 的用户 //内存消耗：6 MB, 在所有 Go 提交中击败了 100.00% 的用户 func singleNumbers(nums []int) []int { //得到两个只出现1次数字的异或结果 xorRet := 0 for _, val := range nums { xorRet ^= val } //得到最右边的为1的二进制 xorRet = xorRet & (-xorRet) //相当于a = a &（~a+1 fmt.Println(xorRet) //上面得到的二进制位和数组中的所有数字与，得到两个结果1或0，可以划分成两个数组 ret1, ret2 := 0, 0 for i := 0; i 改进： 通过 x = x & -x* 找到最右边的二进制位1 返回切片的时候 不用直接make， 可以直接使用 return []int{ret1, ret2} 相当于返回一个长度为2的切片 *return* []int{ret1, ret2} 进阶-2 //执行用时：20 ms, 在所有 Go 提交中击败了89.35% 的用户 //内存消耗：6 MB, 在所有 Go 提交中击败了 100.00% 的用户 func singleNumbers(nums []int) []int { //得到两个只出现1次数字的异或结果 xorRet := 0 for _, val := range nums { xorRet ^= val } //得到最右边的为1的二进制 xorRet = xorRet & (-xorRet) //相当于a = a &（~a+1 //上面得到的二进制位和数组中的所有数字与，得到两个结果1或0，可以划分成两个数组 ret := make([]int, 2) for i := 0; i 改进：直接使用切片存储而不需要两个结果变量 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/数组中数字出现的次数II/code.html":{"url":"剑指offer/数组中数字出现的次数II/code.html","title":"数组中数字出现的次数II","keywords":"","body":"数组中数字出现的次数II方法一方法二：有限状态自动机+位运算数组中数字出现的次数II 思路：所有数字出现了3次，那么我们可以将二进制位每一位的结果进行无进位相加，如果哪一位可以被3整除，则说明只出现一次的数字在该位上为0，否则为1 方法一 //自己的解法，也是和剑指offer一样的解法 func singleNumber(nums []int) int { if len(nums) 方法二：有限状态自动机+位运算 参考 func singleNumber2(nums []int) int { one, two := 0, 0 for _, e := range nums { one = ^two & (one^e) two = ^one & (two^e) } return one } 总结：两个方法时间复杂度都为o(1)，但整体上推荐方法二，详细解答点击上面的参考 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/翻转单词顺序/code.html":{"url":"剑指offer/翻转单词顺序/code.html","title":"翻转单词顺序","keywords":"","body":"剑指 Offer 58 - I. 翻转单词顺序剑指 Offer 58 - I. 翻转单词顺序 此题思路：将句子进行反转，然后反转句子中的每个单词 两个注意的点： 句子的前后可能有多个空格 单词与单词之间不止有一个空白字符，可能有多个空白字符，需要将多个转换为1个 步骤如下： 去掉两边的空格字符，并进行截取 对截取的字符去掉单词之间的空格 反转整个句子 将句子中的单词内部进行反转 返回结果 执行用时：0 ms, 在所有 Go 提交中击败了 100.00% 的用户 内存消耗：3.3 MB, 在所有 Go 提交中击败了 99.14% 的用户 代码：参考 func reverseWords(s string) string { //提取出句子中的每个单词，会将首尾以及字符串之间所有的空格都去掉 wordList := strings.Fields(s) l, r := 0, len(wordList)-1 for l 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/左旋转字符串/code.html":{"url":"剑指offer/左旋转字符串/code.html","title":"左旋转字符串","keywords":"","body":"左旋转字符串方法一：剑指offer方法二：使用切片左旋转字符串 方法一：剑指offer 思路：剑指offer思路，先旋转前n个字符串，之后旋转剩下的，最后旋转整个字符串 // 执行用时：4 ms, 在所有 Go 提交中击败了 12.19% 的用户 // 内存消耗：4.9 MB, 在所有 Go 提交中击败了 14.03% 的用户 func reverseLeftWords(s string, n int) string { if len(s) 方法二：使用切片 // 执行用时：0 ms, 在所有 Go 提交中击败了 100.00% 的用户 // 内存消耗：3.3 MB, 在所有 Go 提交中击败了 78.95% 的用户 func reverseLeftWords(s string, n int) string { return s[n:] + s[:n] } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/滑动窗口的最大值/code.html":{"url":"剑指offer/滑动窗口的最大值/code.html","title":"滑动窗口的最大值","keywords":"","body":"滑动窗口的最大值自己纸上手写的代码：(提交不通过)对上面版本的代码的错误改正：再改正：滑动窗口的最大值 思路：使用一个切片模拟窗口以及一个切片保存滑动窗口每次的最大值 初始时将前滑动窗口大小的元素中的元素按照如下规则加入最大值切片 若最大值切片没有元素，直接加入 若大于最大值切片的最后一个，则弹出最后一个元素，不断循环，直到最大值切片最后一个元素小于等于要加入的元素值 之后在加入当前遍历到的元素时，需要确保如下几种情况 滑动窗口最左边的元素没有越界 加入的元素如果比之前的大，就弹出，直到最大值切片最后一个元素小于等于要加入的元素值 此时就可以直接加入 自己纸上手写的代码：(提交不通过) //语法有问题：第2个for循环的里面那个for循环，可能为0，因此就会把索引设为-1，报错 //同时逻辑有点小问题，我们自己初始化了滑动窗口大小的元素，初始化完成之后，没有将初始化后的最大值加入到我们的结果中 func maxSlidingWindow(nums []int, k int) []int { //如果传入的数组大小小于窗口大小，我们需要问面试官如何处理 if len(nums) = k { //说明左边的元素超过了边界要弹出 window = window[1:] curLength -= 1 } for curLength 对上面版本的代码的错误改正： //提交之后报错：因为传入的数组以及滑动窗口大小可能为0 // 加了ret = append(ret, nums[window[0]])，改了for curLength != 0 && curLength func maxSlidingWindow(nums []int, k int) []int { //如果传入的数组大小小于窗口大小，我们需要问面试官如何处理 // if len(nums) = k { //说明左边的元素超过了边界要弹出 window = window[1:] curLength -= 1 } for curLength != 0 && curLength 再改正： // 执行用时：20 ms, 在所有 Go 提交中击败了 79.30% 的用户 // 内存消耗：6.3 MB, 在所有 Go 提交中击败了 41.67% 的用户 func maxSlidingWindow(nums []int, k int) []int { if len(nums) = k { //说明左边的元素超过了边界要弹出 window = window[1:] curLength -= 1 } for curLength != 0 && curLength 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/队列的最大值/code.html":{"url":"剑指offer/队列的最大值/code.html","title":"队列的最大值","keywords":"","body":"队列的最大值队列的最大值 // 执行用时：96 ms, 在所有 Go 提交中击败了 96.81% 的用户 // 内存消耗：7.8 MB, 在所有 Go 提交中击败了 53.33% 的用户 思路：使用两个切片，一个保存数据，另一个保存最大值 当加入数据到队列时，如果比最大值切片中的最后一个元素大，则弹出最后一个，不断循环，直到最大值切片中最后一个元素大于等于要加入的数据值(类似于滑动窗口的最大值)。此时再加入数据值到数据切片与最大值切片。反之直接加入 当弹出数据元素的时候，如果该元素等于最大值切片的第一个元素，最大值切片也要弹出，反之只弹出数据切片中的元素 type MaxQueue struct { maximum []int data []int } func Constructor() MaxQueue { return MaxQueue{[]int{}, []int{}} } func (this *MaxQueue) Max_value() int { if len(this.maximum) this.maximum[length - 1] { //弹出小的,因为要加入的值比前面的值大 this.maximum = this.maximum[:length - 1] length -= 1 } this.data = append(this.data, value) this.maximum = append(this.maximum, value) } func (this *MaxQueue) Pop_front() int { if len(this.data) 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/扑克牌中的顺子/code.html":{"url":"剑指offer/扑克牌中的顺子/code.html","title":"扑克牌中的顺子","keywords":"","body":"剑指 Offer 61. 扑克牌中的顺子方法一：快排方法二：使用set + 最大值最小值规律法剑指 Offer 61. 扑克牌中的顺子 因为数组长度很小，所以使用方法一二的效率都差不多。 方法一：快排 时间复杂度：O(NlogN) 空间复杂度：O(1) 思路： 首先对传入的数组进行排序 排序之后因为是从小到大升序，首先统计0的元素的个数 统计非0元素个数之间的空隙 如果空隙的个数大于0说明无法填充直接返回false，否则返回true 执行用时：0 ms, 在所有 Go 提交中击败了 100.00% 的用户 内存消耗 2.2 MB, 在所有 Go 提交中击败了 17.76% 的用户 func isStraight(nums []int) bool { //1. 对传入的数据进行排序 sort.Ints(nums) //2. 数一下0的个数 numsOfZero := 0 for i := 0; i 方法二：使用set + 最大值最小值规律法 时间复杂度：O(N) 空间复杂度：O(N) 参考 遍历数组的时候，我们动态维护一个最大值和最小值，同时我们不断更新map，如果有重复值直接返回false，并且统计0的个数 遍历之后，我们得到了最大值max，最小值min，以及一个没有重复值的map，同时我们还获得了0的个数count 此时max - min为最大值和最小值的差值，非0的元素个数为5-count，如果为顺子正常的差值为4-count。 因此我们需要进行判断，如果max - min - (4 - count)得到的便是gap数量，如果这个值小于等于count那么就可以填充成顺子 func isStraight(nums []int) bool { mymap := make(map[int]bool) //遍历传入的数组 //1. 如果为0直接跳过，并且count+=1 //统计0出现的次数 count := 0 //记录5张牌中的最大值和最小值 max, min := -1, 20 for i := 0; i max { max = nums[i] } if nums[i] 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/股票的最大利润/code.html":{"url":"剑指offer/股票的最大利润/code.html","title":"股票的最大利润","keywords":"","body":"股票的最大利润方法一：方法二：股票的最大利润 方法一： 思路：假设在当天买入，在后面找到最大值，差值与之前计算过的最大利润比较，如果大就更新。含有大量的重复计算 //执行用时：292 ms, 在所有 Go 提交中击败了5.2% 的用户 //内存消耗：3.1 MB, 在所有 Go 提交中击败了 100.00% 的用户 func maxProfit(prices []int) int { //这里没必要判断，因为for循环第1个会判断 //如果传入进来的价格数组长度为0,zh length := len(prices) // if length 方法二： 思路：假设当天卖出股票，那么在遍历到当天之前，我们需要使用minValue记录最小的值，同时记录maxProfit //执行用时：4 ms, 在所有 Go 提交中击败了97.06% 的用户 //内存消耗：3.1 MB, 在所有 Go 提交中击败了 100.00% 的用户 func maxProfit(prices []int) int { //如果传入进来的价格数组长度为0 length := len(prices) //if length maxProfit { maxProfit = prices[i] - minValue } //之后比较最小值 if minValue > prices[i] { minValue = prices[i] } } return maxProfit } 总结：两种方法如上所示，法一时间复杂度为o(n^2)，法二时间复杂度为o(n) 这道题目其实就是找到在数组中找到两个值，要求满足如下条件： 两个值有先后顺序 后面值减去前面值尽可能大，如果都为负直接返回0 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/求1+2+...+n/code.html":{"url":"剑指offer/求1+2+...+n/code.html","title":"求1+2+...+n","keywords":"","body":"版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/不用加减乘除做加法/code.html":{"url":"剑指offer/不用加减乘除做加法/code.html","title":"不用加减乘除做加法","keywords":"","body":"不用加减乘除做加法不用加减乘除做加法 思路：两个数相加，可以拆分成如下几步 计算进位的结果 计算不进位时的结果 将两个相加得到我们的结果 func add(a int, b int) int { //如果有一个为0 if a == 0 || b == 0 { return a ^ b } //如果两个都不为0 andRet, xorRet := a & b, a ^ b for andRet != 0 { andRet 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/二叉搜索树的最近公共祖先/code.html":{"url":"剑指offer/二叉搜索树的最近公共祖先/code.html","title":"二叉搜索树的最近公共祖先","keywords":"","body":"剑指 Offer 68 - I. 二叉搜索树的最近公共祖先剑指 Offer 68 - I. 二叉搜索树的最近公共祖先 # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = Nonehttps://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/ class Solution: def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode': # 如果当前根节点为空，直接返回true if root is None: return None # 如果当前节点不为空 # 1.1 如果p和q都小于root，递归到左子树 if root.val > p.val and root.val > q.val: return self.lowestCommonAncestor(root.left, p, q) # 1.2 如果p和q都大于root，递归到右子树 elif root.val 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"剑指offer/二叉树的最近公共祖先/code.html":{"url":"剑指offer/二叉树的最近公共祖先/code.html","title":"二叉树的最近公共祖先","keywords":"","body":"剑指 Offer 68 - II. 二叉树的最近公共祖先方法：dfsGo解法python解法剑指 Offer 68 - II. 二叉树的最近公共祖先 方法：dfs 思路：题目中说明了树中节点值唯一，并且两个节点都存在于树中 如果当前节点的左右子树都不空，直接返回当前节点 如果左子树为空，直接返回右节点 如果右子树为空，直接返回左节点 关键点： 如果当前的节点为左节点或右节点，我们直接返回当前节点。 ​ 2. 如果当前节点为空，直接返回当前节点 小问题：自己之前很不理解的就是如果两个节点都在当前节点的左子树最下方，那么这个函数不是返回当前节点么？ 解释：首先如果两个节点都在当前节点的孙子节点，那么返回的是当前节点的儿子节点而不是孙子节点，因为我们使用dfs一层一层遍历，当遍历到孙子那层返回两个节点，但是之后递归回到了当前节点的孩子那一层，此时发现左右两个子树节点满足条件，所以返回当前节点的孩子节点，也就是最终答案楼 执行用时：16 ms, 在所有 Go 提交中击败了 63.91% 的用户 内存消耗：7.6 MB, 在所有 Go 提交中击败了 17.10% 的用户 Go解法 func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil || root == p || root == q { return root } //递归遍历到左子树 left := lowestCommonAncestor(root.Left, p, q) //递归遍历到右子树 right := lowestCommonAncestor(root.Right, p, q) //如果左边的不空 if left != nil { if right != nil { //说明左节点在左边，右节点在右边 return root } //说明左子树那边不空(且此时left为其中的一个节点)，右子树那边没有p和q return left } //走到这里说明left没找到，直接返回right即可 //原因：题目说明了两个节点都出现了并且树中所有节点的值都不相同 return right } python解法 class Solution: def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode: if root is None or root == p or root == q: return root left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) if left is not None: if right is not None: return root return left return right 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/":{"url":"LeetCode/","title":"LeetCode","keywords":"","body":"LeetCode题解动态规划回溯：字符串去掉尾部的空格LeetCode题解 This is the summary of my book. 题号 题目名称 解决时间 疑问 笔记 面试题16.01 2020-08-12 交换数字 98验证二叉搜索树 2020-08-14 98验证二叉搜索树 238除自身以外数组的乘积 2020-08-15 238除自身以外数组的乘积 225用队列实现栈 2020-08-16 225用队列实现栈 237删除链表中的节点 2020-08-16 237删除链表中的节点 226翻转二叉树 2020-08-18 226翻转二叉树 1290二进制链表转整数 2020-08-18 1290二进制链表转整数 876 链表的中间结点 2020-08-18 876 链表的中间结点 83 删除排序链表中的重复元素 2020-08-18 83删除排序链表中的重复元素 141 环形链表 2020-08-18 141 环形链表 342. 4的幂 2020-08-18 342.4的幂 461. 汉明距离 2020-08-18 461.汉明距离 1342. 将数字变成 0 的操作次数 2020-08-19 1342.将数字变成 0 的操作次数 106. 从中序与后序遍历序列构造二叉树 2020-08-19 106. 从中序与后序遍历序列构造二叉树 101. 对称二叉树 2020-08-19 101. 对称二叉树 105. 从前序与中序遍历序列构造二叉树 2020-08-19 105. 从前序与中序遍历序列构造二叉树 142. 环形链表 II 2020-08-20 142. 环形链表 II 1137. 第 N 个泰波那契数 2020-08-20 1137.第N个泰波那契数 70.爬楼梯 2020-08-20 70.爬楼梯 344. 反转字符串 2020-08-20 344.反转字符串 371. 两整数之和 2020-08-20 371.两整数之和 412. Fizz Buzz 2020-08-21 412.FizzBuzz 155. 最小栈 2020-08-21 155.最小栈 88. 合并两个有序数组 2020-08-21 88.合并两个有序数组 35. 搜索插入位置 2020-08-21 35. 搜索插入位置 64. 最小路径和 2020-08-22 64. 最小路径和 53. 最大子序和 2020-08-22 53.最大子序和 121.买卖股票的最佳时机 2020-08-22 121.买卖股票的最佳时机 50. Pow(x, n) 2020-08-22 50.Pow(x, n) 367. 有效的完全平方数 2020-08-22 367. 有效的完全平方数 116 填充每个节点的下一个右侧节点指针 2020-08-22 116.填充每个节点的下一个右侧节点指针 198 打家劫舍 2020-08-25 198.打家劫舍 746 使用最小花费爬楼梯 2020-08-25 746.使用最小花费爬楼梯 429 N叉树的层序遍历 2020-08-26 429.N叉树的层序遍历 590 N叉树的后序遍历 2020-08-26 590.N叉树的后序遍历 111 二叉树的最小深度 2020-08-26 111.二叉树的最小深度 637 二叉树的层平均值 2020-08-26 637.二叉树的层平均值 338 比特位计数 2020-08-26 338.比特位计数 965 单值二叉树 2020-08-26 965.单值二叉树 617 合并二叉树 2020-08-26 617.合并二叉树 108 将有序数组转换为二叉搜索树 2020-08-26 108.将有序数组转换为二叉搜索树 20 有效的括号 2020-08-28 20.有效的括号 404 左叶子之和 2020-08-28 404.左叶子之和 349 两个数组的交集 2020-08-28 349.两个数组的交集 345 反转字符串中的元音字母 2020-08-28 345.反转字符串中的元音字母 326 3的幂 2020-08-28 326.3的幂 7 整数反转 2020-08-28 7.整数反转 202 快乐数 2020-08-28 202.快乐数 9. 回文数 2020-08-28 9. 回文数 589. N叉树的前序遍历 2020-08-28 589.N叉树的前序遍历 2. 两数相加 2020-08-28 2.两数相加 867. 转置矩阵 2020-09-01 867.转置矩阵 235. 二叉搜索树的最近公共祖先 2020-09-02 235.二叉搜索树的最近公共祖先 566. 重塑矩阵 2020-09-02 566.重塑矩阵 693. 交替位二进制数 2020-09-02 693.交替位二进制数 476. 数字的补数 2020-09-03 476.数字的补数 169. 多数元素 2020-09-03 169.多数元素 268. 缺失数字 2020-09-03 268. 缺失数字 1009. 十进制整数的反码 2020-09-03 1009.十进制整数的反码 203. 移除链表元素 2020-09-03 203.移除链表元素 234. 回文链表 2020-09-03 234.回文链表 19. 删除链表的倒数第N个节点 2020-09-03 19.删除链表的倒数第N个节点 260. 只出现一次的数字 III 2020-09-03 260.只出现一次的数字III 160. 相交链表 2020-09-03 160.相交链表 190. 颠倒二进制位 2020-09-04 190.颠倒二进制位 389. 找不同 2020-09-04 389.找不同 477. 汉明距离总和 2020-09-04 477.汉明距离总和 201. 数字范围按位与 2020-09-04 201.数字范围按位与 24. 两两交换链表中的节点 2020-09-04 24.两两交换链表中的节点 1281. 整数的各位积和之差 2020-09-04 1281.整数的各位积和之差 1295. 统计位数为偶数的数字 2020-09-04 1295.统计位数为偶数的数字 28. 实现 strStr() 2020-09-05 28.实现strStr 925. 长按键入 2020-09-05 925.长按键入 125. 验证回文串 2020-09-05 125.验证回文串 350. 两个数组的交集 II 2020-09-05 350.两个数组的交集II 290. 单词规律 2020-09-05 290.单词规律 219. 存在重复元素 II 2020-09-05 219.存在重复元素II 205. 同构字符串 2020-09-05 205.同构字符串 208. 实现 Trie (前缀树) 2020-09-05 208.实现Trie(前缀树) 171. Excel表列序号 2020-09-05 171.表列序号 263. 丑数 2020-09-05 263.丑数 146. LRU缓存机制 2020-09-06 146.LRU缓存机制 46. 全排列 2020-09-06 46.全排列 58. 最后一个单词的长度 2020-09-07 58.最后一个单词的长度 434. 字符串中的单词数 2020-09-07 434.字符串中的单词数 917. 仅仅反转字母 2020-09-07 917.仅仅反转字母 107. 二叉树的层次遍历 II 2020-09-08 107.二叉树的层次遍历II 515. 在每个树行中找最大值 2020-09-08 515.在每个树行中找最大值 113. 路径总和 II 2020-09-08 113.路径总和II 257. 二叉树的所有路径 2020-09-08 257.二叉树的所有路径 236. 二叉树的最近公共祖先 2020-09-09 236.二叉树的最近公共祖先 258. 各位相加 2020-09-10 258.各位相加 129. 求根到叶子节点数字之和 2020-09-10 129.求根到叶子节点数字之和 1022. 从根到叶的二进制数之和 2020-09-10 1022.从根到叶的二进制数之和 118. 杨辉三角 2020-09-11 118.杨辉三角 119. 杨辉三角 II 2020-09-11 119.杨辉三角II 633. 平方数之和 2020-09-11 633.平方根之和 79. 单词搜索 2020-09-12 79.单词搜索 62. 不同路径 2020-09-13 62.不同路径 63. 不同路径 II 2020-09-13 63.不同路径 905. 按奇偶排序数组 2020-09-27 905. 按奇偶排序数组 66. 加一 2020-09-27 66. 加一 283. 移动零 2020-09-28 283.移动零 557. 反转字符串中的单词 III 2020-09-28 557.反转字符串中的单词III 75. 颜色分类 2020-09-28 75. 颜色分类 771. 宝石与石头 2020-09-29 771.宝石与石头 199. 二叉树的右视图 2020-10-02 199.二叉树的右视图 1118. 一月有多少天 2020-10-03 1118. 一月有多少天 LCP 17. 速算机器人 2020-10-03 LCP 17. 速算机器人 1154. 一年中的第几天 2020-10-03 1154. 一年中的第几天 383. 赎金信 2020-10-03 383. 赎金信 709. 转换成小写字母 2020-10-03 709. 转换成小写字母 48. 旋转图像 2020-10-05 48. 旋转图像 15. 三数之和 2020-10-05 15. 三数之和 18. 四数之和 2020-10-02 18. 四数之和 74. 搜索二维矩阵 2020-10-02 74. 搜索二维矩阵 739. 每日温度 2020-10-02 739. 每日温度 22. 括号生成 2020-10-02 22. 括号生成 303. 区域和检索 - 数组不可变 2020-10-02 303. 区域和检索 - 数组不可变 1265. 逆序打印不可变链表 2020-10-02 1265. 逆序打印不可变链表 1441. 用栈操作构建数组 2020-10-07 1441. 用栈操作构建数组 1047. 删除字符串中的所有相邻重复项 2020-10-07 1047. 删除字符串中的所有相邻重复项 682. 棒球比赛 2020-10-07 682. 棒球比赛 946. 验证栈序列 2020-10-07 946. 验证栈序列 150. 逆波兰表达式求值 2020-10-07 150. 逆波兰表达式求值 496. 下一个更大元素 I 2020-10-07 496. 下一个更大元素 I 152. 乘积最大子数组 2020-10-09 15.乘积最大子数组 17. 电话号码的字母组合 2020-10-09 17. 电话号码的字母组合 538. 把二叉搜索树转换为累加树 2020-10-09 538. 把二叉搜索树转换为累加树 760. 找出变位映射 2020-10-09 760.找出变位映射 11. 盛最多水的容器 2020-10-10 11.盛最多水的容器 560. 和为K的子数组 2020-10-10 560.和为K的子数组 448. 找到所有数组中消失的数字 2020-10-10 448.找到所有数组中消失的数字 215. 数组中的第K个最大元素 2020-10-13 215. 数组中的第K个最大元素 200. 岛屿数量 2020-11-13 200. 岛屿数量 976. 三角形的最大周长 2020-11-28 976. 三角形的最大周长 1025. 除数博弈 2020-11-29 1025.除数博弈 27. 移除元素 2020-11-30 27.移除元素 6. Z 字形变换 2020-11-30 6.Z字形变换 92. 反转链表 II 2020-11-30 92.反转链表II 222. 完全二叉树的节点个数 2020-12-05 222.完全二叉树的节点个数 240. 搜索二维矩阵 II 2020-12-09 240.搜索二维矩阵 II 153. 寻找旋转排序数组中的最小值 2020-12-09 153.寻找旋转排序数组中的最小值 154. 寻找旋转排序数组中的最小值 II 2020-12-09 154.寻找旋转排序数组中的最小值II 33. 搜索旋转排序数组 2020-12-09 33.搜索旋转排序数组 81. 搜索旋转排序数组 II 2020-12-09 81.搜索旋转排序数组II 264. 丑数 II 2020-12-09 264.丑数II 204.计数质数 2020-12-09 204.计数质数 228.汇总区间 2020-12-15 228.汇总区间 2020-12-09 2020-12-09 链表中一个很重要的点就是，当删除链表中的某个节点，我们可能会觉得删除头节点或者删除尾节点，此时我们可以通过建立一个哨兵节点来解决这些问题。 由于编译器的优化，当方法调用出现函数末尾时，没有其它操作要执行，编译器在编译代码时，就不会开辟新的栈空间，而是直接覆盖当前栈执行。根据此思路使用尾递归进行求解，当递归到n==0时，就可得到对应的解。参考 位运算：两个数异或 其实就是 无进位相加 二分查找：计算 mid 时需要技巧防止溢出，mid = left + (right - left) >> 1 目前为止，讲解二分最好的文章，没有之一 参考 这个博主里面有一些关于算法，计算机网络以及数据库的文章，自己需要好好看一下链接) 分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节 对于这个数组，算法会返回 1。这个 1 的含义可以这样解读：nums 中小于 2 的元素有 1 个。 动态规划 动态规划问题的一般形式就是求最值 求解动态规划的核心问题是穷举。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗 动态规划三要素：重叠子问题，最优子结构，正确的状态转移方程 重叠子问题：首先，动态规划的穷举有点特别，因为这类问题存在「重叠子问题」，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算 最优子结构：动态规划问题一定会具备「最优子结构」，才能通过子问题的最值得到原问题的最值 正确的状态转移方程：问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出正确的「状态转移方程」才能正确地穷举。在实际的算法问题中，写出状态转移方程是最困难的。我来提供我研究出来的一个思维框架，辅助你思考状态转移方程：明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义 回溯： 解决一个回溯问题，实际上就是一个决策树的遍历过程。你只需要思考 3 个问题： 1、路径：也就是已经做出的选择。 2、选择列表：也就是你当前可以做的选择。 3、结束条件：也就是到达决策树底层，无法再做选择的条件。 result = [] def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: 做选择 backtrack(路径, 选择列表) 撤销选择 回溯解题思路： 字符串 去掉尾部的空格 i := len(s)-1 for i >= 0 && s[i] == ' ' { i -= 1 } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/2.两数相加/code.html":{"url":"LeetCode/2.两数相加/code.html","title":"2.两数相加","keywords":"","body":"2. 两数相加方法一：迭代方法二：递归方法三[推荐]：参照LeetCode上的代码进行改进2. 两数相加 方法一：迭代 思路：首先计算两个链表公共部分的和，然后计算剩余链表与carry的和。 注意：最后可能会两个链表遍历完，但是还有进位，此时我们需要新建一个节点存放进位 执行用时：12 ms, 在所有 Go 提交中击败了73.46%的用户 内存消耗：5 ms, 在所有 Go 提交中击败了91.50%的用户 func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { if l1 == nil { return l2 } if l2 == nil { return l1 } dummyNode := &ListNode{} //用来当做返回结果的链表头部 head := dummyNode carry := 0 //用来记录进位 val := 0 //用来记录当前两节点对应值的和 //两链表都不空的时候 for l1 != nil && l2 != nil { val = l1.Val + l2.Val + carry //注意点1：注意carry写在这里 //每次都需要重置进位 carry = val / 10 //建立当前节点 node := &ListNode{ Val: val % 10, } head.Next = node l1, l2, head = l1.Next, l2.Next, head.Next } //以下两个条件只会满足一个 //若l1不空 for l1 != nil { val = l1.Val + carry //注意点1：注意carry写在这里 //每次都需要重置进位 carry = val / 10 node := &ListNode{Val: val % 10} head.Next = node l1, head = l1.Next, head.Next } //若l2不空 for l2 != nil { val = l2.Val + carry //注意点1：注意carry写在这里 //每次都需要重置进位 carry = val / 10 node := &ListNode{Val: val % 10} head.Next = node l2, head = l2.Next, head.Next } //如果链表都遍历完成，但是最后还是有进位 //此时还是要创建一个节点 //例如：输入 第1个链表为5 输入第2个链表也是5 if carry > 0 { head.Next = &ListNode{Val: carry} } return dummyNode.Next } 方法二：递归 思路：递归将链表中的两数相加合并为6种如下情况，代码中有注释 若l1, l2 都为空，且进位为0，直接返回nil 若l1为空, l2 不空，且进位为0，直接返回l2 若l2为空, l1 不空，且进位为0，直接返回l1 若l1为空, l2 不空，且进位不为0，需要不断计算l2与进位 若l1不空, l2 空，且进位不为0，需要不断计算l1与进位 若l1不空, l2 不空，需要不断计算l1+l2+进位 执行用时：16 ms, 在所有 Go 提交中击败了40.85%的用户 内存消耗：4.8 ms, 在所有 Go 提交中击败了94.47%的用户 func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { if l1 == nil { return l2 } if l2 == nil { return l1 } return addTwoNumbersCore(l1, l2, 0) } func addTwoNumbersCore(l1 *ListNode, l2 *ListNode, carry int) *ListNode { //如果最后两个链表都空，但是还有进位 if l1 == nil && l2 == nil && carry != 0 { return &ListNode{Val: carry} }else if l1 == nil && carry == 0 { //如果l2不空，且没有进位 return l2 }else if l2 == nil && carry == 0 { //如果l1不空，且没有进位 return l1 }else if l1 == nil && carry != 0 { //如果l2不空，且有进位 l2.Val = l2.Val + carry l2.Val, l2.Next = l2.Val % 10, addTwoNumbersCore(l1, l2.Next, l2.Val / 10) return l2 } else if l2 == nil && carry != 0 { //如果l1不空，且有进位 l1.Val = l1.Val + carry l1.Val, l1.Next = l1.Val % 10, addTwoNumbersCore(l1.Next, l2, l1.Val / 10) return l1 } //到这里说明l1, l2都有 l1.Val, l1.Next = (l2.Val + l1.Val + carry) % 10, addTwoNumbersCore(l1.Next, l2.Next, (l2.Val + l1.Val + carry) / 10) return l1 } 方法三[推荐]：参照LeetCode上的代码进行改进 改进：直接使用一个while循环就可以进行解决，不用像我们之前那样写那么多复杂的代码。代码简洁，思路清晰 执行用时：12 ms, 在所有 Go 提交中击败了73.45%的用户 内存消耗：5 ms, 在所有 Go 提交中击败了61.23%的用户 func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { if l1 == nil { return l2 } if l2 == nil { return l1 } dummyNode := &ListNode{} head := dummyNode carry := 0 var val int for l1 != nil || l2 != nil { val = 0 if l1 != nil { val += l1.Val l1= l1.Next } if l2 != nil { val += l2.Val l2=l2.Next } head.Next = &ListNode{ Val: (val + carry) % 10, } carry = (val + carry) / 10 head = head.Next } if carry > 0 { head.Next = &ListNode{ Val: carry, } } return dummyNode.Next } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/6.Z字形变换/code.html":{"url":"LeetCode/6.Z字形变换/code.html","title":"6.Z字形变换","keywords":"","body":"6. Z 字形变换方法一：6. Z 字形变换 方法一： 虽然看起来比较难，但是是一道规律题 因为每一行都是有规律可循，所以最外层需要的循环次数就是我们的行数。 对于每一行，除了第一行和最后一行只有一个间距，其他都有两个间距，其中第一个间距一定是rows，第2个间距假设为j，那么一定有j + 第1个间距的和为rows，对于除了第一行和最后一行的任意一行都适用。 所以使用一个变量不断切换两个间距即可。 package main /** * @Author: yirufeng * @Date: 2020/11/29 12:00 下午 * @Desc: 6.Z字形变换 **/ func convert(str string, rows int) string { if rows 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/7.整数反转/code.html":{"url":"LeetCode/7.整数反转/code.html","title":"7.整数反转","keywords":"","body":"7. 整数反转方法：直接进行反转方法二【推荐】：针对方法一的缺陷进行改进7. 整数反转 方法：直接进行反转 注意事项：注意反转过程中可能会越界，一旦越界直接返回0 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.2 ms, 在所有 Go 提交中击败了100.00%的用户 func reverse(x int) int { if x == 0 { return x } //flag用来表示是否为负数 flag := false temp := x if temp = 214748365 || ((num >= 214748364) && temp >= 8) { return 0 } num = num * 10 + temp % 10 temp /= 10 } if flag { num *= (-1) } return num } 方法二【推荐】：针对方法一的缺陷进行改进 上面的代码有缺陷，一旦输入一个负数为-2147483647，那么乘以-1之后就会越界，所以我们使用下面的代码进行纠正。 执行用时：4 ms, 在所有 Go 提交中击败了47.38%的用户 内存消耗：2.2 ms, 在所有 Go 提交中击败了67.85%的用户 func reverse(x int) int { if x == 0 { return x } //flag用来表示是否为负数 //flag := false temp := x //if temp = 214748365 || ((num >= 214748364) && temp >= 8) || num 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/9.回文数/code.html":{"url":"LeetCode/9.回文数/code.html","title":"9.回文数","keywords":"","body":"9. 回文数方法一：反转后直接比较和原数是否相等方法二：方法三：将数字转换为字符串进行反转看是否匹配方法四：参照LeetCode解法9. 回文数 方法一：反转后直接比较和原数是否相等 注意：反转过程中会溢出，因此不建议采用这种做法 方法二： 思路：建立一个数字num，使得与x的最高位都在同一位，但是num的最高位为1，之后依次判断x的最高位和最低位是否相同， 如果不相同则直接返回false 如果相同需要去掉x的最高位和最低位继续判断 不断重复以上步骤，直到x只剩一位 执行用时：8 ms, 在所有 Go 提交中击败了98.04%的用户 内存消耗：5.2 ms, 在所有 Go 提交中击败了100.00%的用户 ​```go func isPalindrome(x int) bool { if x if x == 0 { return true } num := 1 //构造最高位的1 for x/(num*10) > 0 { num *= 10 } //依次判断x的最高位和最低位是否同，并不断去掉最高位和最低位 for num >= 10 { //最低位和最高位不同 if x%10 != (x / num % 10) { return false } //x去掉%最高位和最低位 x = x % num / 10 //num缩小 num /= 100 } return true } ``` 方法三：将数字转换为字符串进行反转看是否匹配 方法四：参照LeetCode解法 思路：因为数字是回文数，数字一定是左右对称的，所以数字反转一半看是否匹配 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/14.最长公共前缀/code.html":{"url":"LeetCode/14.最长公共前缀/code.html","title":"14.最长公共前缀","keywords":"","body":"14. 最长公共前缀方法：14. 最长公共前缀 方法： 核心：因为是求公共最长前缀，所以只要任意的两个字符串的公共前缀也可能是最长公共前缀 思路： 假设第1个字符为公共前缀(prefix)， 然后不断与后面的进行匹配，查看当后面的字符串作为主串，我们这个prefix作为子串， 看一下是否匹配， 3.1 如果匹配则继续与将下一个字符串作为主串，重复该操作， 3.2 如果不匹配，则我们不断将prefix尾巴不断去掉直到匹配为止，如果中间prefix为空，我们可以直接返回一个空串 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.3 ms, 在所有 Go 提交中击败了92.78%的用户 func longestCommonPrefix(strs []string) string { if len(strs) 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/19.删除链表的倒数第N个节点/code.html":{"url":"LeetCode/19.删除链表的倒数第N个节点/code.html","title":"19.删除链表的倒数第N个节点","keywords":"","body":"19. 删除链表的倒数第N个节点方法：保持固定距离的双指针 + 哨兵节点19. 删除链表的倒数第N个节点 方法：保持固定距离的双指针 + 哨兵节点 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.3 ms, 在所有 Go 提交中击败了5.78%的用户 因为我们找的是要删除节点的前一个节点。 思路：关键是要保持快慢两个指针的距离，因为快指针指向最后一个Nil的时候，慢指针指向倒数第n+1个节点，距离为n+1 1. 建立一个dummyNode, 让fast, slow 都指向这个节点 2. 让快指针先走n+1步 3. 之后快慢同时走，当快走向nil的时候，慢指向要删除节点的前一个节点 4. 修改指针指向并返回dummyNode.Next 我们找的是要删除节点的前一个节点，因此使用哨兵节点是为了怕删除头节点 思路：关键是要保持快慢两个指针的距离，因为快指针指向最后一个Nil的时候，慢指针指向倒数第n+1个节点，距离为n+1。 建立一个dummyNode, 让fast, slow 都指向这个节点 让快指针先走n+1步 之后快慢同时走，当快走向nil的时候，慢指向要删除节点的前一个节点 修改指针指向并返回dummyNode.Next func removeNthFromEnd(head *ListNode, n int) *ListNode { if head == nil { return nil } dummyNode := &ListNode{Next: head} fast, slow := dummyNode, dummyNode for i := 0; i 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/20.有效的括号/code.html":{"url":"LeetCode/20.有效的括号/code.html","title":"20.有效的括号","keywords":"","body":"20. 有效的括号方法一：借助栈+map进行匹配20. 有效的括号 方法一：借助栈+map进行匹配 思路：借助栈来进行匹配，同时使用map来存储右括号和左括号，其中键为右括号，值为左括号，以后遍历到当前字符为右括号，直接使用map[key]得到对应的左括号与栈顶元素相匹配。如果遍历到当前字符为左括号，直接将其压入栈中 注意： 传入的字符串如果长度为奇数一定不是有效的括号 当取栈顶的时候一定要确保栈里面有元素，如果没有直接返回false 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.1 ms, 在所有 Go 提交中击败了16.17%的用户 func isValid(s string) bool { //如果字符串长度为0返回true if len(s) == 0 { return true } else if len(s)&1 == 1 { //如果字符串长度为奇数直接返回false return false } mymap := map[string]string{ \")\": \"(\", \"]\": \"[\", \"}\": \"{\", } stack := []string{} for _, val := range s { if string(val) == \"(\" || string(val) == \"[\" || string(val) == \"{\" { stack = append(stack, string(val)) } else { //如果当前字符是右括号看下对应的左括号是否与栈顶一致 //注意这里必须要加上一个条件len(stack)>0，因为很有可能一开始就是一个右括号 if len(stack) > 0 && mymap[string(val)] == stack[len(stack)-1] { //如果一致就弹出栈顶 stack = stack[:len(stack)-1] } else { //不一致就返回false return false } } } //最后检查栈是否为空 return len(stack) == 0 } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/24.两两交换链表中的节点/code.html":{"url":"LeetCode/24.两两交换链表中的节点/code.html","title":"24.两两交换链表中的节点","keywords":"","body":"24. 两两交换链表中的节点方法：24. 两两交换链表中的节点 方法： 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.1 MB, 在所有 Go 提交中击败了10.26%的用户 思路：直接交换，步骤如下，前提条件，如果当前节点以及当前节点的下一个节点都不为空： 首先如果当前节点的上一个节点不空，将上一个节点的指针指向当前节点的下一个节点 将当前节点的指针指向下下个节点，同时当前节点的下下个节点指针指向当前节点，同时移动prev到当前节点，同时将当前节点移动到下下个节点 func swapPairs(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } prev, cur := head, head prev = nil ret := head.Next for cur != nil && cur.Next != nil { if prev != nil { prev.Next = cur.Next } cur.Next, cur.Next.Next, prev, cur = cur.Next.Next, cur, cur, cur.Next.Next } return ret } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/26.删除排序数组中的重复项/code.html":{"url":"LeetCode/26.删除排序数组中的重复项/code.html","title":"26.删除排序数组中的重复项","keywords":"","body":"26. 删除排序数组中的重复项方法一：方法二【推荐】：26. 删除排序数组中的重复项 方法一： 思路：新建一个数组，存储不重复的元素。之后将该数组的元素复制给原数组 执行用时：12 ms, 在所有 Go 提交中击败了37.98%的用户 内存消耗：5.2 ms, 在所有 Go 提交中击败了5.26%的用户 func removeDuplicates(nums []int) int { if len(nums) 方法二【推荐】： 思路：使用双指针，两个指针都存储元素的下标，第一个指针指向第一个重复的元素，第二个指针指向下一个要放的元素。 具体细节看代码注释即可 执行用时：4 ms, 在所有 Go 提交中击败了99.35%的用户 内存消耗：4.6 ms, 在所有 Go 提交中击败了99.91%的用户 func removeDuplicates(nums []int) int { if len(nums) =nums[right]，因为数组升序，并且left是已经放置到最终位置的元素 //因此我们下一个要放置的元素一定比left指向的元素大 for right = nums[right] { right += 1 } //如果right已经越界，说明此时已经有序 if right >= len(nums) { break } //说明left指向的元素没有重复元素 if left == right-1 { left += 1 } else { nums[left+1], nums[right] = nums[right], nums[left+1] left += 1 } } return left + 1 } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/27.移除元素/code.html":{"url":"LeetCode/27.移除元素/code.html","title":"27.移除元素","keywords":"","body":"27. 移除元素方法一：错误方法27. 移除元素 方法一： 思路：使用两个索引，其中1个从前往后指向我们要删除的值，另外一个从后往前，指向非删除值的元素。之后交换。 注意点：两个索引用start以及end代替，由于初始情况下，我们不知道第一个元素是否为要删除的元素，所以我们初始状态让start=-1，避免数组里面全部都是要删除的值的元素。 也就是说，我们让start的意义：指向的元素我们可以理解为已经没有要删除元素值的数组的最后一个位置。因而最后返回的新数组的长度应该为start+1 //执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 //内存消耗：2.1 MB, 在所有 Go 提交中击败了85.68%的用户 //这道题自己没做出来就卡在这里，关键核心special case 如何处理输入的一个数组全部都是我们要删除元素的情况 //✅：自己可以使用一个指针，从-1开始，如果没有找到就指向-1 //这次改变了start的意义：已经确定过没有我们要找的元素的数组对应的最后一个位置的下标， func removeElement(nums []int, val int) int { //包含两种情况：一种是数组本来就为空，另一种是数组只有一个我们要删除的元素 if len(nums) == 0 || len(nums) == 1 && nums[0] == val { return 0 } //如果数组长度为1并且不是我们要删除的元素直接返回1 if len(nums) == 1 && nums[0] != val { return 1 } //start指向第一个值为val的元素，end指向最后一个值不为val的元素 start, end := -1, len(nums)-1 for start 另外一种写法： //第二种写法 //另外一种写法：上面的for循环可以改写成下面这样 //执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 //内存消耗：2.1 MB, 在所有 Go 提交中击败了49.68%的用户 func removeElement(nums []int, val int) int { //包含两种情况：一种是数组本来就为空，另一种是数组只有一个我们要删除的元素 if len(nums) == 0 || len(nums) == 1 && nums[0] == val { return 0 } //如果数组长度为1并且不是我们要删除的元素直接返回1 if len(nums) == 1 && nums[0] != val { return 1 } //start指向第一个值为val的元素，end指向最后一个值不为val的元素 start, end := -1, len(nums)-1 for start 错误方法 由于直接让start从第1个元素开始，并不知道第1个元素是否该删除。 //自己第一时间想出来的方法： //采用两个指针，一个指向第一个值为val的元素，以及最后一个值不是val的元素，然后交换 //❌：因为可能输入的数组全部都是我们要移除的数 func removeElement(nums []int, val int) int { //包含两种情况：一种是数组本来就为空，另一种是数组只有一个我们要删除的元素 if len(nums) == 0 || len(nums) == 1 && nums[0] == val { return 0 } //如果数组长度为1并且不是我们要删除的元素直接返回1 if len(nums) == 1 && nums[0] != val { return 1 } //start指向第一个值为val的元素，end指向最后一个值不为val的元素 start, end := 0, len(nums)-1 for start 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/28.实现strStr/code.html":{"url":"LeetCode/28.实现strStr/code.html","title":"28.实现strStr","keywords":"","body":"28. 实现 strStr()方法一：调用库函数方法二：自己的解法，双指针其他方法：28. 实现 strStr() 方法一：调用库函数 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.3 MB, 在所有 Go 提交中击败了99.56%的用户 func strStr(haystack string, needle string) int { return strings.Index(haystack, needle) } 方法二：自己的解法，双指针 思路： 第1个指针指向第1个字符串的字符，第2个指针指向第2个字符串，每次比较 如果相等，则继续比较第1个字符串后面的字符与第2个字符串后面的字符是否相等， 不相等，第1个指针走到下一个位置，同时第2个指针回到起点位置。继续判断 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.3 MB, 在所有 Go 提交中击败了99.56%的用户 func strStr(haystack string, needle string) int { if len(haystack) == 0 || len(needle) == 0 { return 0 } if len(haystack) 其他方法： KMP，参考leetCode的官方题解以及评论区 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/35.搜索插入位置/code.html":{"url":"LeetCode/35.搜索插入位置/code.html","title":"35.搜索插入位置","keywords":"","body":"35. 搜索插入位置方法一：顺序查找方法二：自己写的二分查找方法三：LeetCode上的二分查找35. 搜索插入位置 方法一：顺序查找 时间复杂度：O(N) 执行用时：4 ms, 在所有 Go 提交中击败了90.20%的用户 内存消耗：3.1 MB, 在所有 Go 提交中击败了100.00%的用户 func searchInsert(nums []int, target int) int { index := 0 for i := 0; i target { break } index = i } if len(nums) != 0 && nums[index] 方法二：自己写的二分查找 思路：题目中说了是有序数组，需要进行后处理，因为可能最后一个元素小于目标值，我们需要插入到最后一个元素索引的下一个，所以需要和最后一个元素比较一下。 执行用时：4 ms, 在所有 Go 提交中击败了90.20%的用户 内存消耗：3.1 MB, 在所有 Go 提交中击败了100.00%的用户 func searchInsert(nums []int, target int) int { if len(nums) == 0 { return 0 } left, right := 0, len(nums)-1 for left > 1 if nums[mid] > target { right = mid } else if nums[mid] 方法三：LeetCode上的二分查找 思路：使用了二分查找模板I 执行用时：4 ms, 在所有 Go 提交中击败了90.20%的用户 内存消耗：3.1 MB, 在所有 Go 提交中击败了100.00%的用户 func searchInsert(nums []int, target int) int { left, right := 0, len(nums)-1 for left > 1 if nums[mid] > target { right = mid - 1 } else if nums[mid] 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/46.全排列/code.html":{"url":"LeetCode/46.全排列/code.html","title":"46.全排列","keywords":"","body":"46. 全排列方法：回溯46. 全排列 方法：回溯 执行用时：0ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.8 MB, 在所有 Go 提交中击败了24.00%的用户 思路：DFS 当满足退出条件，也就是长度等于我们给的切片的长度就可以将其加入结果中。 注意要拷贝，因为golang中二维数组存储的是一维数组的引用 func permute(nums []int) [][]int { if len(nums) == 0 { return nil } used, cur, res := make([]bool, len(nums)), []int{}, [][]int{} generatePermutation(&nums, &res, &used, cur) return res } func generatePermutation(nums *[]int, res *[][]int, used *[]bool, cur []int) { //添加正确之后的对比 if len(*nums) == len(cur) { temp := make([]int, len(cur)) copy(temp, cur) *res = append(*res, temp) return } for i := 0; i 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/53.最大子序和/code.html":{"url":"LeetCode/53.最大子序和/code.html","title":"53.最大子序和","keywords":"","body":"53. 最大子序和方法一：brute-force方法二：dp方法三：dp进行状态压缩53. 最大子序和 方法一：brute-force 暴力：直接穷举所有区间的起点和终点，计算区间内所有元素的和与最大值比较 执行用时：108 ms, 在所有 Go 提交中击败了5.02%的用户 内存消耗：3.3 MB, 在所有 Go 提交中击败了100.00%的用户 时间复杂度：O(N^2) 空间复杂度：O(1) func maxSubArray(nums []int) int { if len(nums) max { max = sum } } } return max } 方法二：dp 时间复杂度：O(N) 空间复杂度：O(N) 执行用时：8 ms, 在所有 Go 提交中击败了58.79%的用户 内存消耗：3.5 MB, 在所有 Go 提交中击败了17.46%的用户 步骤： basecase dp[0] = nums[0] 状态： dp[i] = 连续数组在结束为止为i时的最大和 选择： 区间结束位置为i，是否需要前面的子序和呢，如果当前值要上前面的子序和变小就不要 dp数组： dp[i] = max(dp[i-1]+nums[i], nums[i]) 最后的结果也就是找dp数组的最大值即可 func maxSubArray(nums []int) int { if len(nums) nums[i] { dp[i] = dp[i-1] + nums[i] } else { dp[i] = nums[i] } //如果比最大子序和还要大 if max 方法三：dp进行状态压缩 改进：相比方法二进行改进，复用我们传入进来的数组 时间复杂度：O(N) 空间复杂度：O(1) 执行用时：8 ms, 在所有 Go 提交中击败了58.79%的用户 内存消耗：3.3 MB, 在所有 Go 提交中击败了72.71%的用户 func maxSubArray(nums []int) int { if len(nums) nums[i] { nums[i] = nums[i-1] + nums[i] } //如果比最大子序和还要大 if max 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/58.最后一个单词的长度/code.html":{"url":"LeetCode/58.最后一个单词的长度/code.html","title":"58.最后一个单词的长度","keywords":"","body":"58. 最后一个单词的长度方法一：调用库函数末尾去空格方法二：改进。自己实现末尾去空格58. 最后一个单词的长度 方法一：调用库函数末尾去空格 思路： 使用一个指针指向最后一个字符串， 如果指针指向的字符为空格，此时直接返回length 如果指针指向的不是空格，每次length+1,并且不断左移 注意：输入的参数中末尾有可能有空格 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.1 ms, 在所有 Go 提交中击败了27.14%的用户 func lengthOfLastWord(s string) int { length := 0 //记得去掉首尾两边的空格 s = strings.Trim(s, \" \") for i := len(s) - 1; i >= 0; i-- { if s[i] == ' ' { break } length += 1 } return length } 方法二：改进。自己实现末尾去空格 改进：自己用一个循环去掉末尾的空格 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.1 ms, 在所有 Go 提交中击败了75.25%的用户 func lengthOfLastWord(s string) int { length := 0 //自己手动实现去掉尾部的空格 i := len(s)-1 for i >= 0 && s[i] == ' ' { i -= 1 } for ; i >= 0; i-- { if s[i] == ' ' { break } length += 1 } return length } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/62.不同路径/code.html":{"url":"LeetCode/62.不同路径/code.html","title":"62.不同路径I","keywords":"","body":"62. 不同路径方法一：普通dp方法二：状态压缩的dp62. 不同路径 方法一：普通dp 也就是使用一个二维数据进行状态转移，这里不再进行赘述 方法二：状态压缩的dp 步骤： base case 使用一个一维数组，初始全为1，长度为列数 状态定义：matrix[i] 到达第i列的走法 选择：可以选择向下或者向右 dp方程：matrix[i] = matrix[i-1] + matrix[i] 最终的结果为matrix的最后一个元素 时间复杂度：O(m * n) 空间复杂度：O(n) 执行用时：0 ms, 在所有 Go 提交中击败了 100.00% 的用户 内存消耗：2 MB, 在所有 Go 提交中击败了 89.04% 的用户 func uniquePaths(m int, n int) int { path := make([]int, n) //初始化状态矩阵 for i := 0; i 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/63.不同路径/code.html":{"url":"LeetCode/63.不同路径/code.html","title":"63.不同路径II","keywords":"","body":"63. 不同路径 II方法一：dp方法二：dp进行代码改进63. 不同路径 II 方法一：dp 这里自己觉得不可以使用状态压缩 步骤： 明确base case ：第一行遇到一个障碍物，则该障碍物开始一直到该行结束的走法为0 状态：dp[i][j] 表示走到i,j的走法 选择：可以选择向右或者向下，但是如果右边是障碍物只可以向下 dp方程： 如果当前位置就有障碍物，直接进入下一个，因为有障碍物不用计算使用默认的0就可以 dp[i][j] = dp[i-1][j] + dp[i][j-1] 要求两边都不可以有障碍物 dp[i][j] = dp[i-1][j] 如果左边有障碍物 dp[i][j] = dp[i][j-1] 如果右边有障碍物 其实dp方程可以简写为 dp[i][j] = dp[i-1][j] + dp[i][j-1] 如果i,j上没有障碍物则= 0 如果i,j上没有障碍物 最终的结果我们就放置在了dp的最后一行的最后一列中 执行用时：0 ms, 在所有 Go 提交中击败了 100.00% 的用户 内存消耗：2.6 MB, 在所有 Go 提交中击败了 20.64% 的用户 func uniquePathsWithObstacles(obstacleGrid [][]int) int { //输入非法判断 if len(obstacleGrid) 方法二：dp进行代码改进 func uniquePathsWithObstacles(obstacleGrid [][]int) int { //输入非法判断 if len(obstacleGrid) 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/64.最小路径和/code.html":{"url":"LeetCode/64.最小路径和/code.html","title":"64.最小路径和","keywords":"","body":"64. 最小路径和方法一：dp方法二：dp改进64. 最小路径和 方法一：dp 步骤： basecase：dp[0][0]=grid[0][0], `dp[0][i]=dp[0][i-1]+grid[0][i]`, `dp[i][0]=dp[i-1][0]` 状态定义：dp[i][j]表示从左上角到该点的最小路径和 选择：每次可以向右或向下 状态转移方程：dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] 执行用时：12 ms, 在所有 Go 提交中击败了17.20%的用户 内存消耗：5 MB, 在所有 Go 提交中击败了5.36%的用户 func minPathSum(grid [][]int) int { if len(grid) == 0 || len(grid[0]) == 0 { return 0 } dp := make([][]int, len(grid)) dp[0] = append(dp[0], grid[0][0]) //初始化第1行 for i := 1; i 方法二：dp改进 改进：复用输入数组进行状态压缩 执行用时：8 ms, 在所有 Go 提交中击败了90.93%的用户 内存消耗：3.9 MB, 在所有 Go 提交中击败了82.14%的用户 步骤： basecase：dp[0][0]=grid[0][0], `dp[0][i]=dp[0][i-1]+grid[0][i]`, `dp[i][0]=dp[i-1][0]` 状态定义：dp[i][j]表示从左上角到该点的最小路径和 选择：每次可以向右或向下 状态转移方程：dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] func minPathSum(grid [][]int) int { if len(grid) == 0 || len(grid[0]) == 0 { return 0 } //初始化第1行 for i := 1; i 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/66加一/code.html":{"url":"LeetCode/66加一/code.html","title":"66.加一","keywords":"","body":"66. 加一方法一：【自己的解法】【推荐】方法二：【参考提交用时100%】66. 加一 方法一：【自己的解法】 思路：从数组的最后一位依次从最后面进行遍历，然后每次加一并进行计算 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.1 ms, 在所有 Go 提交中击败了5.10%的用户 func plusOne(digits []int) []int { if len(digits) = 0; i-- { ret = append(ret, (carry+digits[i])%10) carry = (carry + digits[i]) / 10 } //说明到最后数组遍历完了，但是还是有进位 if carry != 0 { ret = append(ret, 1) } //反转ret for i := 0; i >1; i++ { ret[i], ret[len(ret)-1-i] = ret[len(ret)-1-i], ret[i] } //将我们反转后的结果进行返回 return ret } 【推荐】方法二：【参考提交用时100%】 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2 ms, 在所有 Go 提交中击败了41.43%的用户 func plusOne(digits []int) []int { for i := len(digits)-1; i >= 0; i-- { //如果当前位不是9，加一后直接返回 if digits[i] != 9 { digits[i] += 1 return digits } //如果当前位是9，说明该位会变成0 digits[i] = 0 } //走到最后，说明还有1个1要加到最前面 digits[0] = 1 //最后还要加上0 return append(digits, 0) } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/79.单词搜索/code.html":{"url":"LeetCode/79.单词搜索/code.html","title":"79.单词搜索","keywords":"","body":"79. 单词搜索方法：回溯79. 单词搜索 方法：回溯 改进点：如果访问过将该节点的值置换为'/'，之后重新回到该节点将其替换为原来的值 执行用时：4 ms, 在所有 Go 提交中击败了 98.25% 的用户 内存消耗：3.3 MB, 在所有 Go 提交中击败了 94.02% 的用户 func exist(board [][]byte, word string) bool { row, col := len(board), len(board[0]) for i := 0; i = row || rowIndex = col || colIndex 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/83删除排序链表中的重复元素/code.html":{"url":"LeetCode/83删除排序链表中的重复元素/code.html","title":"83.删除排序链表中的重复元素","keywords":"","body":"83. 删除排序链表中的重复元素方法一：83. 删除排序链表中的重复元素 方法一： 思路：直接删除 如果当前节点的值与下一个节点的值相同，则将当前节点指向下一个节点的下一个节点 如果当前节点的值与下一个节点的值不同， 则将当前节点移动到下一个节点 同时记得清除当前节点的下一个节点的野指针，让其指向nil 重复步骤1，2直到当前节点的下一个节点为Nil 执行用时：4 ms, 在所有 Go 提交中击败了86.85%的用户 内存消耗：3.1 MB, 在所有 Go 提交中击败了61.54%的用户 func deleteDuplicates(head *ListNode) *ListNode { if head == nil { return head } node := head for node.Next != nil { if node.Val == node.Next.Val { //记得清楚野指针 node.Next, node.Next.Next = node.Next.Next, nil } else { node = node.Next } } return head } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/88.合并两个有序数组/code.html":{"url":"LeetCode/88.合并两个有序数组/code.html","title":"88.合并两个有序数组","keywords":"","body":"88. 合并两个有序数组方法一：采用双指针88. 合并两个有序数组 方法一：采用双指针 思路：最开始想到用双指针，从前往后合并，但是需要一个数组空间来存储nums1这个目标数组原来的内容，因此最好的建议是从后往前合并，不需要额外空间 时间复杂度：O(m+n) 空间复杂度：O(1) 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.3 MB, 在所有 Go 提交中击败了68.70%的用户 func merge(nums1 []int, m int, nums2 []int, n int) { // 说明第2个数组初始化元素数量为0，都在第1个数组中 if n == 0 { return } if m == 0 { for i := 0; i nums2[n-1] { nums1[eleIndex] = nums1[m-1] m -= 1 } else { nums1[eleIndex] = nums2[n-1] n -= 1 } eleIndex -= 1 } //此时有一个数组一定弄完了 if n != -1 { for i := n-1; i >= 0; i-- { nums1[i] = nums2[i] } } return } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/92.反转链表II/code.html":{"url":"LeetCode/92.反转链表II/code.html","title":"92.反转链表II","keywords":"","body":"92. 反转链表 II方法一：92. 反转链表 II 方法一： 要反转第m个节点到第n个节点这一段。 找到4个节点：第m个节点的前一个节点prev，第m个节点start，第n个节点end，第n个节点的下一个节点next。 然后prev以及end的Next指针置空 反转start到end之间所有的节点 将prev的Next指向反转后的头end，将反转后的尾start的Next指向next 最后返回我们链表的头结点即可 注意：由于反转可能从开头节点开始，因此我们需要使用一个虚拟节点。 错误写法： //❌代码： //错误点：返回的结果错误，因为我们建立了一个虚拟头节点(避免从头部第1个节点开始进行翻转)，因此我们应该返回虚拟头节点的下一个节点 func reverseBetween(head *ListNode, m int, n int) *ListNode { //建立dummyNode为了防止删除头节点 dummyNode := &ListNode{} dummyNode.Next = head //从dummyNode走m-1步，此时来到反转开始节点的前一个节点， cur := dummyNode for i := 0; i 正确写法： //✅ //执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 //内存消耗：2.1 MB, 在所有 Go 提交中击败了86.23%的用户 //改正：只修改了返回值 func reverseBetween(head *ListNode, m int, n int) *ListNode { //建立dummyNode dummyNode := &ListNode{} dummyNode.Next = head //从dummyNode走m-1步，此时来到反转开始节点的前一个节点， cur := dummyNode for i := 0; i 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/98验证二叉搜索树/code.html":{"url":"LeetCode/98验证二叉搜索树/code.html","title":"98.验证二叉搜索树","keywords":"","body":"98 验证二叉搜索树方法一：判断中序遍历序列是否升序方法二：递归判断当期节点是否满足bst要求方法三：LeetCode官方题解(推荐)98 验证二叉搜索树 题目中说明了根节点要大于左子树的最大节点，并没有等于，根节点要小于右子树的最小节点值，并没有等于 方法一：判断中序遍历序列是否升序 思路1：验证中序遍历是升序序列 //执行用时：12 ms, 在所有 Go 提交中击败了12.07%的用户 //内存消耗：6.9 MB, 在所有 Go 提交中击败了6.23%的用户 func inorderTraversalRecursion(root *TreeNode) []int { if root == nil { return nil } ret := []int{} //先遍历左子树 if root.Left != nil { ret = append(ret, inorderTraversalRecursion(root.Left)...) } //遍历当前节点 ret = append(ret, root.Val) //再遍历右子树 if root.Right != nil { ret = append(ret, inorderTraversalRecursion(root.Right)...) } return ret } func isValidBST(root *TreeNode) bool { // 空树也是bst if root == nil { return true } ret := inorderTraversalRecursion(root) for i := 0; i ret[i+1] { return false } } return true } 方法二：递归判断当期节点是否满足bst要求 思路：自下往上，因为自上往下有大量的重复计算 如果根节点为空，直接返回true 如果根节点不空，首先判断左右子树是否为bst， 1. 如果不是，直接返回false 2. 如果是，判断根节点大于左子树的最大值和右子树的最小值， 1. 如果不满足，返回false 2. 如果满足，那么更新最大值和最小值，并返回true //执行用时：8 ms, 在所有 Go 提交中击败了77.05%的用户 //内存消耗：5.6 MB, 在所有 Go 提交中击败了29.76%的用户 type RetType struct { isBST bool max, min *TreeNode } func isValidBST(root *TreeNode) bool { if root == nil { return true } return isValidBSTCore(root).isBST } func isValidBSTCore(root *TreeNode) RetType{ //空树也是bst if root == nil { return RetType{isBST: true} } ret := RetType{isBST: true, min: root, max: root} left, right := isValidBSTCore(root.Left), isValidBSTCore(root.Right) //如果左右子树有1个不是平衡二叉树，那么就不是 if !left.isBST || !right.isBST { ret.isBST = false return ret } //如果左子树不空并且根小于等于左子树的最大值，那么返回false if root.Left != nil && root.Val = right.min.Val { ret.isBST = false return ret } //如果左子树不空，则更新当前最小值节点 if root.Left != nil { ret.min = left.min } if root.Right != nil { ret.max = right.max } return ret } 方法三：LeetCode官方题解(推荐) 参考 相比方法一二更加简短和技巧化 func isValidBST(root *TreeNode) bool { return helper(root, math.MinInt64, math.MaxInt64) } func helper(root *TreeNode, min int, max int) bool { if root == nil { return true } //此时root应该位于min, max之间 if root.Val >= max || root.Val 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/100相同的树/code.html":{"url":"LeetCode/100相同的树/code.html","title":"100.相同的树","keywords":"","body":"100 相同的树方法一：从上到下递归方法二：从下到上递归100 相同的树 方法一：从上到下递归 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.1 MB, 在所有 Go 提交中击败了84.70%的用户 思路： 如果当前两个树的节点都不存在，则返回true 如果当前两个树的节点有一个存在，则返回false 如果当前两个树的节点都存在且值相等，则再判断左右子树是否相等 func isSameTree(p *TreeNode, q *TreeNode) bool { //如果两个都为Nil if p == nil && q == nil { return true } //如果有一个为Nil返回false, //同时如果两个都不为空且值不等也返回nil if p == nil || q == nil || p.Val != q.Val { return false } //if p.Val != q.Val { // return false //} //最后比较左右子树 return isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right) } 方法二：从下到上递归 思路：需要判断从上到下递归的前提条件前提条件是对应的左子树或右子树都有或者两个都为空。如果满足前提条件，那么如果左右子树相同并且该节点值相同就返回true。否则返回false 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.1 MB, 在所有 Go 提交中击败了84.70%的用户 //思路：如果左右子树相同并且该节点值相同就返回true， //执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 //内存消耗：2.1 MB, 在所有 Go 提交中击败了84.70%的用户 func isSameTree(p *TreeNode, q *TreeNode) bool { //如果两个都为Nil if p == nil && q == nil { return true } //如果有一个为Nil返回false, //同时如果两个都不为空且值不等也返回nil if p == nil || q == nil{ return false } //如果左右子树相同并且该节点值相同就返回true， if isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right) && p.Val == q.Val { return true } return false } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/101.对称二叉树/code.html":{"url":"LeetCode/101.对称二叉树/code.html","title":"101.对称二叉树","keywords":"","body":"101. 对称二叉树方法一：从上到下递归方法二：从下到上递归方法三：对方法一和方法二代码的优化方法四：广度优先搜索验证是否对称101. 对称二叉树 方法一：从上到下递归 思路：对于给定的root，如果该节点的左右子节点相等，那么继续判断该节点的左子树与右子树是否镜像对称 执行用时：4 ms, 在所有 Go 提交中击败了75.56%的用户 内存消耗：2.9 MB, 在所有 Go 提交中击败了71.38%的用户 func isSymmetric(root *TreeNode) bool { if root == nil { return true } return isSymmetricCore(root.Left, root.Right) } //检查left与right是否镜像对称 func isSymmetricCore(left *TreeNode, right *TreeNode) bool { //如果两个都为空 if left == nil && right == nil { return true } //如果有一个为空 if left == nil || right == nil { return false } //如果两个的值相等，查看子树是否镜像对称 if left.Val == right.Val { return isSymmetricCore(left.Left, right.Right) && isSymmetricCore(left.Right, right.Left) } //两个的值不相等 return false } 方法二：从下到上递归 思路：当左右子树都存在且对称的情况下，需要判断当前节点的左右子节点是否值相等 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.9 MB, 在所有 Go 提交中击败了71.38%的用户 func isSymmetric(root *TreeNode) bool { if root == nil { return true } return isSymmetricCore(root.Left, root.Right) } //检查left与right是否镜像对称 func isSymmetricCore(left *TreeNode, right *TreeNode) bool { //如果两个都为空 if left == nil && right == nil { return true } //如果有一个为空 if left == nil || right == nil { return false } //如果两个的值相等，查看子树是否镜像对称 if isSymmetricCore(left.Left, right.Right) && isSymmetricCore(left.Right, right.Left) { return left.Val == right.Val } //两个子树不对称 return false } 方法三：对方法一和方法二代码的优化 改进：对方法一二进行代码优化，如果左右子树都存在的情况下，只需要判断两个左右子树是否值相等并且是否左右子树自己的左右子树是否镜像对称 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.9 MB, 在所有 Go 提交中击败了24.34%的用户 func isSymmetric(root *TreeNode) bool { if root == nil { return true } return isSymmetricCore(root.Left, root.Right) } //检查left与right是否镜像对称 func isSymmetricCore(left *TreeNode, right *TreeNode) bool { //如果两个都为空 if left == nil && right == nil { return true } //如果有一个为空 if left == nil || right == nil { return false } //如果两个的值相等并且子树是镜像对称，就返回true return isSymmetricCore(left.Left, right.Right) && isSymmetricCore(left.Right, right.Left) && left.Val == right.Val } 方法四：广度优先搜索验证是否对称 思路：bfs验证左右子树是否镜像对称，该思路参考了LeetCode官方解法 执行用时：4 ms, 在所有 Go 提交中击败了75.56%的用户 内存消耗：3 MB, 在所有 Go 提交中击败了9.21%的用户 func isSymmetric(root *TreeNode) bool { if root == nil { return true } queue := []*TreeNode{root, root} for len(queue) != 0 { node1, node2 := queue[0], queue[1] queue = queue[2:] //这个不可以放在for循环最后，因为一定要放在continue之前 //两个都为Nil if node1 == nil && node2 == nil { continue } //有一个为nil if node1 == nil || node2 == nil { return false } //两个的节点值不等 if node1.Val != node2.Val { return false } queue = append(queue, node1.Left, node2.Right) queue = append(queue, node1.Right, node2.Left) } return true } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/103.二叉树的锯齿形层次遍历/code.html":{"url":"LeetCode/103.二叉树的锯齿形层次遍历/code.html","title":"103.二叉树的锯齿形遍历","keywords":"","body":"103. 二叉树的锯齿形层次遍历方法一：剑指offer思路，使用两个栈方法2：对层次遍历中的部分层进行反转103. 二叉树的锯齿形层次遍历 方法一：剑指offer思路，使用两个栈 思路： 假设第1层为根节点，也就是奇数层 我们用奇数栈保存奇数层要打印的节点，偶数栈保存偶数层要打印的节点 如果当前打印的是奇数层的节点，则按照先加入该节点的左子节点到偶数栈，再加入该节点的右子节点到偶数栈 如果当前打印的是偶数层的节点，则按照先加入该节点的右子节点到奇数栈，再加入该节点的左子节点到奇数栈 // 执行用时：0 ms, 在所有 Go 提交中击败了100.00% 的用户 // 内存消耗：2.5 MB, 在所有 Go 提交中击败了 100.0% 的用户 func zigzagLevelOrder(root *TreeNode) [][]int { if root == nil { return nil } flag := true //表明是奇数栈 ret := [][]int{} oddStack, evenStack := []*TreeNode{root}, []*TreeNode{} for len(oddStack) != 0 || len(evenStack) != 0 { currentLevelRet := []int{} if flag { for len(oddStack) != 0 { node := oddStack[len(oddStack)-1] currentLevelRet = append(currentLevelRet, node.Val) if node.Left != nil { evenStack = append(evenStack, node.Left) } if node.Right != nil { evenStack = append(evenStack, node.Right) } oddStack = oddStack[:len(oddStack)-1] } } else { for len(evenStack) != 0 { node := evenStack[len(evenStack)-1] currentLevelRet = append(currentLevelRet, node.Val) if node.Right != nil { oddStack = append(oddStack, node.Right) } if node.Left != nil { oddStack = append(oddStack, node.Left) } evenStack = evenStack[:len(evenStack)-1] } } flag = !flag ret = append(ret, currentLevelRet) } return ret } 方法2：对层次遍历中的部分层进行反转 假设根节点在第0层，我们需要在奇数层遍历完之后将反转的结果加入到最终的结果中 // 执行用时：0 ms, 在所有 Go 提交中击败了100.00% 的用户 // 内存消耗：2.5 MB, 在所有 Go 提交中击败了 55.25% 的用户 func zigzagLevelOrder(root *TreeNode) [][]int { //如果根节点为空 if root == nil { return nil } queue := []*TreeNode{root} ret := [][]int{} level := 1 for len(queue) != 0 { currentLevelRet := []int{} length := len(queue) for i := 0; i 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/105.从前序与中序遍历序列构造二叉树/code.html":{"url":"LeetCode/105.从前序与中序遍历序列构造二叉树/code.html","title":"105.从前序与中序遍历序列构造二叉树","keywords":"","body":"105. 从前序与中序遍历序列构造二叉树方法一：递归的简洁写法方法二：递归105. 从前序与中序遍历序列构造二叉树 方法一：递归的简洁写法 执行用时：4 ms, 在所有 Go 提交中击败了96.59%的用户 内存消耗：4 MB, 在所有 Go 提交中击败了29.47%的用户 func buildTree(preorder []int, inorder []int) *TreeNode { if len(preorder) == 0 || len(inorder) == 0 { return nil } //根节点的值 rv := preorder[0] //左子树的长度 left := 0 for i := 0; i 方法二：递归 执行用时：8 ms, 在所有 Go 提交中击败了56.43%的用户 内存消耗：4 MB, 在所有 Go 提交中击败了17.37%的用户 思路：上面的方法每次都会对传入的数组进行切片，而这里我们传递区间的起始值来锁定中序序列以及先序序列所在的区间 此时左子树长度为：left-startInorder 右子树长度为：endInorder-left 此时left会指向根 此时我们遍历左子树的 先序从startPreorder+1->startPreorder+左子树长度(left-startInorder) 中序从startInorder->left-1 此时我们遍历右子树的 先序从startPreorder+左子树长度(left-startInorder)+1->endPreorder 中序从left+1->endInorder 改进：不对传入的先序与中序序列进行切分 关键点：正确计算左右子树的区间起始值 func buildTree(preorder []int, inorder []int) *TreeNode { if len(preorder) == 0 || len(inorder) == 0 || len(preorder) != len(inorder) { return nil } return buildTreeCore(preorder, inorder, 0, len(preorder)-1, 0, len(inorder)-1) } func buildTreeCore(preorder []int, inorder []int, startPreorder, endPreorder, startInorder, endInorder int) *TreeNode { if startPreorder > endPreorder || startInorder > endInorder { return nil } //找到根节点的值 rootVal := preorder[startPreorder] //找到左子树的长度 left := startInorder for ; left startInorder { //说明有左子树 root.Left = buildTreeCore(preorder, inorder, startPreorder+1, startPreorder+left-startInorder, startInorder, left-1) } //建立右子树 if endInorder-left > 0 { //说明有右子树 root.Right = buildTreeCore(preorder, inorder, startPreorder+left-startInorder+1, endPreorder, left+1, endInorder) } return root } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/106.从中序与后序遍历序列构造二叉树/code.html":{"url":"LeetCode/106.从中序与后序遍历序列构造二叉树/code.html","title":"106.从中序与后序遍历序列构造二叉树","keywords":"","body":"106. 从中序与后序遍历序列构造二叉树方法一：递归方法二：参考LeetCode其他解法106. 从中序与后序遍历序列构造二叉树 方法一：递归 思路：直接找到根，划分为左右子树，递归建立左右子树即可。不需要将原来的中序与后序的数组修改， 执行用时：8 ms, 在所有 Go 提交中击败了56.82%的用户 内存消耗：4 MB, 在所有 Go 提交中击败了15.69%的用户 func buildTree(inorder []int, postorder []int) *TreeNode { //说明节点非法，不需要构造二叉树 if len(inorder) == 0 || len(postorder) == 0 || len(postorder) != len(inorder) { return nil } return buildTreeCore(inorder, postorder, 0, len(inorder)-1, 0, len(postorder)-1) } func buildTreeCore(inorder []int, postorder []int, startInorder, endInorder, startPostorder, endPostorder int) *TreeNode { if startInorder > endInorder || startPostorder > endPostorder { return nil } //找到根节点 root := &TreeNode{Val: postorder[endPostorder]} //左子树的长度 leftLength := 0 for i := startInorder; i 0 { root.Left = buildTreeCore(inorder, postorder, startInorder, startInorder+leftLength-1, startPostorder, startPostorder+leftLength-1) } //如果有右子树 if rightLength > 0 { root.Right = buildTreeCore(inorder, postorder, startInorder+leftLength+1, endInorder, startPostorder+leftLength, endPostorder-1) } return root } 方法二：参考LeetCode其他解法 思路：直接找到根，划分为左右子树，递归建立左右子树即可 参考 执行用时：4 ms, 在所有 Go 提交中击败了96.59%的用户 内存消耗：4 MB, 在所有 Go 提交中击败了29.41%的用户 func buildTree(inorder []int, postorder []int) *TreeNode { if len(inorder) == 0 || len(postorder) == 0 { return nil } //根节点的值 rv := postorder[len(postorder)-1] //用来记录左子树长度 left := 0 //找到左子树 for i := 0; i 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/107.二叉树的层次遍历II/code.html":{"url":"LeetCode/107.二叉树的层次遍历II/code.html","title":"107.二叉树的层次遍历II","keywords":"","body":"107. 二叉树的层次遍历 II方法一：bfs+反转方法二：bfs+每次加入当前层元素的时候先加入再加入之前的层的结果方法三：DFS+反转107. 二叉树的层次遍历 II 关键点： 如何实现层次遍历：BFS或DFS 层次遍历之后如何进行反转，两个方法， 第1个方法是遍历完之后进行反转， 第2个方法就是每次遍历当前层的时候先将当前层先加入到ret中，再将ret之前的层次再加入进来 方法一：bfs+反转 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.8 ms, 在所有 Go 提交中击败了58.80%的用户 func levelOrder(root *TreeNode) [][]int { queue := []*TreeNode{root} ret := [][]int{} for len(queue) != 0 { length := len(queue) currentLevelRet := []int{} for length > 0 { node := queue[0] queue = queue[1:] length -= 1 if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } currentLevelRet = append(currentLevelRet, node.Val) } ret = append(ret, currentLevelRet) } return ret } func reverse(ret [][]int) [][]int { for i := 0; i > 1; i++ { ret[i], ret[len(ret)-i-1] = ret[len(ret)-1-i], ret[i] } return ret } 方法二：bfs+每次加入当前层元素的时候先加入再加入之前的层的结果 如何实现反转：每次加入当前层元素的时候先将之前加入的剔除掉，然后加入当前层，再加入剔除掉的之前层的结果 func levelOrderBottom(root *TreeNode) [][]int { var res [][]int if root==nil{ return res } queue := []*TreeNode{root} for len(queue)>0{ l :=len(queue) list := make([]int,0) for i:=0;i 方法三：DFS+反转 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：3.1 ms, 在所有 Go 提交中击败了39.33%的用户 func levelOrderBottom(root *TreeNode) [][]int { if root == nil { return nil } ret := [][]int{} dfs(root, 1, &ret) reverse(&ret) return ret } func reverse(ret *[][]int) { for i := 0; i > 1; i++ { (*ret)[i], (*ret)[len(*ret)-i-1] = (*ret)[len(*ret)-1-i], (*ret)[i] } } func dfs(root *TreeNode, level int, ret *[][]int) { if len(*ret) 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/108.将有序数组转换为二叉搜索树/code.html":{"url":"LeetCode/108.将有序数组转换为二叉搜索树/code.html","title":"108.将有序数组转换为二叉搜索树","keywords":"","body":"108. 将有序数组转换为二叉搜索树方法一：递归108. 将有序数组转换为二叉搜索树 方法一：递归 思路：每次找到中间节点之后，将其一分为二，之后递归建立左右子树 执行用时：4 ms, 在所有 Go 提交中击败了85.06%的用户 内存消耗：4.4 ms, 在所有 Go 提交中击败了100.00%的用户 func sortedArrayToBST(nums []int) *TreeNode { if len(nums) > 1 root := &TreeNode{ Val: nums[mid], } if mid > 0 { //说明有左子树 root.Left = sortedArrayToBST(nums[:mid]) } if mid 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/111.二叉树的最小深度/code.html":{"url":"LeetCode/111.二叉树的最小深度/code.html","title":"111.二叉树的最小深度","keywords":"","body":"111 二叉树的最小深度方法一：递归方法一修正：修改方法一111 二叉树的最小深度 方法一：递归 思路：从上到下递归 提交后报错：输入[1, 2]，我们输出1，预期输出2 func minDepth(root *TreeNode) int { if root == nil { return 0 } //返回左右子树最小的深度值+1 return min(minDepth(root.Left), minDepth(root.Right)) + 1 } func min(num1, num2 int) int{ if num1 方法一修正：修改方法一 注意：如果某个节点只有左叶子节点，那么该节点的深度为2而不是1。 因为要的是从根节点到叶子节点的最小深度 因此我们要加上前面两个判断左右子树的条件 执行用时：8 ms, 在所有 Go 提交中击败了74.02%的用户 内存消耗：5.3 ms, 在所有 Go 提交中击败了35.42%的用户 func minDepth(root *TreeNode) int { if root == nil { return 0 } if root.Left == nil { return minDepth(root.Right) + 1 } if root.Right == nil { return minDepth(root.Left) + 1 } //返回左右子树最小的深度值+1 //这里不能直接这样写，因为如果某个节点只有左叶子节点，那么该节点的深度为2而不是1 //因为要的是从根节点到叶子节点的最小深度 //因此我们要加上前面两个判断左右子树的条件 return min(minDepth(root.Left), minDepth(root.Right)) + 1 } func min(num1, num2 int) int{ if num1 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/113.路径总和II/code.html":{"url":"LeetCode/113.路径总和II/code.html","title":"113.路径总和II","keywords":"","body":"113. 路径总和 II方法：DFS+前序遍历113. 路径总和 II 方法：DFS+前序遍历 执行用时：4 ms, 在所有 Go 提交中击败了94.63%的用户 内存消耗：4.6 MB, 在所有 Go 提交中击败了38.30%的用户 func pathSum(root *TreeNode, sum int) [][]int { if root == nil { return nil } ret := [][]int{} path := []int{} dfs(root, &ret, &path, sum) return ret } func dfs(root *TreeNode, ret *[][]int, path *[]int, sum int) { *path = append(*path, root.Val) //加入的条件，到了叶子节点并且叶子节点的值等于sum if sum == root.Val && root.Left == nil && root.Right == nil { temp := make([]int, len(*path)) copy(temp, *path) *ret = append(*ret, temp) return } if root.Left != nil { dfs(root.Left, ret, path, sum-root.Val) *path = (*path)[:len(*path)-1] } if root.Right != nil { dfs(root.Right, ret, path, sum-root.Val) *path = (*path)[:len(*path)-1] } } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/116.填充每个节点的下一个右侧节点指针/code.html":{"url":"LeetCode/116.填充每个节点的下一个右侧节点指针/code.html","title":"116.填充每个节点的下一个右侧节点指针","keywords":"","body":"116 填充每个节点的下一个右侧节点指针方法一：BFS遍历进行修改116 填充每个节点的下一个右侧节点指针 方法一：BFS遍历进行修改 思路： 每次左子树不空就设置左子树的Next为右子树 每次右子树不空就设置右子树的Next为nil 注意：题目中要求只能使用常数级别的空间复杂度 执行用时：4 ms, 在所有 Go 提交中击败了94.43%的用户 内存消耗：6.2 MB, 在所有 Go 提交中击败了16.30%的用户 func connect(root *Node) *Node { if root == nil { return nil } ////设置root的Next指向 //root.Next = nil queue := []*Node{root} for len(queue) != 0 { length := len(queue) for i := 0; i 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/118.杨辉三角/code.html":{"url":"LeetCode/118.杨辉三角/code.html","title":"118.杨辉三角","keywords":"","body":"118. 杨辉三角方法：找规律后直接循环118. 杨辉三角 方法：找规律后直接循环 规律：某一行的行号等于这一行的元素个数 思路： 首先每行开始之前加入1个1 如果当前行的元素个数大于2个说明中间有元素，开始加入，假设当前在第i行第j列(都从1开始)，那么nums[i-1][j] = nums[i-2][j-1]+nums[i-2][j] 如果当前行数大于等于2说明要加上最后1个1 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.1 MB, 在所有 Go 提交中击败了22.81%的用户 func generate(numRows int) [][]int { ret := [][]int{} for i := 1; i = 2 { rowRet = append(rowRet, 1) } ret = append(ret, rowRet) } return ret } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/119.杨辉三角II/code.html":{"url":"LeetCode/119.杨辉三角II/code.html","title":"119.杨辉三角II","keywords":"","body":"119. 杨辉三角 II方法：找规律并进行压缩方法二：参考LeetCode他人代码进行改进119. 杨辉三角 II 方法：找规律并进行压缩 思路：同118，无非不过进行状态压缩 注意更新每行的时候是从右往左更新，否则会出错，因为我们有一个公式nums[i] = nums[i-1]+nums[i]，所以如果nums[i-1]更新，导致当前行用的是上一行的nums[i-1]所以会出错。因此我们一定要记得从右往左更新 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.1 MB, 在所有 Go 提交中击败了26.82%的用户 下面的代码较容易理解 func getRow(rowIndex int) []int { //如果传入的参数非法 if rowIndex = 1; j-- { nums[j] = nums[j-1] + nums[j] } //如果元素个数大于1，一定要记得最后一个元素加上1 if i >= 1 { nums[i] = 1 } } return nums } 方法二：参考LeetCode他人代码进行改进 LeetCode的双百代码Golang func getRow(rowIndex int) []int { // 第0行 nums := []int{1} for i := 1; i 0;j--{ nums[j]+=nums[j-1] } } return nums } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/120.三角形最小路径和/code.html":{"url":"LeetCode/120.三角形最小路径和/code.html","title":"120.三角形最小路径和","keywords":"","body":"120. 三角形最小路径和方法一：直接dp方法二【推荐】：状态压缩的dp120. 三角形最小路径和 方法一：直接dp 思路：覆盖传入的triangle basecase：dp[0][0]=grid[0][0], `dp[0][i]=dp[0][i-1]+grid[0][i],` `dp[i][0]=dp[i-1][0]` 状态定义：dp[i][j]表示从左上角到该点的最小路径和 选择：每次可以向右或向下 状态转移方程：dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] 执行用时：12 ms, 在所有 Go 提交中击败了17.20%的用户 内存消耗：5 MB, 在所有 Go 提交中击败了5.36%的用户 func minimumTotal(triangle [][]int) int { if len(triangle) == 0 || len(triangle[0]) == 0 { return 0 } //更新第1列 for i := 1; i triangle[len(triangle)-1][i] { mi = triangle[len(triangle)-1][i] } } return mi } 方法二【推荐】：状态压缩的dp 空间复杂度：O(N) 思路：从下到上进行动态规划， basecase：dp数组初始化为triangle的最后一行 状态定义：dp[j]表示从最后一行到达当前位置的最小路径和 选择：每次可以向上或左上 状态转移方程：dp[j] = min(dp[j], dp[j+1]) j从0->i，而i代表行号，从倒数第2行到第1行 执行用时：4 ms, 在所有 Go 提交中击败了94.80%的用户 内存消耗：3.1 MB, 在所有 Go 提交中击败了83.71%的用户 最终我们想要的结果存放在dp[0] func minimumTotal(triangle [][]int) int { if len(triangle) == 0 || len(triangle[0]) == 0 { return 0 } //初始化为最后一行 dp := triangle[len(triangle)-1] for i := len(triangle)-2; i >= 0; i-- { for j := 0; j 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/121.买卖股票的最佳时机/code.html":{"url":"LeetCode/121.买卖股票的最佳时机/code.html","title":"121.买卖股票的最佳时机","keywords":"","body":"121. 买卖股票的最佳时机方法一：dp方法二：参照LeetCode上的另外一种解法121. 买卖股票的最佳时机 方法一：dp 按照如下模板来做题：（如果实在做不到就直接暴力穷举然后优化） 明确basecase dp[0] = 0 状态定义：dp[i]表示前i天获取的最大利润 选择：当天是卖或者不卖 状态转移方程：dp[i] = max(dp[i-1], 第i天卖掉可以获得的利润) 执行用时：4 ms, 在所有 Go 提交中击败了96.81%的用户 内存消耗：3.3 MB, 在所有 Go 提交中击败了13.93%的用户 func maxProfit(prices []int) int { if len(prices) prices[i] { minPrice = prices[i] } dp[i] = max(dp[i-1], prices[i]-minPrice) } return dp[len(prices)-1] } func max(num1, num2 int) int { if num1 > num2 { return num1 } return num2 } 方法二：参照LeetCode上的另外一种解法 改进：只使用一个变量来记录最小价格，同时使用一个变量来保存最大利润。其实如果把价格用曲线图画出来之后，我们要找到如下的两个点 曲线图中的最小点 曲线图中的最大点 满足最大点位于最小点的后方，这样利润可以为正 执行用时：4 ms, 在所有 Go 提交中击败了96.81%的用户 内存消耗：3.3 MB, 在所有 Go 提交中击败了100.00%的用户 func maxProfit(prices []int) int { if len(prices) prices[i] { minPrice = prices[i] } if maxProfit 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/125.验证回文串/code.html":{"url":"LeetCode/125.验证回文串/code.html","title":"125.验证回文串","keywords":"","body":"125. 验证回文串方法一：对撞指针125. 验证回文串 方法一：对撞指针 思路：采用对撞指针每次判断两边的字母数字字符，如果相等进入到下一个字母数字字符，否则返回false 步骤： 将所有字母小写 之后left,right分别从左右两边开始移动，直到left = right就停止 l和r指向的如果不同，就返回false。否则l和r移动到右边和左边的位置， 继续如上循环 执行用时：4 ms, 在所有 Go 提交中击败了96.81%的用户 内存消耗：2.8 MB, 在所有 Go 提交中击败了13.93%的用户 func isPalindrome(s string) bool { //空字符串定义为有效的回文串。 if len(s) = 97 && num = 48 && num 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/129.求根到叶子节点数字之和/code.html":{"url":"LeetCode/129.求根到叶子节点数字之和/code.html","title":"129.求根到叶子节点数字之和","keywords":"","body":"129. 求根到叶子节点数字之和方法：DFS+前序遍历129. 求根到叶子节点数字之和 方法：DFS+前序遍历 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.5 MB, 在所有 Go 提交中击败了18.80%的用户 func sumNumbers(root *TreeNode) int { //之前提交的错误点：注意输入为nil if root == nil { return 0 } sum := 0 dfs(root, &sum, 0) return sum } //第2个值存储所有到叶子路径的和，也就是最终结果 //第3个值代表当前的值 func dfs(root *TreeNode, sum *int, currentVal int) { currentVal = currentVal * 10 + root.Val //回溯结束条件：如果当前节点为叶子节点 if root.Left == nil && root.Right == nil { *sum += currentVal fmt.Println(currentVal) } //如果当前节点的左子树不空 if root.Left != nil { dfs(root.Left, sum, currentVal) } //如果当前节点的右子树不空 if root.Right != nil { dfs(root.Right, sum, currentVal) } } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/141环形链表/code.html":{"url":"LeetCode/141环形链表/code.html","title":"141.环形链表","keywords":"","body":"141. 环形链表方法一：使用hashset方法二：快慢指针141. 环形链表 方法一：使用hashset 思路：使用hashset存储走过的节点，如果下次走到的节点在hashset中说明有环 方法二：快慢指针 思路：快指针一次走两步，慢指针一次只走一步 执行用时：4 ms, 在所有 Go 提交中击败了98.94%的用户 内存消耗：3.8 MB, 在所有 Go 提交中击败了100.00%的用户 func hasCycle(head *ListNode) bool { //if判断可以省略，因为下面的for第一步就会判断 // if head == nil { // return false // } fast, slow := head, head for fast != nil && fast.Next != nil { fast, slow = fast.Next.Next, slow.Next //这个if一定要放到下面，如果放在上面，刚开始fast和slow都为head，会报错 if fast == slow { return true } } return false } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/142.环形链表II/code.html":{"url":"LeetCode/142.环形链表II/code.html","title":"142.环形链表II","keywords":"","body":"142. 环形链表 II142. 环形链表 II 思路：首先确定是否有环，如果有环，当相遇时，让fast指向链表头，slow不动，之后fast每次与slow一致都走一步，下次相遇就是在环的入口位置处 数学证明：假设链表有环，且环的入口到链表的起点有d个节点，从环的入口到第一次相遇的那个位置有m个节点，从第一次相遇的位置再走回到换的入口处有n个节点， 第一次相遇时：慢指针走了：d + k (m+n) + m，因为快指针走两步，慢指针走一步，所以快指针走的路程是慢指针的2倍，那么快指针走了2 d + 2 k (m + n) + m，相减得到d + m + k * (m + n)，其实此时快指针比慢指针多走了几圈环，所以d + m 其实也是一个环长度，也就是相当于得到d = n，从而我们可以让快指针此时指向链表头，此时让快慢每次都走一步，那么下次相遇一定在环的入口处 执行用时：4 ms, 在所有 Go 提交中击败了98.94%的用户 内存消耗：3.8 MB, 在所有 Go 提交中击败了100.00%的用户 func detectCycle(head *ListNode) *ListNode { //没有环，可以不用写，因为后面会执行 //if head == nil { // return nil //} fast, slow := head, head for fast != nil && fast.Next != nil { fast, slow = fast.Next.Next, slow.Next if fast == slow { //找到了相遇点 fast = head break } } //说明没有环 if fast == nil || fast.Next == nil { return nil } //再次制造机会让他们相碰撞，此时会在环的入口节点处碰撞 for slow != fast { slow, fast = slow.Next, fast.Next } return slow } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/146.LRU缓存机制/code.html":{"url":"LeetCode/146.LRU缓存机制/code.html","title":"146.LRU缓存机制","keywords":"","body":"146. LRU缓存机制方法：采用map+双链表146. LRU缓存机制 方法：采用map+双链表 为什么要采用map：因为get的时候就是查找，我们要O(1)时间复杂度 为什么采用双链表：因为我们将当前节点提升为最近使用时，要修改当前节点的上一个节点的next指向，所以我们需要采用双链表。 同时注意：我们在map中采用key-val存储，我们在链表中的节点也要存储key-val，因为我们删除节点的时候，查找到了当前节点，如果只存val，我们需要没办法用O(1)的时间找到key，从而就不能在map中用O(1)的操作删除 思路： get操作： 如果节点存在，将节点提升为最近使用(首先删除当前节点，之后将当前节点移动到head的下一个节点)并返回节点的值 如果不存在直接返回-1 put操作： 首先查看map中是否存在该节点 如果存在 就修改该节点的值 删除该节点 将该节点提升为最近使用(放置到head的下面) 如果不存在 新建一个节点，插入到head后面 同时判断map容量是否满了，如果满了就要从链表尾部删除最近不经常使用的，之后记得删除map中的键值对哦，这里需要借助节点存储的key删除，所以我们节点要存储key信息 执行用时：116 ms, 在所有 Go 提交中击败了99.90%的用户 内存消耗：12.6 ms, 在所有 Go 提交中击败了94.19%的用户 /** * @Author: yirufeng * @Email: yirufeng@foxmail.com * @Date: 2020/9/5 8:50 下午 * @Desc: 146.LRU缓存机制 */ //定义双链表的节点 type DoubleLinkedListNode struct { Key, Val int //定义Key也就是map的key，到时候根据链表中的节点的key就可以删除map对应的key，不然比较难删除 Prev, Next *DoubleLinkedListNode } type LRUCache struct { dict map[int]*DoubleLinkedListNode //键值对，键为，值指向双链表的一个节点 head, tail *DoubleLinkedListNode //双链表 capacity int } func Constructor(capacity int) LRUCache { tempHead := &DoubleLinkedListNode{ } tempTail := &DoubleLinkedListNode{ //下面注释的这两个指针其实用不上 //Prev: tempHead, //Next: tempHead, } tempHead.Next, tempTail.Prev = tempTail, tempHead return LRUCache{ dict: make(map[int]*DoubleLinkedListNode), head: tempHead, tail: tempTail, capacity: capacity, } } //从删除当前节点 func (this *LRUCache) removeNode(cur *DoubleLinkedListNode) { cur.Prev.Next, cur.Next.Prev = cur.Next, cur.Prev } //将当前节点添加到head后面 func (this *LRUCache) addToHead(cur *DoubleLinkedListNode) { this.head.Next, this.head.Next.Prev, cur.Next, cur.Prev = cur, cur, this.head.Next, this.head } //将当前节点移动到头部 //1. 删除当前节点 //2. 添加到头部 func (this *LRUCache) moveToHead(cur *DoubleLinkedListNode) { this.removeNode(cur) this.addToHead(cur) } //从尾部删除节点 func (this *LRUCache) removeTail() *DoubleLinkedListNode { cur := this.tail.Prev this.removeNode(cur) return cur } func (this *LRUCache) Get(key int) int { if cur, ok := this.dict[key]; ok { //说明之前就存在， //1. 删除当前节点 //2. 提升为最近使用，也就是插入到头部 this.moveToHead(cur) return cur.Val } //说明不存在 return -1 } func (this *LRUCache) Put(key int, value int) { if cur, ok := this.dict[key]; ok { //不为-1，修改对应的值即可， 并且提升为最近使用 //1. 从修改对应的值 cur.Val = value //2. 提升为最近使用 this.moveToHead(cur) //fmt.Println(\"修改对应的值并提升为最近使用---->\", key, \"-\", value) } else { //如果不存在，插入并且提升为最近使用 cur = &DoubleLinkedListNode{ Val: value, Key: key, } this.addToHead(cur) this.dict[key] = cur //如果容量满 if len(this.dict) > this.capacity { //1.删除尾部节点 node := this.removeTail() //2.同时记得从map里面删除哦 delete(this.dict, node.Key) } //fmt.Println(\"插入到head后面-------->\", key, \"-\", value) } //fmt.Println(\"map元素个数：\", len(this.dict)) } /** * Your LRUCache object will be instantiated and called as such: * obj := Constructor(capacity); * param_1 := obj.Get(key); * obj.Put(key,value); */ 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/155.最小栈/code.html":{"url":"LeetCode/155.最小栈/code.html","title":"155.最小栈","keywords":"","body":"155. 最小栈方法一：方法二：155. 最小栈 方法一： 思路： 使用两个栈来保存，一个为数据栈用来保存数据，另一个为最小值栈用来保存最小值 当加入元素的时候，数据栈直接加入，但是如果元素小于等于最小栈的栈顶则加入到最小栈中 当弹出元素的时候，数据栈直接弹出，但是如果弹出的元素等于最小栈的栈顶则从最小栈中弹出 执行用时：36 ms, 在所有 Go 提交中击败了97.98%的用户 内存消耗：6.3 MB, 在所有 Go 提交中击败了60.28%的用户 type MinStack struct { dataStack []int minStack []int } /** initialize your data structure here. */ func Constructor() MinStack { return MinStack{ dataStack: []int{}, minStack: []int{}, } } func (this *MinStack) Push(x int) { this.dataStack = append(this.dataStack, x) //这里得特别注意最小值栈为空的情况 if len(this.minStack) == 0 { this.minStack = append(this.minStack, x) return } //如果加入的元素小于等于最小栈栈顶，则加入 if x 方法二： 思路： 使用两个栈来保存，一个为数据栈用来保存数据，另一个为最小值栈用来保存最小值 当加入元素的时候，数据栈直接加入，但是如果元素大于最小栈的栈顶则重复加入最小栈栈顶到最小栈中 当弹出元素的时候，数据栈与最小栈直接弹出 执行用时：20 ms, 在所有 Go 提交中击败了74.85%的用户 内存消耗：7.8 MB, 在所有 Go 提交中击败了26.47%的用户 type MinStack struct { dataStack []int minStack []int } /** initialize your data structure here. */ func Constructor() MinStack { return MinStack{ dataStack: []int{}, minStack: []int{}, } } func (this *MinStack) Push(x int) { this.dataStack = append(this.dataStack, x) //这里得特别注意最小值栈为空的情况 if len(this.minStack) == 0 { this.minStack = append(this.minStack, x) return } //如果加入的元素大于最小栈栈顶，则重复加入最小栈栈顶,否则加入x if x > this.minStack[len(this.minStack)-1] { this.minStack = append(this.minStack, this.minStack[len(this.minStack)-1]) } else { this.minStack = append(this.minStack, x) } } func (this *MinStack) Pop() { if len(this.dataStack) == 0 { return } this.dataStack = this.dataStack[:len(this.dataStack) - 1] this.minStack = this.minStack[:len(this.minStack) - 1] } func (this *MinStack) Top() int { return this.dataStack[len(this.dataStack) - 1] } func (this *MinStack) GetMin() int { return this.minStack[len(this.minStack) - 1] } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/160.相交链表/code.html":{"url":"LeetCode/160.相交链表/code.html","title":"160.相交链表","keywords":"","body":"160. 相交链表方法：160. 相交链表 方法： 关键：如何弥补长度差，我们可以让两个指针遍历完自己所在的链表之后再遍历另一个链表 执行用时：40 ms, 在所有 Go 提交中击败了97.34%的用户 内存消耗：7.4 MB, 在所有 Go 提交中击败了81.51%的用户 使用双指针，让两个指针同时走自己的链表，走完自己的链表之后走另外一个链表，这样就可以弥补长度差。 最后的退出条件说明：如果两个链表指向了同一个节点，说明该节点就是相交的起始节点，也有可能两个链表都走到最后(如果两个链表有长度差，那么弥补完长度差之后如果不相交也都会指向nil)且都为空，此时也会退出循环 func getIntersectionNode(headA, headB *ListNode) *ListNode { //如果有一个为空，直接返回nil if headA == nil || headB == nil { return nil } tempHeadA, tempHeadB := headA, headB for tempHeadA != tempHeadB { if tempHeadA == nil { tempHeadA = headB } else { tempHeadA = tempHeadA.Next } if tempHeadB == nil { tempHeadB = headA } else { tempHeadB = tempHeadB.Next } } //走到这里说明两个节点相等或者相交， //如果相等则说明走到了最后也就是nil，因此只要返回其中一个就可以 //如果两个节点走的时候相交也会退出循环，因此只要返回其中一个就可以 return tempHeadB } 之前自己写的错误代码: /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func getIntersectionNode(headA, headB *ListNode) *ListNode { //如果有一个为空，直接返回nil if headA == nil || headB == nil { return nil } tempHeadA, tempHeadB := headA, headB count := 0 for tempHeadA != tempHeadB { if tempHeadA == nil { tempHeadA = headB count += 1 } if tempHeadB == nil { tempHeadB = headA count += 1 } tempHeadA, tempHeadB = tempHeadA.Next, tempHeadB.Next if count >= 3 { //说明没找到 break } } //说明最后只走了2次就找到了节点 //count如果为0，说明两个等长且找到了相交的节点 if count == 2 || count == 0 { return tempHeadA } return nil } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/169.多数元素/code.html":{"url":"LeetCode/169.多数元素/code.html","title":"169.多数元素","keywords":"","body":"169. 多数元素方法一：暴力美学进行统计方法二：参考LeetCode-CookBook对方法一改进方法三：使用额外空间的摩尔投票法【推荐】方法四：进阶-不使用额外空间的摩尔投票法总结：169. 多数元素 方法一：暴力美学进行统计 思路：使用map统计次数，之后每次统计的时候计算是否超过了一半数组长度， 时间复杂度：O(N) 空间复杂度：O(N) func majorityElement(nums []int) int { //如果只有1个元素 if len(nums) == 1 { return nums[0] } mymap := make(map[int]int) for _, num := range nums { if _, ok := mymap[num]; ok { mymap[num] += 1 if float64(mymap[num])/float64(len(nums)) >= 0.5 { return num } } else { mymap[num] = 1 } } //说明啥都没有,到时候自己问面试官返回啥 return 0 } 方法二：参考LeetCode-CookBook对方法一改进 时间复杂度：O(N) 空间复杂度：O(N) 执行用时：24 ms, 在所有 Go 提交中击败了65.56%的用户 内存消耗：6.2 MB, 在所有 Go 提交中击败了5.48%的用户 func majorityElement(nums []int) int { mymap := make(map[int]int) for _, num := range nums { mymap[num] += 1 //注意这里是大于没有等于，因为len(nums)/2就会向下取整，题目中说出现次数大于 ⌊ n/2 ⌋ 的元素 if mymap[num] > len(nums)/2 { return num } } return 0 } 方法三：使用额外空间的摩尔投票法 执行用时：20 ms, 在所有 Go 提交中击败了92.69%的用户 内存消耗：6.6 MB, 在所有 Go 提交中击败了5.48%的用户 时间复杂度：O(N) 空间复杂度：O(N) func majorityElement(nums []int) int { if len(nums) == 1 { return nums[0] } ret := []int{} for _, num := range nums { if len(ret) > 0 && num == ret[0] { ret = append(ret, num) } else if len(ret) > 0 && num != ret[0] { ret = ret[1:] } else { ret = append(ret, num) } } return ret[0] } 【推荐】方法四：进阶-不使用额外空间的摩尔投票法 思路： 从上面的方法二中其实观察出，我们不断地抵消数字，当次数为0就加入一个新数，所以只要一个数即可， 但是我们需要保存次数，判断下次抵消后的次数或者新加入后的次数或者重置，我们的ret只需要保存一个数即可 执行用时：20 ms, 在所有 Go 提交中击败了92.69%的用户 内存消耗：6.6 MB, 在所有 Go 提交中击败了5.48%的用户 时间复杂度：O(N) 空间复杂度：O(1) func majorityElement(nums []int) int { //ret存储元素下标，count存储次数 ret, count := 0, 1 for i := 1; i 0 && nums[ret] != nums[i] { //出现次数很多，但是这次我们不同于之前的数字，要抵消 count -= 1 } else if count > 0 && nums[ret] == nums[i] { //出现次数很多，这次又出现 count += 1 } else if count == 0 { //如果之前全部都抵消完 count = 1 ret = i } fmt.Println(i, nums[i]) } return nums[ret] } 总结： 关于摩尔投票法的理解：人数对打，如果1个人可以kill掉1个人，那么就是对打，最终的结果肯定是人数多的获胜，对拼消耗就是摩尔投票法的核心。 摩尔投票法的理解 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/171.表列序号/code.html":{"url":"LeetCode/171.表列序号/code.html","title":"171.表序列号","keywords":"","body":"版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/190.颠倒二进制位/code.html":{"url":"LeetCode/190.颠倒二进制位/code.html","title":"190.颠倒二进制位","keywords":"","body":"190. 颠倒二进制位方法：190. 颠倒二进制位 方法： 思路：不断让num右移，同时每次获取num的最后一位 执行用时：4 ms, 在所有 Go 提交中击败了61.69%的用户 内存消耗：2.6 MB, 在所有 Go 提交中击败了5.21%的用户 func reverseBits(num uint32) uint32 { var ret uint32 for i := 0; i >= 1 } return ret } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/198.打家劫舍/code.html":{"url":"LeetCode/198.打家劫舍/code.html","title":"198.打家劫舍","keywords":"","body":"198. 打家劫舍方法一：自己的dp方法二：LeetCode上的dp方法三：参考小浩算法198. 打家劫舍 方法一：自己的dp 步骤： 明确base case：dp[0][0]=0, dp[0][1]=nums[0] 状态：dp[i][0]， 其中第2维取值0，1分别表示不偷，偷。 其中第1维表示偷到第i个房屋时可以获取的最大偷窃金额 选择：偷 或 不偷 状态转移方程： dp[i][0] = max(dp[i-1][0], dp[i-1][1]) dp[i][1] = dp[i-1][0] + nums[i] 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.1 MB, 在所有 Go 提交中击败了5.44%的用户 func rob(nums []int) int { if len(nums) num2 { return num } return num2 } 方法二：LeetCode上的dp 步骤： 明确base case：dp[0]=nums[0], 状态：dp[i]表示前 i 间房屋能偷窃到的最高总金额 选择：偷 或 不偷 状态转移方程： dp[i] = max(dp[i-1], dp[i-2]+nums[i]) 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2 MB, 在所有 Go 提交中击败了57.77%的用户 func rob(nums []int) int { if len(nums) num2 { return num } return num2 } 方法三：参考小浩算法 dp[i]表示偷盗至第i个房屋时，已经累计获取的最大偷窃金额 后来自己也参考思路改进了 func rob(nums []int) int { if len(nums) num2 { return num } return num2 } 自己上次提交的错误代码： 错误原因：之前自己提交的这一行代码给nums[1]赋值只会在数组长度为2的时候进行赋值 func rob(nums []int) int { if len(nums) 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/201.数字范围按位与/code.html":{"url":"LeetCode/201.数字范围按位与/code.html","title":"201.数字范围按位与","keywords":"","body":"201. 数字范围按位与方法一：自己的解法方法二：位移【推荐】方法三：Brian Kernighan 算法201. 数字范围按位与 这道题的本质就是求解m和n的最长公共前缀 方法一：自己的解法 自己的思路： 求取m和n二进制中最前面的公共位即可，直到某一位不同，就不再继续求了 步骤： 1. 获取最大数n的最高位的1所在的那一位，我们这里用mask表示 2. 之后不断用mask判断m和n是否相同，并累加，如果不等就退出 时间复杂度：O(N) 空间复杂度：O(1) func rangeBitwiseAnd(m int, n int) int { if m == n { return m } //构造一个mask使得mask的最高位为n的最高位1所在的那1位，从该位开始寻找到某一位，满足一下条件： //当向右循环到某1位的时候，左边的所有位m和n都相同，此时直接返回前面的所有位+后面补0即可 mask := 1 for mask 0 && mask&m == mask&n { ret += mask&m mask >>= 1 } return ret } 方法二：位移 思路：使用位移算法直接对两个传入的数字偏移 对传入的两个数字进行不断位移，直到两个数相等便是最长公共前缀，直接返回即可 func rangeBitwiseAnd(m int, n int) int { shift := 0 for m>>shift != n>>shift { shift += 1 } return m >> shift 【推荐】方法三：Brian Kernighan 算法 算法核心思想： \"Brian Kernighan算法可以用于清除二进制数中最右侧的1。Brian Kernighan算法的做法是先将当前数减一,然后在与当前数进行按位与运算。” 每次清除最右边的1，直到两个数获取最长前缀后的n肯定小于等于m,便是最长公共前缀 Brian Kernighan 的算法需要的迭代次数会更少，因为它跳过了两个数字之间的所有零位 func rangeBitwiseAnd(m int, n int) int { for n > m { n &= (n-1) } return n } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/202.快乐数/code.html":{"url":"LeetCode/202.快乐数/code.html","title":"202.快乐数","keywords":"","body":"202. 快乐数方法一：使用hashset方法二：快慢指针方法三：数学法202. 快乐数 方法一：使用hashset 性质：如果一个数的各位平方和加起来最后到不了1，那么肯定陷入无限循环 思路：我们用map记录出现的数的各位平方和，当下次在map中，直接返回false,否则继续，并将没出现的数加入map，直到1出现 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.2 ms, 在所有 Go 提交中击败了8.14%的用户 func isHappy(n int) bool { if n 方法二：快慢指针 思路：既然我们上面提到了，各位数字平方和最终到不了1，就一定会陷入无限循环，因此这道题目可以等价于链表找环，如果存在环就说明一定会陷入无限循环，如果不存在环，我们最终需要判断是否可以到达1 改进：不需要使用额外空间 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2 ms, 在所有 Go 提交中击败了87.13%的用户 func getDigitSquareSum(num int) int { sum := 0 for num != 0 { sum += (num % 10) * (num % 10) num = num / 10 } return sum } func isHappy(n int) bool { if n 方法三：数学法 参考LeetCode官方解法三 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/203.移除链表元素/code.html":{"url":"LeetCode/203.移除链表元素/code.html","title":"203.移除链表元素","keywords":"","body":"203. 移除链表元素方法一：通过建立哨兵节点统一删除所有节点的操作203. 移除链表元素 方法一：通过建立哨兵节点统一删除所有节点的操作 思路：有些人可能一眼觉得如果删除的是头结点怎么办，其实我们通过一个dummyNode将所有节点的删除进行了统一。 执行用时：8 ms, 在所有 Go 提交中击败了89.78%的用户 内存消耗：4.7 ms, 在所有 Go 提交中击败了13.17%的用户 func removeElements(head *ListNode, val int) *ListNode { if head == nil { return nil } dummyNode := &ListNode{Next: head} cur := dummyNode for cur.Next != nil { if cur.Next.Val == val { cur.Next = cur.Next.Next } else { cur = cur.Next } } return dummyNode.Next } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/205.同构字符串/code.html":{"url":"LeetCode/205.同构字符串/code.html","title":"205.同构字符串","keywords":"","body":"205. 同构字符串205. 同构字符串 思路：题目中说明了：两个字符不能映射到同一个字符上，但字符可以映射自己本身。这里我们采用两个map进行双向验证，第一个字符串到第2个字符串使用mymap1进行映射，第2个字符串到第1个字符串使用mymap2进行映射 执行用时：4 ms, 在所有 Go 提交中击败了75.24%的用户 内存消耗：2.6 MB, 在所有 Go 提交中击败了100.00%的用户 func isIsomorphic(s string, t string) bool { //长度不等肯定替换不可以得到直接返回false if (s == \"\" && t == \"\") || len(s) != len(t) { return false } mymap := make(map[uint8]uint8) for i := 0; i 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/208.实现Trie前缀树/code.html":{"url":"LeetCode/208.实现Trie前缀树/code.html","title":"208.实现Trie前缀树","keywords":"","body":"208. 实现 Trie (前缀树)方法一：参考Leetcode-cookbook方法二：208. 实现 Trie (前缀树) 方法一：参考Leetcode-cookbook 思路：通过系统提供的map建立映射 执行用时：88ms, 在所有 Go 提交中击败了23.01%的用户 内存消耗：16.6 MB, 在所有 Go 提交中击败了55.39%的用户 type Trie struct { isWord bool children map[rune]*Trie } /** Initialize your data structure here. */ func Constructor() Trie { return Trie{ isWord: false, children: make(map[rune]*Trie), } } /** Inserts a word into the trie. */ func (this *Trie) Insert(word string) { parent := this //遍历每个字符 for _, ch := range word { if v, ok := parent.children[ch]; ok { parent = v } else { parent.children[ch] = &Trie{ isWord: false, children: make(map[rune]*Trie), } parent = parent.children[ch] } } parent.isWord = true } /** Returns if the word is in the trie. */ func (this *Trie) Search(word string) bool { parent := this //遍历每个字符 for _, ch := range word { if v, ok := parent.children[ch]; ok { parent = v } else { return false } } //走到最后可能不是一个单词，因为可能是一个前缀 return parent.isWord } /** Returns if there is any word in the trie that starts with the given prefix. */ func (this *Trie) StartsWith(prefix string) bool { parent := this //遍历每个字符 for _, ch := range prefix { if v, ok := parent.children[ch]; ok { parent = v } else { return false } } return true } /** * Your Trie object will be instantiated and called as such: * obj := Constructor(); * obj.Insert(word); * param_2 := obj.Search(word); * param_3 := obj.StartsWith(prefix); */ 方法二： 思路：通过一个长度为26的切片进行hash映射 执行用时：52 ms, 在所有 Go 提交中击败了97.01%的用户 内存消耗：18.3 MB, 在所有 Go 提交中击败了46.39%的用户 type Trie struct { endOfWord bool children [26]*Trie } /** Initialize your data structure here. */ func Constructor() Trie { return Trie{} //这里系统会帮助我们提前创建好endOfWord以及children } /** Inserts a word into the trie. */ func (this *Trie) Insert(word string) { cur := this for _, val := range word { if cur.children[val-'a'] != nil { cur = cur.children[val-'a'] } else { cur.children[val-'a'] = &Trie{} cur = cur.children[val-'a'] } } cur.endOfWord = true } /** Returns if the word is in the trie. */ func (this *Trie) Search(word string) bool { cur := this for _, val := range word { if cur.children[val-'a'] != nil { cur = cur.children[val-'a'] } else { return false } } return cur.endOfWord } /** Returns if there is any word in the trie that starts with the given prefix. */ func (this *Trie) StartsWith(prefix string) bool { cur := this for _, val := range prefix { if cur.children[val-'a'] != nil { cur = cur.children[val-'a'] } else { return false } } return true } /** * Your Trie object will be instantiated and called as such: * obj := Constructor(); * obj.Insert(word); * param_2 := obj.Search(word); * param_3 := obj.StartsWith(prefix); */ 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/219.存在重复元素II/code.html":{"url":"LeetCode/219.存在重复元素II/code.html","title":"219.存在重复元素II","keywords":"","body":"版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/222.完全二叉树的节点个数/code.html":{"url":"LeetCode/222.完全二叉树的节点个数/code.html","title":"222.完全二叉树的节点个数","keywords":"","body":"222. 完全二叉树的节点个数方法一：自己写【推荐方法二，效率会高，虽然时复一样】方法二：参考labuladong222. 完全二叉树的节点个数 完全二叉树：根的左右两侧一定有一侧是满二叉树。此时我们可以利用2^h - 1求解该侧对应二叉树的高度。其实完全二叉树是满二叉树与普通二叉树的结合体。 几种情况： 左右子树高度相同： 1.1 左子树是满二叉树，右子树是满二叉树 1.2 左子树是满二叉树，右子树不是满二叉树 左子树大于右子树高度，此时右子树一定是满二叉树 技巧：每次寻找左右子树的高度，只需要找到左子树最左边的节点以及右子树的最右边的节点，如果相等，则说明是满二叉树 方法一：自己写【推荐方法二，效率会高，虽然时复一样】 //✅ //方法一：计算左右子树的高度，然后判断哪一侧是满的，然后递归到另外一侧非满的 //执行用时：24 ms, 在所有 Go 提交中击败了23.62%的用户 //内存消耗：7.1 MB, 在所有 Go 提交中击败了49.25%的用户 func countNodes(root *TreeNode) int { //如果二叉树为空，直接返回0 if root == nil { return 0 } //获得左右子树的高度 hl, hr := getHeight(root.Left), getHeight(root.Right) //如果左右子树高度相等，说明左子树是满二叉树 if hl == hr { //注意点：这里是1 b { return a } return b } 方法二：参考labuladong //✅ //方法二：参考labuladong的 //每次获取左子树的最左边节点与右子树的最右边节点的高度，如果高度相等，说明是一颗满二叉树，否则就分别递归求出左右子树的节点个数+1 //执行用时：20 ms, 在所有 Go 提交中击败了68.62%的用户 //内存消耗：7.1 MB, 在所有 Go 提交中击败了96.25%的用户 func countNodes(root *TreeNode) int { if root == nil { return 0 } l, r := root.Left, root.Right hl, hr := 0, 0 for l != nil { hl++ l = l.Left } for r != nil { hr++ r = r.Right } if hl == hr { return 1 两个方法的时间复杂度都是o(logN logN)但是方法二常数项更加低，所以*推荐方法二 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/225用队列实现栈/code.html":{"url":"LeetCode/225用队列实现栈/code.html","title":"225.用队列实现栈","keywords":"","body":"用队列实现栈方法一：两个队列实现栈方法二：[推荐]一个队列实现栈总结：用队列实现栈 方法一：两个队列实现栈 思路：使用两个队列模拟栈， 使用队列实现栈，使用两个队列来实现栈，queue1, queue2, 当加入元素的时候直接加入到queue1 当弹出元素的时候，将queue1中的所有元素移动到queue2，只留下最后一个元素返回并移除，此时将queue1 与 queue2 互换 当查看栈顶的时候，将queue1中所有的元素一样，压入到queue2，记录queue1最后一个元素的值。之后将queue1与queue2互换，此时返回我们记录的最后一个元素的值 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2 MB, 在所有 Go 提交中击败了80.70%的用户 type MyStack struct { queue1, queue2 []int } /** Initialize your data structure here. */ func Constructor() MyStack { return MyStack{ queue1: []int{}, queue2: []int{}, } } /** Push element x onto stack. */ func (this *MyStack) Push(x int) { this.queue1 = append(this.queue1, x) } /** Removes the element on top of the stack and returns that element. */ func (this *MyStack) Pop() int { for len(this.queue1) != 1 { this.queue2 = append(this.queue2, this.queue1[0]) this.queue1 = this.queue1[1:] } //获得最后一个元素的值并弹出 val := this.queue1[0] this.queue1 = this.queue1[1:] //交换queue1与queue2 this.queue1, this.queue2 = this.queue2, this.queue1 //弹出并返回我们栈中的栈顶 return val } /** Get the top element. */ func (this *MyStack) Top() int { for len(this.queue1) != 1 { this.queue2 = append(this.queue2, this.queue1[0]) this.queue1 = this.queue1[1:] } //获得最后一个元素的值 val := this.queue1[0] this.queue2 = append(this.queue2, this.queue1[0]) this.queue1 = this.queue1[1:] //交换queue1与queue2 this.queue1, this.queue2 = this.queue2, this.queue1 //弹出并返回我们栈中的栈顶 return val } /** Returns whether the stack is empty. */ func (this *MyStack) Empty() bool { return len(this.queue1) == 0 && len(this.queue2) == 0 } 方法二：[推荐]一个队列实现栈 思路：因为我们每次加入的元素在栈里面都是栈顶，所以我们使用一个队列在加入元素的时候，将队列里面的元素进行反转。此时我们队列头就是栈顶元素，其他操作与栈雷同。 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2 MB, 在所有 Go 提交中击败了45.61%的用户 type MyStack struct { queue []int } /** Initialize your data structure here. */ func Constructor() MyStack { return MyStack{ queue: []int{}, } } /** Push element x onto stack. */ func (this *MyStack) Push(x int) { this.queue = append(this.queue, x) //将前面n-1个元素扔到后面 for i := 1; i 总结： 这里是使用队列来实现栈，自己参考了LeetCode上很多解法，采用了一个双端队列来实现，并不符合题目中的要求peek/pop from front。这里罗列了两个方法，其中一个方法只使用一个队列，空复为O(N)，另外一个方法使用了两个队列，空复为O(N*2)。 每个操作的时间复杂度： 方法一：两个队列 方法二：一个队列 Push O(1) O(N) Pop O(N) O(1) top O(1) O(1) empty O(1) O(1) 其他解法详见 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/226翻转二叉树/code.html":{"url":"LeetCode/226翻转二叉树/code.html","title":"226.翻转二叉树","keywords":"","body":"226 翻转二叉树方法一：从上到下递归反转方法二：从下到上递归反转总结226 翻转二叉树 方法一：从上到下递归反转 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.1 MB, 在所有 Go 提交中击败了100.00%的用户 func invertTree(root *TreeNode) *TreeNode { if root == nil { return nil } root.Left, root.Right = root.Right, root.Left invertTree(root.Left) invertTree(root.Right) return root } 方法二：从下到上递归反转 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.1 MB, 在所有 Go 提交中击败了65.09%的用户 func invertTree(root *TreeNode) *TreeNode { if root == nil { return nil } root.Left, root.Right = invertTree(root.Right), invertTree(root.Left) return root } 总结 从上到下与从下到上的区别就是：从上到下，先执行操作，最后递归调用即可。而从下到上则是先递归到下面，执行操作之后，需要上面接收下面执行操作后的返回值。例如上面的翻转二叉树，从下到上则是先翻转左右子树，之后采用当前节点的两个节点接收后进行翻转。 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/234.回文链表/code.html":{"url":"LeetCode/234.回文链表/code.html","title":"234.回文链表","keywords":"","body":"234. 回文链表方法：双指针+反转链表234. 回文链表 方法：双指针+反转链表 执行用时：12 ms, 在所有 Go 提交中击败了96.94%的用户 内存消耗：5.6 ms, 在所有 Go 提交中击败了100.00%的用户 思路： 1. fast为快指针，slow为慢指针，不断移动，移动过程中slow不断进行反转链表 2. 当fast指向链表最后一个节点或者fast为nil的时候就停止，此时prev为我们反转的前一半链表的表头 2.1 如果有奇数个节点，fast指向最后一个节点，slow指向中间的链表正中间的节点， 2.2 ，如果有偶数个节点，fast指向nil，slow指向链表中间第2个节点) 3. 此时如果有奇数个节点我们需要将slow后移一个单位 4. 将prev赋值给fast 5. 之后不断循环比较slow与fast，并进行移动 func isPalindrome(head *ListNode) bool { //首先检查是否为空链表 if head == nil { return true } fast, slow := head, head prev := head //让fast走到链表尾部的时候，(如果有奇数个节点，fast指向最后一个节点，如果有偶数个节点，fast指向nil) //slow指向链表的中间(如果有奇数个节点则为中间，如果是偶数个节点，则是中间第2个节点) for fast != nil && fast.Next != nil { fast, prev, slow, slow.Next = fast.Next.Next, slow, slow.Next, prev } //说明有奇数个节点，此时slow指向中间节点，我们需要将它后移一个单位 if fast != nil { slow = slow.Next } //此时prev指向前半段反转完的头节点 fast = prev //此时不断的从两个链表的开始进行比较，如果中间有不等就直接返回false for fast != nil && slow != nil { if fast.Val != slow.Val { return false } fast, slow = fast.Next, slow.Next } return true } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/235.二叉搜索树的最近公共祖先/code.html":{"url":"LeetCode/235.二叉搜索树的最近公共祖先/code.html","title":"235.二叉搜索树的最近公共祖先","keywords":"","body":"235. 二叉搜索树的最近公共祖先方法一：递归方法二：迭代235. 二叉搜索树的最近公共祖先 思路：利用二叉搜索树的特性，左子树节点小于等于根，右子树节点大于等于根 如果两个节点的值都大于根，则说明最近公共最先应该往根的右边找 如果两个节点的值都小于根，则说明最近公共最先应该往根的左边找 如果两个节点的值一个大于根，一个小于根，则说明最近公共祖先就是当前的根节点 方法一：递归 时间复杂度：O(N) 空间复杂度：O(N) func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } //如果p,q都在一侧则一定都比roo大或者都比root小 if p.Val > root.Val && q.Val > root.Val { return lowestCommonAncestor(root.Right, p, q) } else if p.Val 方法二：迭代 时间复杂度：O(N) 空间复杂度：O(1) func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } for root != nil { //如果p,q都在一侧则一定都比roo大或者都比root小 if p.Val > root.Val && q.Val > root.Val { root = root.Right } else if p.Val 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/236.二叉树的最近公共祖先/code.html":{"url":"LeetCode/236.二叉树的最近公共祖先/code.html","title":"236.二叉树的最近公共祖先","keywords":"","body":"236. 二叉树的最近公共祖先方法：dfsGo解法python解法236. 二叉树的最近公共祖先 方法：dfs 思路：题目中说明了树中节点值唯一，并且两个节点都存在于树中 如果当前节点的左右子树都不空，直接返回当前节点 如果左子树为空，直接返回右节点 如果右子树为空，直接返回左节点 关键点： 如果当前的节点为左节点或右节点，我们直接返回当前节点。 ​ 2. 如果当前节点为空，直接返回当前节点 小问题：自己之前很不理解的就是如果两个节点都在当前节点的左子树最下方，那么这个函数不是返回当前节点么？ 解释：首先如果两个节点都在当前节点的孙子节点，那么返回的是当前节点的儿子节点而不是孙子节点，因为我们使用dfs一层一层遍历，当遍历到孙子那层返回两个节点，但是之后递归回到了当前节点的孩子那一层，此时发现左右两个子树节点满足条件，所以返回当前节点的孩子节点，也就是最终答案楼 执行用时：16 ms, 在所有 Go 提交中击败了 63.91% 的用户 内存消耗：7.6 MB, 在所有 Go 提交中击败了 17.10% 的用户 Go解法 func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil || root == p || root == q { return root } //递归遍历到左子树 left := lowestCommonAncestor(root.Left, p, q) //递归遍历到右子树 right := lowestCommonAncestor(root.Right, p, q) //如果左边的不空 if left != nil { if right != nil { //说明左节点在左边，右节点在右边 return root } //说明左子树那边不空(且此时left为其中的一个节点)，右子树那边没有p和q return left } //走到这里说明left没找到，直接返回right即可 //原因：题目说明了两个节点都出现了并且树中所有节点的值都不相同 return right } python解法 class Solution: def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode: if root is None or root == p or root == q: return root left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) if left is not None: if right is not None: return root return left return right 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/237删除链表中的节点/code.html":{"url":"LeetCode/237删除链表中的节点/code.html","title":"237.删除链表中的节点","keywords":"","body":"237 删除链表中的节点237 删除链表中的节点 思路： 因为题目中说明了 传入的是要删除的节点，并且保证这个要删除的节点不是最后一个节点。也就是当前节点的Next不为空。所以我们可以下一个节点的值替换到当前节点， 之后将当前节点的Next 指向当前节点的Next的Next 执行用时：4 ms, 在所有 Go 提交中击败了70.15%的用户 内存消耗：2.9 MB, 在所有 Go 提交中击败了59.74%的用户 func deleteNode(node *ListNode) { node.Val, node.Next = node.Next.Val, node.Next.Next } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/238除自身以外数组的乘积/code.html":{"url":"LeetCode/238除自身以外数组的乘积/code.html","title":"238除自身以外数组的乘积","keywords":"","body":"除自身以外数组的乘积方法一：[推荐]方法二：只使用一个数组和两次遍历来解决总结：除自身以外数组的乘积 方法一： 思路：使用两个数组，分别求出nums[i]左右两边的乘积，最后进行相乘 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2 MB, 在所有 Go 提交中击败了21.38%的用户 //时间复杂度：O(N) //空间复杂度：O(N) numsBefore数组表示nums[0].....nums[i-1]。公式如下： numsBefore[0] = 1 numsBefore[i] = numsBefore[i-1] * nums[i-1] numsEnd数组表示nums[i+1].....nums[len(nums)-1] numsEnd[len(nums)-1] = 1 numsEnd[len(nums)-1-i] = numsEnd[len(nums)-i] * nums[len(nums)-i] func productExceptSelf(nums []int) []int { numsBefore, numsEnd := make([]int, len(nums)), make([]int, len(nums)) numsBefore[0] = 1 numsEnd[len(nums)-1] = 1 for i := 1; i [推荐]方法二：只使用一个数组和两次遍历来解决 改进思路：因为题目中说在常数空间复杂度内完成这道题目。所以我们只采用一个数组，按顺序求完前面i-1个元素的乘积，之后再从数组最后一个元素开始倒序开始求后半部分的乘积 执行用时：16 ms, 在所有 Go 提交中击败了72.51%的用户 内存消耗：6.3 MB, 在所有 Go 提交中击败了98.36%的用户 //时间复杂度：O(N) //空间复杂度：O(1) func productExceptSelf(nums []int) []int { answer := make([]int, len(nums)) answer[0] = 1 //计算上三角 for i := 1; i = 0; i-- { q *= nums[i+1] answer[i] *= q } return answer } 总结： 方法一：我们使用了两个额外的数组，分别计算该数字左右两边的乘积， 方法二：我们只使用了一个数组，但是两次遍历计算得到我们最终的结果， 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/257.二叉树的所有路径/code.html":{"url":"LeetCode/257.二叉树的所有路径/code.html","title":"257.二叉树的所有路径","keywords":"","body":"257. 二叉树的所有路径方法一：DFS+前序遍历方法二：对方法一的代码优化257. 二叉树的所有路径 方法一：DFS+前序遍历 思路： 如果有左右子树就加上->，之后递归到左右子树，递归回来之后记得去掉-> 如果没有左右子树，直接将path加入到ret中 执行用时：0ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.4 MB, 在所有 Go 提交中击败了59.58%的用户 func binaryTreePaths(root *TreeNode) []string { if root == nil { return nil } ret := []string{} path := \"\" dfs(root, &ret, path) return ret } func dfs(root *TreeNode, ret *[]string, path string) { //如果有左右子树就加上—>，之后递归到左右子树 //如果没有左右子树，直接将path加入到ret中 path = path + strconv.Itoa(root.Val) if root.Left == nil && root.Right == nil { *ret = append(*ret, path) } if root.Left != nil { path = path + \"->\" dfs(root.Left, ret, path) path = path[:len(path)-2] } if root.Right != nil { path = path + \"->\" dfs(root.Right, ret, path) path = path[:len(path)-2] } } 方法二：对方法一的代码优化 执行用时：0ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.4 MB, 在所有 Go 提交中击败了43.92%的用户 func binaryTreePaths(root *TreeNode) []string { if root == nil { return nil } ret := []string{} path := \"\" dfs(root, &ret, path) return ret } func dfs(root *TreeNode, ret *[]string, path string) { //如果有左右子树就加上—>，之后递归到左右子树 //如果没有左右子树，直接将path加入到ret中 path = path + strconv.Itoa(root.Val) if root.Left == nil && root.Right == nil { *ret = append(*ret, path) } path = path + \"->\" if root.Left != nil { dfs(root.Left, ret, path) } if root.Right != nil { dfs(root.Right, ret, path) } } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/258.各位相加/code.html":{"url":"LeetCode/258.各位相加/code.html","title":"258.各位相加","keywords":"","body":"258. 各位相加方法一：自己想到的解法，暴力迭代方法二：性质：一个数的树根就是它对9的余数方法三：找规律258. 各位相加 方法一：自己想到的解法，暴力迭代 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.2 MB, 在所有 Go 提交中击败了17.16%的用户 func addDigits(num int) int { sum := getDigitSum(num) for sum >= 10 { sum = getDigitSum(sum) } return sum } func getDigitSum(num int) int { sum := 0 for num != 0 { sum += num % 10 num /= 10 } return sum } 方法二：性质：一个数的树根就是它对9的余数 思路：各位相加对9取余(就是数根)等于该数对9取余 步骤：因此如果该数对9取余之后如果返回0说明该数可以被9整除，因此直接返回9，0比较特殊 下面例子讲解参考 例子：例如12345 可以写成(1 + 9999) 1 + (999 + 1) 2 + (99 + 1) 3 + (9 + 1) 4 + 5 1 = (9999 + 999 + 99 + 9) + (1 1 + 2 1 + 3 1 + 4 1 + 5 1) 此时将上面化简得到的结果%9可以得到各位数的和 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.2 MB, 在所有 Go 提交中击败了17.16%的用户 func addDigits(num int) int { if num == 0 { return num }else if num % 9 == 0 { return 9 } else { return num % 9 } } 方法三：找规律 参考 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.2 MB, 在所有 Go 提交中击败了17.16%的用户 原数: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 偏移: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 取余: 0 1 2 3 4 5 6 7 8 0 1 2 3 4 5 6 7 8 0 1 2 3 4 5 6 7 8 0 1 2 数根: 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 func addDigits(num int) int { return (num - 1) % 9 + 1 } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/260.只出现一次的数字III/code.html":{"url":"LeetCode/260.只出现一次的数字III/code.html","title":"260.只出现一次的数字III","keywords":"","body":"260. 只出现一次的数字 III方法一：对方法一的改进：260. 只出现一次的数字 III 方法一： 思路： 1. 首先将所有数异或，得到可以区分两个只出现一次数字的异或结果， 2. 将所有数字分成两组，如果与上面的异或结果异或 3. 将两组中每个组中的所有数字进行异或，得到两个最终结果 4. 返回这两个最终结果 执行用时：8 ms, 在所有 Go 提交中击败了90.46%的用户 内存消耗：4 MB, 在所有 Go 提交中击败了100.00%的用户 func singleNumber(nums []int) []int { xorRet := 0 for _, num := range nums { xorRet ^= num } //取到异或结果中的最低位 mask := (xorRet & (-xorRet)) //根据这一位将数据分成两组 first, second := 0, 0 for _, num := range nums { if mask & num != 0 { first ^= num } else { second ^= num } } //最后的每组对应的数便是结果 return []int{first, second} } 对方法一的改进： 改进点：对上面代码的小幅改进，不需要使用两个变量进行分别对应我们的结果。同时直接构造mask而不需要重新建变量 执行用时：8 ms, 在所有 Go 提交中击败了90.46%的用户 内存消耗：4 MB, 在所有 Go 提交中击败了100.00%的用户 func singleNumber(nums []int) []int { xorRet := 0 for _, num := range nums { xorRet ^= num } //取到异或结果中的最低位 xorRet = (xorRet & (-xorRet)) ret := []int{0, 0} //根据这一位将数据分成两组 for _, num := range nums { if xorRet & num != 0 { ret[0] ^= num } else { ret[1] ^= num } } //最后的每组对应的数便是结果 return ret } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/263.丑数/code.html":{"url":"LeetCode/263.丑数/code.html","title":"263.丑数","keywords":"","body":"263. 丑数方法一：自己的解法方法二：263. 丑数 方法一：自己的解法 执行用时：4ms, 在所有 Go 提交中击败了58.00%的用户 内存消耗：2.2 MB, 在所有 Go 提交中击败了5.06%的用户 func isUgly(num int) bool { if num >= 1 } else if num & 1 != 0 { //如果不能被以上3个整除并且此时不为1，直接返回false return false } } return true } 方法二： 思路：如果能够被5，3，2整除就一直除下去，直到最终判断是否为1即可 执行用时：0ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.2 MB, 在所有 Go 提交中击败了5.06%的用户 func isUgly(num int) bool { /*负数以及0肯定不是丑数*/ if num 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/268.缺失数字/code.html":{"url":"LeetCode/268.缺失数字/code.html","title":"268.缺失数字","keywords":"","body":"268. 缺失数字方法一：快排 + 二分方法二：遍历一次数组【推荐】方法三：利用异或的性质 x ^ x = 0268. 缺失数字 方法一：快排 + 二分 时间复杂度：O(N*logN) 思路：快排之后进行二分，查找到缺失的数字并返回 方法二：遍历一次数组 遍历的时候，记录该数组的和，同时动态维护最小值和最大值， 遍历完成之后，首先检查最小值是否为0，如果不是直接返回0，之后做如下操作 如果数组的和 != [最小值，最大值]这个闭区间范围的和，那么我们直接做差返回即可 如果等于则说明缺失最后一个N，直接返回len(nums)即可 【推荐】方法三：利用异或的性质 x ^ x = 0 思路：利用异或的性质 x ^ x = 0 ，我们构造一个0-N的数组(不存在缺失数字)直接与传入的数组进行异或，此时就已经转换为136题，数组中某个数出现了1次，其他数都出现了两次，只不过我们这里是两个数组。 构造一个数组(包含[0,n]之间的所有数字，将传入的数组与这个数组中所有元素异或，其实走到这里就等价于136题中的某个数出现了1次，其他数都出现了两次) 执行用时：16 ms, 在所有 Go 提交中击败了97.39%的用户 内存消耗：6.3 MB, 在所有 Go 提交中击败了7.66%的用户 func missingNumber(nums []int) int { xorRet := 0 for i := 0; i 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/290.单词规律/code.html":{"url":"LeetCode/290.单词规律/code.html","title":"290.单词规律","keywords":"","body":"290. 单词规律290. 单词规律 关键点：建立双向关系，例如abba 与dog dog dog dog是匹配的，但是如果反过来就不匹配了，因此我们需要考虑双向关系。 题目中说明了：pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。因此我们定义两个map使得pattern中的字母可以合法匹配str中的每个非空单词，以及str中的每个非空单词可以合法匹配pattern中的字母 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2 MB, 在所有 Go 提交中击败了100.00%的用户 func wordPattern(pattern string, str string) bool { strs := strings.Split(str, \" \") if len(strs) != len(pattern) { return false } mymap := make(map[uint8]string) for i := 0; i 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/300.最长上升子序列/code.html":{"url":"LeetCode/300.最长上升子序列/code.html","title":"300.最长上升子序列","keywords":"","body":"300. 最长上升子序列方法一：300. 最长上升子序列 方法一： 思路：虽然是一个子序列，但是没有说连续，所以可能不连续 步骤： base case : dp[0] = 1 状态定义：dp[i] 表示子序列以第i个元素结尾时的长度 状态方程：dp[i] = max(dp[j], dp[k].....前面比第i个元素小的值对应的dp值) + 1 额外的一步：分析状态转移方程不能满足的特殊情况 最后返回的结果：遍历dp数组返回最大值即可 执行用时：12 ms, 在所有 Go 提交中击败了44.35%的用户 内存消耗：2.4 ms, 在所有 Go 提交中击败了28.76%的用户 func lengthOfLIS(nums []int) int { if len(nums) nums[j] { if dp[j] + 1 > dp[i] { dp[i] = dp[j] + 1 } } } if max 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/326.3的幂/code.html":{"url":"LeetCode/326.3的幂/code.html","title":"326.3的幂","keywords":"","body":"326. 3的幂方法一：判断是否可以除尽3方法二：将n转换为3进制后只有1个1方法三：打表法，3的幂在int32范围内只有19个方法四：参考leetcode官方题解最后一种解法326. 3的幂 方法一：判断是否可以除尽3 思路：不断除以3，最后如果余数为0说明是3的幂次方 方法二：将n转换为3进制后只有1个1 思路：将n转换为3进制之后，1在开头并且后面全为0 方法三：打表法，3的幂在int32范围内只有19个 思路：将19个范围内的3的幂列出来，直接放在map中，如果是对应的数字直接返回true，否则返回false 方法四：参考leetcode官方题解最后一种解法 思路：因为3是质数，且3^19是位于范围内的最大的3的幂，因此如果n>0且3^19%n==0则一定是3的幂 执行用时：32 ms, 在所有 Go 提交中击败了66.67%的用户 内存消耗：6.1 ms, 在所有 Go 提交中击败了32.61%的用户 func isPowerOfThree(n int) bool { return n > 0 && int(math.Pow(3.0, 19.0)) % n == 0 } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/338.比特位计数/code.html":{"url":"LeetCode/338.比特位计数/code.html","title":"338.比特位计数","keywords":"","body":"338. 比特位计数方法一：暴力求解方法二：dp338. 比特位计数 方法一：暴力求解 思路：循环统计每个数1的位数即可 方法二：dp 思路：利用性质，数字n和数字n&(n-1)的二进制表示差1个1 原因：因为n&(n-1)就是去掉数字n二进制表示中最后一个1 步骤： base case，dp[0] = 0 状态：dp[i]表示数字i中二进制1的个数 选择：没有选择 dp数组：dp[i] = dp[i&(i-1)] + 1 执行用时：4 ms, 在所有 Go 提交中击败了91.93%的用户 内存消耗：6.1 ms, 在所有 Go 提交中击败了18.18%的用户 func countBits(num int) []int { if num 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/342.4的幂/code.html":{"url":"LeetCode/342.4的幂/code.html","title":"342.4的幂","keywords":"","body":"342. 4的幂方法一：找规律方法二：改进其他思路342. 4的幂 方法一：找规律 题目要求不可以用循环或迭代，所以只能自己找规律 4的幂次方的规律在于：同时成立如下3个条件 首先是一个整数 其次二进制表示中只有1个1 二进制的1只在特定位置上，也就是倒数奇数位上 执行用时：4 ms, 在所有 Go 提交中击败了47.24%的用户 内存消耗：2.1 MB, 在所有 Go 提交中击败了100.00%的用户 func isPowerOfFour(num int) bool { return num > 0 && (num&(num-1) == 0) && ((num & (0b101010101010101010101010101010)) != 0) } 方法二：改进 重点：之前写的是1要在偶数位上。这次我们换一个思路，如果1在特定的位置上那么与操作0xaaaaaaaa一定为0 执行用时：4 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.1 MB, 在所有 Go 提交中击败了100.00%的用户 func isPowerOfFour(num int) bool { return num > 0 && (num&(num-1) == 0) && ((num & (0xaaaaaaaa)) == 0) } 其他思路 LeetCode官方题解中提出了使用该数字对2取对数，如果为偶数，那么一定是4的幂次方，否则不是。思路比较新颖，自己没有想到 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/344.反转字符串/code.html":{"url":"LeetCode/344.反转字符串/code.html","title":"344.反转字符串","keywords":"","body":"344. 反转字符串方法一：直接反转方法二：使用双指针进行反转344. 反转字符串 方法一：直接反转 执行用时：36 ms, 在所有 Go 提交中击败了97.98%的用户 内存消耗：6.3 MB, 在所有 Go 提交中击败了60.28%的用户 func reverseString(s []byte) { for i := 0; i > 1); i++ { s[i], s[len(s)-1-i] = s[len(s)-1-i], s[i] } } 方法二：使用双指针进行反转 执行用时：36 ms, 在所有 Go 提交中击败了97.98%的用户 内存消耗：6.3 MB, 在所有 Go 提交中击败了60.28%的用户 func reverseString(s []byte) { l, r := 0, len(s)-1 for l 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/345.反转字符串中的元音字母/code.html":{"url":"LeetCode/345.反转字符串中的元音字母/code.html","title":"345.反转字符串中的元音字母","keywords":"","body":"345. 反转字符串中的元音字母方法一：对撞指针思想进行反转345. 反转字符串中的元音字母 方法一：对撞指针思想进行反转 思路：我们通过对传入的字符串设置两个指针，分别指向最左和最右，分别从左向右和从右向左搜寻元音字母，两个都找到之后就进行替换(前提是left 注意事项： 这里aA都是元音字母 同时l,r每次搜寻的时候注意不要越界 执行用时：4 ms, 在所有 Go 提交中击败了83.52%的用户 内存消耗：4.1 ms, 在所有 Go 提交中击败了52.70%的用户 func reverseVowels(s string) string { if len(s) = 0 && !vowelMap[str[r]] { r -= 1 } //很有可能最后l指向后面的元音字母，而right位于left前面也指向元音字母，但此时不可以交换 if l 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/349.两个数组的交集/code.html":{"url":"LeetCode/349.两个数组的交集/code.html","title":"349.两个数组的交集","keywords":"","body":"349. 两个数组的交集方法一：暴力遍历方法二：349. 两个数组的交集 方法一：暴力遍历 思路：对数组1的所有元素依次判断是否在num2中 时间复杂度：O(N^2) ​ 空间复杂度：O(1) 方法二： 思路：借助一个map统计其中一个数组出现的数字，当另外一个数组数字在map中就加入结果中，同时加入之后记得将map中的键值对失效(可以通过map中设置值为false或者设置值为0) 执行用时：4 ms, 在所有 Go 提交中击败了89.06%的用户 内存消耗：3.1 ms, 在所有 Go 提交中击败了12.07%的用户 时间复杂度：O(M+N) 空间复杂度：O(M) 技巧：这里我们当数组2的元素出现在map中后，将map的键对应的值减去1，避免重复加入 func intersection(nums1 []int, nums2 []int) []int { if len(nums1) == 0 || len(nums2) == 0{ return []int{} } mymap := make(map[int]int) for _, val := range nums1 { mymap[val] = 1 } ret := []int{} for _, val := range nums2 { if mymap[val] == 1 { ret = append(ret, val) mymap[val] = 0 //技巧操作，避免同一个元素出现多次但都是交集重复加入ret中 } } return ret } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/350.两个数组的交集II/code.html":{"url":"LeetCode/350.两个数组的交集II/code.html","title":"350.两个数组的交集II","keywords":"","body":"350. 两个数组的交集 II350. 两个数组的交集 II 思路： 使用map统计数组1中出现的元素，其中键作为元素，值作为次数 之后遍历数组2，如果在map中出现了并且次数不为0，次数减去1，同时将其加入结果， 执行用时：4 ms, 在所有 Go 提交中击败了91.16%的用户 内存消耗：3.2 MB, 在所有 Go 提交中击败了9.48%的用户 func intersect(nums1 []int, nums2 []int) []int { mymap := make(map[int]int) ret := []int{} for _, num := range nums1 { mymap[num] += 1 } for _, num := range nums2 { if mymap[num] != 0 { mymap[num] -= 1 ret = append(ret, num) } } return ret } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/367.有效的完全平方数/code.html":{"url":"LeetCode/367.有效的完全平方数/code.html","title":"367.有效的完全平方数","keywords":"","body":"367. 有效的完全平方数方法一：二分方法二：对上面代码进行改进方法三：牛顿迭代法367. 有效的完全平方数 方法一：二分 注意：mid * mid容易溢出 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2 MB, 在所有 Go 提交中击败了50.00%的用户 func isPerfectSquare(num int) bool { left, right := 1, num for left >1 if mid*mid num { right = mid - 1 } else if mid*mid == num { return true } } return false } 方法二：对上面代码进行改进 改进：避免溢出(不适用mid * mid)，同时增加了num 为1的情况 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.1 MB, 在所有 Go 提交中击败了17.31%的用户 func isPerfectSquare(num int) bool { if num == 1 { return true } left, right := 1, num for left >1 if mid num/mid { //这里为了避免溢出 right = mid - 1 } else if (num%mid == 0) && (num/mid == mid) { //这里为了避免溢出 return true } else if (num%mid != 0) && (num/mid == mid) { left = mid + 1 } } return false } 方法三：牛顿迭代法 参考 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/371.两整数之和/code.html":{"url":"LeetCode/371.两整数之和/code.html","title":"371.两整数之和","keywords":"","body":"371. 两整数之和结论371. 两整数之和 思路：使用位运算 具体步骤同参考 我们分别求出两个数字的异或(两个数独特的位)，以及两个数字的公共位(与运算) 如果两个数字相加，公共位一定进位，因此我们左移1位，此时继续将刚左移1位的结果 与操作 前面求得的异或结果， 如果结果为0，说明没有进位产生，此时我们返回异或的结果 加上 两个位之前进位的结果，但是这两个结果没有重复的二进制位，因此我们返回他们两个的异或 如果结果不为0，说明有进位产生继续重复步骤1 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.1 MB, 在所有 Go 提交中击败了84.70%的用户 func getSum(a int, b int) int { //当不产生进位时 for a & b != 0 { a, b = (a & b) 结论 两个数异或其实就是两个数无进位相加 两个数与操作其实就是求得两个数的进位 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/387.字符串中的第一个唯一字符/code.html":{"url":"LeetCode/387.字符串中的第一个唯一字符/code.html","title":"387.字符串中的第一个唯一字符","keywords":"","body":"387. 字符串中的第一个唯一字符方法一：map计数方法二：使用一个长度为26的数组代替map方法三：两次遍历387. 字符串中的第一个唯一字符 方法一：map计数 第一次遍历，使用map统计每个字符出现的次数 第二次遍历，直接遍历字符串，如果对应字符在map中次数为1直接返回即可 时间复杂度：O(N) 空间复杂度：O(字符串长度) 执行用时：32 ms, 在所有 Go 提交中击败了59.25%的用户 内存消耗：5.3 ms, 在所有 Go 提交中击败了89.64%的用户 func firstUniqChar(s string) int { for len(s) == 0 { return -1 } mymap := make(map[int32]int) for _, c := range s { mymap[c-97] += 1 } for index, c := range s { if mymap[c-97] == 1 { return index } } return -1 } 方法二：使用一个长度为26的数组代替map 思路：每个索引代表一个元素出现的次数， 第一次遍历，如果出现就加1， 第二次遍历字符串，如果对应字符在数组中出现次数为1直接返回 执行用时：4 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：5.2 ms, 在所有 Go 提交中击败了92.40%的用户 func firstUniqChar(s string) int { for len(s) == 0 { return -1 } array := make([]int, 26) for _, c := range s { array[c-97] += 1 } for index, c := range s { if array[c-97] == 1 { return index } } return -1 } 方法三：两次遍历 我们使用一个长度为26的数组， 第1次遍历：将每个元素最后出现的索引放入到数组中 第2次遍历：遍历字符串，并且每次查找对应字符在数组中的索引与当前索引是否相同， 如果相同说明是第一次出现也是最后一次出现的，直接返回。 如果不同，我们修改对应数组元素对应的索引为-1， 当数组遍历完，说明没有找到，此时我们直接返回-1 执行用时：12 ms, 在所有 Go 提交中击败了61.00%的用户 内存消耗：5.2 ms, 在所有 Go 提交中击败了92.40%的用户 func firstUniqChar(s string) int { for len(s) == 0 { return -1 } array := make([]int, 26) for index, c := range s { array[c-97] = index } for index, c := range s { //如果出现的最后一次索引等于第一次出现的索引 if array[c-97] == index { return index } //说明出现很多次 array[c-97] = -1 } return -1 } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/389.找不同/code.html":{"url":"LeetCode/389.找不同/code.html","title":"389.找不同","keywords":"","body":"389. 找不同方法一：【推荐】方法二：方法一的改进总结：389. 找不同 方法一： 思路：将字符串拼接之后，将字符串中的所有字符进行异或 其中一个字符串随机加了一个字母并重排形成另一个字符串，因此两个字符串拼接在一起，相当于某个字符只出现1次，其他字符全都出现2次， 因此考虑遍历每个字符转换为整形并用异或求得结果 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.3 MB, 在所有 Go 提交中击败了8.62%的用户 func findTheDifference(s string, t string) byte { ret := 0 for _, val := range s + t { ret ^= int(val) } return byte(ret) } 【推荐】方法二：方法一的改进 改进点：直接使用一个变量保存异或结果即可 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.2 MB, 在所有 Go 提交中击败了53.45%的用户 func findTheDifference_(s string, t string) byte { var ret uint8 for i := 0; i 总结： 注意： 遍历字符串我们获得每个元素的数据类型为int32。 如果通过对字符串索引取值获得的数据类型是uint8，等价于byte 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/404.左叶子之和/code.html":{"url":"LeetCode/404.左叶子之和/code.html","title":"404.左叶子之和","keywords":"","body":"404. 左叶子之和方法一：递归404. 左叶子之和 方法一：递归 思路：遍历当前节点的左右子树，之后如果当前节点的左节点是左叶子节点就加上 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.7 ms, 在所有 Go 提交中击败了53.85%的用户 func sumOfLeftLeaves(root *TreeNode) int { if root == nil { return 0 } sum := 0 //遍历左右子树 sum += sumOfLeftLeaves(root.Left) sum += sumOfLeftLeaves(root.Right) //如果root的左结点为叶子节点 if root.Left != nil && root.Left.Left == nil && root.Left.Right == nil { sum += root.Left.Val } return sum } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/412.FizzBuzz/code.html":{"url":"LeetCode/412.FizzBuzz/code.html","title":"412.FizzBuzz","keywords":"","body":"412. Fizz Buzz方法一：自己的解法()方法二：LeetCode官方解法二方法三：LeetCode官方解法三412. Fizz Buzz 方法一：自己的解法() 思路：直接按照题目中的要求打印即可 缺点：拓展性不强，如果面试官有多个数字可以被整除的要求，代码逻辑太多且臃肿 执行用时：4 ms, 在所有 Go 提交中击败了95.95%的用户 内存消耗：3.4 MB, 在所有 Go 提交中击败了78.43%的用户 func fizzBuzz(n int) []string { if n 方法二：LeetCode官方解法二 优点：当判断条件过多我们可以简化代码 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：3.4 MB, 在所有 Go 提交中击败了88.24%的用户 func fizzBuzz(n int) []string { if n 方法三：LeetCode官方解法三 对于面试官要求的更自由的映射关系我们可以采用散列表，但是需要注意的是，我们要采用有序的散列表，因为打印的时候我们从散列表中要按照输入的匹配顺序来取，例如我们要先能被3整除，其次才能被5整除，如果采用了无序的散列表，首先发现能够被5整除，其次能被3整除，打印结果将会与我们的正确结果不一致。 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/429.N叉树的层序遍历/code.html":{"url":"LeetCode/429.N叉树的层序遍历/code.html","title":"429.N叉树的层序遍历","keywords":"","body":"429. N叉树的层序遍历方法一：直接使用BFS进行遍历429. N叉树的层序遍历 方法一：直接使用BFS进行遍历 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：4.3 ms, 在所有 Go 提交中击败了53.03%的用户 func levelOrder(root *Node) [][]int { if root == nil { return [][]int{} } queue := []*Node{root} ret := [][]int{} for len(queue) != 0 { length := len(queue) levelRet := []int{} for i := 0; i 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/434.字符串中的单词数/code.html":{"url":"LeetCode/434.字符串中的单词数/code.html","title":"434.字符串中的单词数","keywords":"","body":"434. 字符串中的单词数方法：统计每个单词第1个字符的个数434. 字符串中的单词数 方法：统计每个单词第1个字符的个数 思路：去掉末尾的空格之后，我们只需要找到单词的首字母(也就是如果一个字符不是空格且左边字符为空格，那么单词数+1)，最后我们需要判断一下开头第1个字符不是空格的时候，我们需要将单词数+1 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：1.9 ms, 在所有 Go 提交中击败了48.33%的用户 func countSegments(s string) int { i := len(s) - 1 //去掉单词末尾空格 for ; i >= 0 && s[i] == ' '; i-- { } //Tips:上次提交出错点 //最后结束时，如果没有单词i会为-1，并且如果有字符，i会指向最后一个非空格字符， //说明没有单词 if i = 0; i-- { if s[i] != ' ' && (i - 1) >= 0 && s[i-1] == ' ' { count += 1 } } //如果开头不是空格，说明有一个单词我们没有统计 if s[0] != ' ' { count += 1 } return count } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/461.汉明距离/code.html":{"url":"LeetCode/461.汉明距离/code.html","title":"461.汉明距离","keywords":"","body":"461. 汉明距离461. 汉明距离 思路：异或之后使得不同二进制位上会为1，之后统计异或结果中二进制表达式中1的数目 执行用时：4 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.1 MB, 在所有 Go 提交中击败了100.00%的用户 func hammingDistance(x int, y int) int { xorRet, count := x ^ y, 0 for xorRet != 0 { count += 1 xorRet &= (xorRet - 1) } return count } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/476.数字的补数/code.html":{"url":"LeetCode/476.数字的补数/code.html","title":"476.数字的补数","keywords":"","body":"476. 数字的补数方法一：方法二：476. 数字的补数 这道题最核心的便是构造mask，来求得数字的补数 如何构造mask：异或操作其实相当于取反，但是如果构造一个从num最高位的1开始的那一位到最后全为1的mask，之后与数字的补数异或便得到数字的补数 以下两种解法，实质上都是构造同一个mask，只是构造方式不同罢了 方法一： 思路：找到num最高位的1所在位左边那位，新建一个数字，让该位右边全为1，此时将这个数与num进行异或。得到的便是我们要的结果 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2 MB, 在所有 Go 提交中击败了42.86%的用户 func findComplement(num int) int { mask := 1 for mask 方法二： 思路：通过最开始的全1，最后一直左移，直到找到num最高位的1左边的位，新建一个数字，让该位(包含)左边全为1，此时将这个数取反后与num进行异或。得到的便是我们要的结果。 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2 MB, 在所有 Go 提交中击败了42.86%的用户 func findComplement(num int) int { mask := ^0 for mask & num > 0 { mask 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/477.汉明距离总和/code.html":{"url":"LeetCode/477.汉明距离总和/code.html","title":"477.汉明距离总和","keywords":"","body":"477. 汉明距离总和【超时】方法一：暴力【推荐】方法二：考虑二进制中的每一位477. 汉明距离总和 【超时】方法一：暴力 时间复杂度：O(n^2) func totalHammingDistance(nums []int) int { sum := 0 for i := 0; i 【推荐】方法二：考虑二进制中的每一位 思路：因此，我们考虑数组中每个数二进制的第 i 位，假设一共有 t 个 0 和 n - t 个 1，那么显然在第 i 位的汉明距离的总和为 t * (n - t)。 步骤： 统计所有数在某一位上位1的数目，如果某一位上有k个相同，剩下n-k个不相同，那么该位上的汉明距离为k*(n-k)， 依次类推求出32位上的各个位的汉明距离，求和并返回 关键点：如何统计每一位上位1的数目，右移固定长度之后与上1 func totalHammingDistance(nums []int) int { total := 0 n := len(nums) for i := 0; i > i & 1) == 1 { bitCount += 1 } } total += bitCount * (n - bitCount) } return total } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/515.在每个树行中找最大值/code.html":{"url":"LeetCode/515.在每个树行中找最大值/code.html","title":"515.在每个树行中找最大值","keywords":"","body":"515. 在每个树行中找最大值方法一：BFS方法二：DFS515. 在每个树行中找最大值 方法一：BFS 执行用时：8 ms, 在所有 Go 提交中击败了80.00%的用户 内存消耗：6.3 MB, 在所有 Go 提交中击败了7.46%的用户 func largestValues(root *TreeNode) []int { if root == nil { return nil } ret := []int{} queue := []*TreeNode{root} for len(queue) != 0 { max := queue[0].Val currentLevelLength := len(queue) for currentLevelLength > 0 { node := queue[0] queue = queue[1:] currentLevelLength -= 1 if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } if max 方法二：DFS 执行用时：4 ms, 在所有 Go 提交中击败了99.02%的用户 内存消耗：6.1 MB, 在所有 Go 提交中击败了32.84%的用户 func largestValues(root *TreeNode) []int { if root == nil { return nil } ret := []int{} dfs(root, 1, &ret) return ret } func dfs(root *TreeNode, level int, ret *[]int) { if len(*ret) (*ret)[level-1] { (*ret)[level-1] = root.Val } } if root.Left != nil { dfs(root.Left, level+1, ret) } if root.Right != nil { dfs(root.Right, level+1, ret) } } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/566.重塑矩阵/code.html":{"url":"LeetCode/566.重塑矩阵/code.html","title":"566.重塑矩阵","keywords":"","body":"566. 重塑矩阵方法一：数学思想，找到行列互换的关系式方法二：直接不断赋值然后新数组换行之后如果行满就新生成一行方法三：566. 重塑矩阵 方法一：数学思想，找到行列互换的关系式 步骤： 首先检查参数是否合理，行数以及列数是否为0 其次检查行列以及传入的行列乘积是否相等，如果不等直接返回原数组 新建一个结果，同时将合法的内容添加进去 假设原来有n行、 新的数组的第i行第j列等同于原来的第ij/n行，第ij%n列 假设原来的矩阵有oldRows行，有oldCols列 新矩阵有r行，有c列 转换关系如下： 新矩阵的ret[i][j]：其实是第i*c+j+1个元素，ret[i][j] = nums[所在原来矩阵的行][所在原来矩阵的列] 所在原来矩阵的行：(i*c+j)/oldCols 所在原来矩阵的列：(i*c+j)%oldCols 执行用时：12 ms, 在所有 Go 提交中击败了87.18%的用户 内存消耗：6.6 MB, 在所有 Go 提交中击败了7.41%的用户 func matrixReshape(nums [][]int, r int, c int) [][]int { if len(nums) == 0 || len(nums[0]) == 0 || r*c != len(nums)*len(nums[0]) { return nums } oldCols := len(nums[0]) ret := [][]int{} rowRet := []int{} for i := 0; i 方法二：直接不断赋值然后新数组换行之后如果行满就新生成一行 执行用时：12 ms, 在所有 Go 提交中击败了87.18%的用户 内存消耗：6.6 MB, 在所有 Go 提交中击败了7.41%的用户 func matrixReshape(nums [][]int, r int, c int) [][]int { //能否reshape if len(nums) == 0 || len(nums[0]) == 0 || r*c != len(nums)*len(nums[0]) { return nums } //直接遍历进行reshape count := 0 ret := [][]int{} rowRet := []int{} for _, row := range nums { for _, val := range row { rowRet = append(rowRet, val) count += 1 if count % c == 0 { ret = append(ret, rowRet) rowRet = []int{} } } } return ret } 方法三： 改进：直接make好之后进行赋值，不要使用append动态分配内存，达到节省空间的作用 执行用时：12 ms, 在所有 Go 提交中击败了87.18%的用户 内存消耗：6.6 MB, 在所有 Go 提交中击败了7.41%的用户 func matrixReshape(nums [][]int, r int, c int) [][]int { if len(nums) == 0 || len(nums[0]) == 0 || r*c != len(nums)*len(nums[0]) { return nums } oldCols := len(nums[0]) ret := make([][]int, r) for i := 0; i 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/589.N叉树的前序遍历/code.html":{"url":"LeetCode/589.N叉树的前序遍历/code.html","title":"589.N叉树的前序遍历","keywords":"","body":"589. N叉树的前序遍历方法一：递归方法二：迭代589. N叉树的前序遍历 方法一：递归 执行用时：4 ms, 在所有 Go 提交中击败了59.25%的用户 内存消耗：5.8 ms, 在所有 Go 提交中击败了17.95%的用户 func preorder(root *Node) []int { if root == nil { return []int{} } ret := []int{root.Val} for _, node := range root.Children { ret = append(ret, preorder(node)...) } return ret } 方法二：迭代 思路：写了二叉树的非递归前序遍历后，其实这个题目类似于二叉树的非递归前序遍历，因此参照写就可以了 注意：我们遍历当前节点子树的时候，需要先从右边开始遍历，然后再遍历到左边，所以需要逆序遍历，而正好root.Children是一个切片，我们可以获取长度逆序遍历 虽然较难理解，但其实只要写好了二叉树的非递归前序遍历就知道如何进行N叉树的非递归前序遍历了 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：3.9 ms, 在所有 Go 提交中击败了86.36%的用户 func preorder(root *Node) []int { if root == nil { return []int{} } ret := []int{} stack := []*Node{root} for len(stack) != 0 { root = stack[len(stack)-1] ret = append(ret, root.Val) stack = stack[:len(stack)-1] for i := len(root.Children)-1; i >= 0; i-- { stack = append(stack, root.Children[i]) } } return ret } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/590.N叉树的后序遍历/code.html":{"url":"LeetCode/590.N叉树的后序遍历/code.html","title":"590.N叉树的后序遍历","keywords":"","body":"590. N叉树的后序遍历方法一：递归方法二：迭代590. N叉树的后序遍历 方法一：递归 思路： 递归遍历该节点的子节点，并依次将结果集加入到ret中 将当前节点的值加入到ret中 执行用时：4 ms, 在所有 Go 提交中击败了66.50%的用户 内存消耗：5.7 ms, 在所有 Go 提交中击败了29.91%的用户 func postorder(root *Node) []int { if root == nil { return []int{} } ret := []int{} for _, node := range root.Children { ret = append(ret, postorder(node)...) } ret = append(ret, root.Val) return ret } 方法二：迭代 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/617.合并二叉树/code.html":{"url":"LeetCode/617.合并二叉树/code.html","title":"617.合并二叉树","keywords":"","body":"617. 合并二叉树方法一：递归合并617. 合并二叉树 方法一：递归合并 思路：从上到下进行合并 执行用时：20 ms, 在所有 Go 提交中击败了78.92%的用户 内存消耗：6.3 ms, 在所有 Go 提交中击败了72.63%的用户 func mergeTrees(t1 *TreeNode, t2 *TreeNode) *TreeNode { if t1 == nil { return t2 } if t2 == nil { return t1 } //如果两个树都存在，那么合并到t1上 t1.Val += t2.Val t1.Left = mergeTrees(t1.Left, t2.Left) t1.Right = mergeTrees(t1.Right, t2.Right) return t1 } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/633.平方根之和/code.html":{"url":"LeetCode/633.平方根之和/code.html","title":"633.平方根之和","keywords":"","body":"633. 平方数之和方法：对撞指针633. 平方数之和 方法：对撞指针 思路：对撞指针，一个指针从0开始另一个指针从该数的平方根下取整开始一直到满足条件为止，如果中间发现i>=j就可以退出了 两个点： 从0开始的原因：题目中说了非负整数 为什么要到平方根呢：因为是两数的平方和等于该数，因此这两个数字一定小于等于该数的平方根 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2 ms, 在所有 Go 提交中击败了36.49%的用户 func judgeSquareSum(c int) bool { // 对撞指针思想 // 双指针只用一个指针指向1，另一个指针从该数的平方根开始 i := 0 j := int(math.Sqrt(float64(c))) tempRet := 0 for ; i c { j -= 1 } else if tempRet 其他方法参考LeetCode 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/637.二叉树的层平均值/code.html":{"url":"LeetCode/637.二叉树的层平均值/code.html","title":"637.二叉树的层平均值","keywords":"","body":"637 二叉树的层平均值方法：BFS637 二叉树的层平均值 方法：BFS 思路： 获取每层的和后除以每层的个数来得到平均值将其加入ret中 执行用时：8 ms, 在所有 Go 提交中击败了96.21%的用户 内存消耗：6.3 ms, 在所有 Go 提交中击败了11.54%的用户 func averageOfLevels(root *TreeNode) []float64 { if root == nil { return []float64{} } queue := []*TreeNode{root} ret := []float64{} for len(queue) != 0 { length := len(queue) var levelRet float64 for i := 0; i 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/693.交替位二进制数/code.html":{"url":"LeetCode/693.交替位二进制数/code.html","title":"693.交替位二进制数","keywords":"","body":"693. 交替位二进制数方法一：方法二：693. 交替位二进制数 方法一： 思路：每次将当前数字 与运算 二进制的11 得到后两位，如果为0或3说明相邻位相同，返回false 。否则将当前数字右移一位继续判断，直到最后为0 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2 ms, 在所有 Go 提交中击败了13.33%的用户 func hasAlternatingBits(n int) bool { for n != 0 { if n & 0b11 == 0 || n & 0b11 == 3 { return false } n >>= 1 } return true } 方法二： 思路：每次将当前数字 与运算 二进制的11 得到后两位，如果为0或3说明相邻位相同，返回false 。否则将当前数字右移一位继续判断，直到最后为0 改进点：上面的思路需要每次两两判断相邻位，而本方法直接一次性可以直接判断 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2 ms, 在所有 Go 提交中击败了13.33%的用户 func hasAlternatingBits(n int) bool { ret := n ^ (n >> 1) //因为n是相邻二进制位不同，所以右移1位之后与之前的n正好插值。此时异或后得到的后面全是1 return ret & (ret + 1) == 0 //+1得到一个1后面全为0，同时与上之前的数字一定为0 } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/746.使用最小花费爬楼梯/code.html":{"url":"LeetCode/746.使用最小花费爬楼梯/code.html","title":"746.使用最小花费爬楼梯","keywords":"","body":"746. 使用最小花费爬楼梯方法一：dp746. 使用最小花费爬楼梯 方法一：dp 步骤： 明确base case：dp[0]=nums[0], dp[1]=nums[1] 状态：dp[i]表示到达第i个阶梯的最小花费 选择：每次选择走一步或两步 状态转移方程： dp[i] = min(dp[i-2] + cost[i], dp[i-1]) ，i为最后一个值时 dp[i] = min(dp[i-1], dp[i-2]) + cost[i] , i 从2到倒数第2个值 执行用时：4 ms, 在所有 Go 提交中击败了93.12%的用户 内存消耗：3.3 ms, 在所有 Go 提交中击败了5.17%的用户 func minCostClimbingStairs(cost []int) int { if len(cost) = 3 { dp = append(dp, min(dp[len(cost)-3] + cost[len(cost)-1], dp[len(cost)-2])) } return dp[len(cost)-1] } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/867.转置矩阵/code.html":{"url":"LeetCode/867.转置矩阵/code.html","title":"867.转置矩阵","keywords":"","body":"867. 转置矩阵方法一：867. 转置矩阵 方法一： 思路：因为转置前后，行数变成列数，列数变成行数，因此我们则可以使用转置后的列数和行数来循环，同时将内容添加进去，原来在A[i][j]现在则在A[j][i] func transpose(A [][]int) [][]int { if len(A) == 0 || len(A[0]) == 0 { return nil } ret := [][]int{} //之前的行数变成了列数 //之前的列数变成了行数 for i := 0; i 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/876链表的中间结点/code.html":{"url":"LeetCode/876链表的中间结点/code.html","title":"876.链表的中间结点","keywords":"","body":"876 链表的中间结点方法一：双指针方法二：方法一的改进其他方法：876 链表的中间结点 方法一：双指针 思路：双指针。 注意：链表中可能有1个中间节点也可能有两个中间节点，取决于链表的节点的个数 如果链表有奇数个节点，则快指针最后移动到最后一个节点，此时慢指针恰好指向中间节点 如果链表有偶数个节点，则快指针最后移动到最后一个节点的下一个节点(nil)，此时慢指针恰好指向中间节点 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2 MB, 在所有 Go 提交中击败了24.64%的用户 func middleNode(head *ListNode) *ListNode { //如果没有节点或者只有一个节点 if head == nil || head.Next == nil { return head } fast, slow := head, head for fast != nil && fast.Next != nil { fast, slow = fast.Next.Next, slow.Next } return slow } 方法二：方法一的改进 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2 MB, 在所有 Go 提交中击败了75.36%的用户 思路：同方法一 改进：最开始的if判断不需要了，因为在for循环中就已经判断了 func middleNode(head *ListNode) *ListNode { //如果没有节点或者只有一个节点 //if head == nil || head.Next == nil { // return head //} fast, slow := head, head for fast != nil && fast.Next != nil { fast, slow = fast.Next.Next, slow.Next } return slow } 其他方法： 参考 使用数组存储链表各元素的值，之后直接采用下标获取中间的节点 使用单指针两次遍历数组，第一次获得链表长度，第二次求得中间节点 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/905.按奇偶排序数组/code.html":{"url":"LeetCode/905.按奇偶排序数组/code.html","title":"905.按奇偶排序数组","keywords":"","body":"905. 按奇偶排序数组方法一：自己的解法【推荐】方法二：905. 按奇偶排序数组 方法一：自己的解法 思路：对撞指针 前面指针存放偶数元素，后面指针指向奇数元素 执行用时：12 ms, 在所有 Go 提交中击败了54.79%的用户 内存消耗：4.7 ms, 在所有 Go 提交中击败了47.73%的用户 func sortArrayByParity(A []int) []int { if len(A) = 0 && A[o]&1 == 1 { o-- } if e >= o { break } if e = 0 { A[o], A[e] = A[e], A[o] o-- e++ } } return A } 【推荐】方法二： 改进：不用管边界，因为上面用到了for循环，需要注意循环超过了边界 执行用时：12 ms, 在所有 Go 提交中击败了54.79%的用户 内存消耗：4.7 ms, 在所有 Go 提交中击败了56.82%的用户 func sortArrayByParity(A []int) []int { l, r := 0, len(A)-1 for l 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/917.仅仅反转字母/code.html":{"url":"LeetCode/917.仅仅反转字母/code.html","title":"917.仅仅反转字母","keywords":"","body":"917. 仅仅反转字母方法：对撞指针思想进行反转917. 仅仅反转字母 方法：对撞指针思想进行反转 思路：使用对撞指针思想进行反转，每次让两个指针指向字母，之后进行反转 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.6 ms, 在所有 Go 提交中击败了36.00%的用户 func reverseOnlyLetters(S string) string { s := []byte(S) start, end := 0, len(s)-1 for start = 97 && num = 65 && num 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/925.长按键入/code.html":{"url":"LeetCode/925.长按键入/code.html","title":"925.长按键入","keywords":"","body":"925. 长按键入方法一：925. 长按键入 方法一： 思路：双指针，分别指向传入两个字符串的第1个字符 步骤： first, second分别指向两个字符串的第1个字符， 开始进行循环： 2.1 如果相等，first,second都后移1个单位 2.2 如果不等，并且second不是第1个下标，此时second可能是前面一个字符重复加入，因此验证second的前一个字符与现在的指向字符是否相等 2.3 否则返回false 循环结束：我们需要处理几个剩下的条件，可能我们最后second没有指向最后并且second后面还有其他字符，因此我们验证此时second后面是否有其他不同的字符，如果有就返回false 最后返回的时候我们需要处理是否first指向最后，因为可能second先于first指向最后 其实上面的思路就是用滑动窗口做这个题目，如果字符相等就往后移动，如果不等时，第2个字符串的字符与前一个字符相等，也会继续后移，直到遇到不同的字符就返回false 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.1 MB, 在所有 Go 提交中击败了13.48%的用户 func isLongPressedName(name string, typed string) bool { first, second := 0, 0 for first = 1 && typed[second-1] == typed[second] { second += 1 } else { return false } } //注意点1：最后typed可能还有别的剩余的字符还是需要处理一下的 for second 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/965.单值二叉树/code.html":{"url":"LeetCode/965.单值二叉树/code.html","title":"965.单值二叉树","keywords":"","body":"965. 单值二叉树方法一：递归遍历965. 单值二叉树 方法一：递归遍历 思路： 满足以下条件就不是单值二叉树 1. 左子树存在，左子树不是单值二叉树 2. 左子树是单值二叉树，但是左子树的根与根节点值不同 3. 右子树存在，右子树不是单值二叉树 4. 右子树是单值二叉树，但是右子树的根与根节点值不同 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：2.3 ms, 在所有 Go 提交中击败了92.86%的用户 func isUnivalTree(root *TreeNode) bool { if root == nil { return true } if (root.Left != nil && ((root.Val != root.Left.Val) || !isUnivalTree(root.Left))) || (root.Right != nil && ((root.Val != root.Right.Val) || !isUnivalTree(root.Right))){ return false } return true } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/976.三角形的最大周长/code.html":{"url":"LeetCode/976.三角形的最大周长/code.html","title":"976.三角形的最大周长","keywords":"","body":"976. 三角形的最大周长方法一：976. 三角形的最大周长 方法一： 思路：对传入的数组进行排序，然后从最后一个位置开始遍历假设为i，同时另外两条边为j,k，初始令j = i-2, k = i-1，最终依次找到可组成三角形的三条边并返回。 注意：最后返回的i, j, k对应的三个元素一定相邻，因为如果某次A[k] + A[k] 知识点：如何判断是否是一个三角形：两边之和大于第三边就可以构成一个三角形。 func largestPerimeter(A []int) int { //如果数组中小于3个数，直接返回0 if len(A) = 0 && A[j] + A[k] 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/1009.十进制整数的反码/code.html":{"url":"LeetCode/1009.十进制整数的反码/code.html","title":"1009.十进制整数的反码","keywords":"","body":"1009. 十进制整数的反码方法一：方法二：1009. 十进制整数的反码 思路：类似于476题，唯一的区别在于，这里传入的参数可以为0，因此我们需要额外判断一下即可。 方法一： 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：1.9 ms, 在所有 Go 提交中击败了41.18%的用户 func bitwiseComplement(N int) int { //如果N为0需要返回1 if N == 0 { return 1 } mask := 1 for mask 方法二： 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：1.9 ms, 在所有 Go 提交中击败了41.18%的用户 func bitwiseComplement(N int) int { //如果N为0需要返回1 if N == 0 { return 1 } mask := ^0 for mask & N != 0 { mask 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/1022.从根到叶的二进制数之和/code.html":{"url":"LeetCode/1022.从根到叶的二进制数之和/code.html","title":"1022.从根到叶的二进制数之和","keywords":"","body":"1022. 从根到叶的二进制数之和方法：DFS + 树的前序遍历1022. 从根到叶的二进制数之和 方法：DFS + 树的前序遍历 具体解法同leetcode-129 执行用时：4 ms, 在所有 Go 提交中击败了79.55%的用户 内存消耗：3.2 MB, 在所有 Go 提交中击败了43.33%的用户 func sumRootToLeaf(root *TreeNode) int { if root == nil { return 0 } sum := 0 dfs(root, &sum, 0) return sum } func dfs(root *TreeNode, sum *int, currentVal int) { currentVal = currentVal 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/1025.除数博弈/code.html":{"url":"LeetCode/1025.除数博弈/code.html","title":"1025.除数博弈","keywords":"","body":"1025. 除数博弈方法一：1025. 除数博弈 方法一： 核心点：谁最后拿到1谁必输 因此围绕上面的核心点，有如下两种情况： Case 1: 我们拿到的是一个奇数，我们只能选1个奇数，之后对方将会拿到一个偶数，对方肯定很聪明，也会一直选1，逼我们拿到奇数，最终我们一定会输（因为我们必会拿1）。 Case 2: 我们拿到的是一个偶数，我们每次选择1，逼对方去拿奇数，最终对方一定会拿到1，我们必赢。 //leetcode submit region begin(Prohibit modification and deletion) //执行耗时:0 ms,击败了100.00% 的Go用户 //内存消耗:1.9 MB,击败了97.56% 的Go用户 func divisorGame(N int) bool { //如果是偶数 if N & 1 == 0 { return true //对方最终一定拿到一个奇数，因此你会赢 } //如果是奇数 return false } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/1137.第N个泰波那契数/code.html":{"url":"LeetCode/1137.第N个泰波那契数/code.html","title":"1137.第N个泰波那契数","keywords":"","body":"1137. 第 N 个泰波那契数方法一：普通递归方法二：dp总结：1137. 第 N 个泰波那契数 方法一：普通递归 思路：直接使用递归进行计算，可以得到结果，但是效率比较低，并且涉及到了重复计算，因此我们可以使用dp进行改进 缺点：超时 func tribonacci(n int) int { if n == 0 { return 0 } else if n == 1 { return 1 } else if n == 2 { return 1 } return tribonacci(n-1) + tribonacci(n-2) + tribonacci(n-3) } 方法二：dp 思路：复用3个变量进行计算 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：1.9 MB, 在所有 Go 提交中击败了97.44%的用户 func tribonacci(n int) int { if n == 0 { return 0 } else if n == 1 { return 1 } else if n == 2 { return 1 } p, q, r := 0, 1, 1 for i := 3; i 总结： 还有其他解法，根据面试官的不同要求来实现，如果需要快速获取，我们可以使用一个map来存储对应的值，如果希望节省空间，那么我们就可以使用3个变量来复用进行计算，具体哪种方法最好取决于面试官的需求以及实际场景的应用要求。 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/1281.整数的各位积和之差/code.html":{"url":"LeetCode/1281.整数的各位积和之差/code.html","title":"1281.整数的各位积和之差","keywords":"","body":"1281. 整数的各位积和之差方法：直接模拟操作即可1281. 整数的各位积和之差 方法：直接模拟操作即可 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：1.9 MB, 在所有 Go 提交中击败了40.00%的用户 func subtractProductAndSum(n int) int { if n == 0 { return 0 } product, sum := 1, 0 for n != 0 { product *= (n % 10) sum += (n % 10) n /= 10 } return product - sum } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/1290二进制链表转整数/code.html":{"url":"LeetCode/1290二进制链表转整数/code.html","title":"1290.二进制链表转整数","keywords":"","body":"1290二进制链表转整数方法一：1290二进制链表转整数 方法一： //执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 //内存消耗：2 MB, 在所有 Go 提交中击败了100.00%的用户 思路： 如果当前链表节点不空，每次获取当前链表节点值加入到ret中， 之后每次后移，相当于二进制位左移了1位，同时值也要左移1位， 重复如上步骤 ``` ​```go func getDecimalValue(head *ListNode) int { ret := 0 for head != nil { ret = ret ## 方法二：参考LeetCode解法，对上述方法改进 > 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 > 内存消耗：2 MB, 在所有 Go 提交中击败了100.00%的用户 原因：对上面代码进行改进，**因为链表中的值是二进制，所以左移1位后不用采用加法来计算，而可以采用或(只有0和1)** > 思路：同方法一 ```go func getDecimalValue(head *ListNode) int { ret := 0 for head != nil { ret = ret版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/1295.统计位数为偶数的数字/code.html":{"url":"LeetCode/1295.统计位数为偶数的数字/code.html","title":"1295.统计位数为偶数的数字","keywords":"","body":"1295. 统计位数为偶数的数字方法一：确定位数为偶数的数字所在范围另外两种解法参考1295. 统计位数为偶数的数字 方法一：确定位数为偶数的数字所在范围 因为要统计位数为偶数，所以在10-99以及1000-9999以及数字为100000的数字位数都是偶数 题目中给定了数组中每个数字的范围从0-10^5 执行用时：4 ms, 在所有 Go 提交中击败了90.45%的用户 内存消耗：3.1 MB, 在所有 Go 提交中击败了100.00%的用户 func findNumbers(nums []int) int { count := 0 for _, num := range nums { if num >= 10 && num = 1000 && num 另外两种解法参考 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/1342将数字变成0的操作次数/code.html":{"url":"LeetCode/1342将数字变成0的操作次数/code.html","title":"1342.将数字变成0的操作次数","keywords":"","body":"方法一：自己的解法方法二：参照其他人的解法1342. 将数字变成 0 的操作次数 方法一：自己的解法 思路：将除以2使用右移运算符替代 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：1.9 MB, 在所有 Go 提交中击败了84.85%的用户 func numberOfSteps (num int) int { ret := 0 for num != 0 { if num & 1 == 1 { num -= 1 } else { num >>= 1 } ret += 1 } return ret } 方法二：参照其他人的解法 思路：将除以2使用右移运算符替代 改进：相比于方法一，如果我们这个数是奇数，那么减去1，其实可以和1进行异或运算 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：1.9 MB, 在所有 Go 提交中击败了54.55%的用户 func numberOfSteps (num int) int { ret := 0 for num != 0 { if num & 1 == 1 { num ^= 1 } else { num >>= 1 } ret += 1 } return ret } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"LeetCode/1480.一维数组动态和/code.html":{"url":"LeetCode/1480.一维数组动态和/code.html","title":"1480.一维数组动态和","keywords":"","body":"1480. 一维数组的动态和方法一：dp方法二：dp + 状态压缩注意点1480. 一维数组的动态和 方法一：dp 思路： 初始状态：ret[0] = nums[0] 状态转移方程ret[i] = ret[i-1] + nums[i] 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：1.9 MB, 在所有 Go 提交中击败了84.85%的用户 func runningSum(nums []int) []int { if len(nums) 方法二：dp + 状态压缩 改进：直接修改传入的数组(需要征得面试官同意)。主要思路同方法一 执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户 内存消耗：1.9 MB, 在所有 Go 提交中击败了84.85%的用户 func runningSum(nums []int) []int { if len(nums) 注意点 面试修改传入的数组，需要征得面试官同意 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"程序员面试金典/":{"url":"程序员面试金典/","title":"程序员面试金典","keywords":"","body":"程序员面试金典题解程序员面试金典题解 题号 题目名称 解决时间 疑问 笔记 面试题16.01 2020-08-12 交换数字 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"算法刷题总结/位运算.html":{"url":"算法刷题总结/位运算.html","title":"位运算","keywords":"","body":"把一个整数减去1之后再和原来的整数做位与运算，得到的结果相当于把整数的二进制表示中最右边的1编程0 一个数字左移1位之后右边补0，但是进行右移时，如果是无符号的则在左边补0，否则补上符号位(整数补0，负数补1)，算术右移补上符号位，逻辑右移不用补符号位 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"算法刷题总结/数组.html":{"url":"算法刷题总结/数组.html","title":"数组","keywords":"","body":"数组双指针：数组 双指针： 数组中的双指针中，第一个指针可以有两种含义： 从当前位置开始进行答案搜索，一般初始值都是0位置 当前位置已经是满足题意的最后一个位置，一般初始值都是-1 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"算法刷题总结/递归与循环.html":{"url":"算法刷题总结/递归与循环.html","title":"递归与循环","keywords":"","body":"算法和数据操作位运算递归与循环算法和数据操作 排序和查找中应该重点掌握：二分查找，归并排序，快速排序 如果面试题要求在二维数据上搜索路径，我们可以尝试使用回溯法，当面试官限定不可以用递归时，我们考虑用栈模拟递归实现。 如果面试题是求某个问题的最优解，并且该问题可以分解为多个子问题，我们可以尝试使用动态规划，在自上而下的递归思路分析问题时，发现存在大量重复子问题，因此为了避免不必要的重复计算，我们使用从下往上的循环实现。一般就是使用一维或二维数组保存计算下来的最优解，接下来解决更大的问题 如果告诉面试官动态规划思路之后，面试官还在提醒说分解子问题的时候是不是存在某个特殊选择，如果采用这个特殊选择一定可以得到最优解，那么这意味着该面试题适用于贪婪算法。 位运算 把一个整数减去1之后再和原来的整数做位与运算，得到的结果相当于把整数的二进制表示中最右边的1编程0 一个数字左移1位之后右边补0，但是进行右移时，如果是无符号的则在左边补0，否则补上符号位(整数补0，负数补1)，算术右移补上符号位，逻辑右移不用补符号位 递归与循环 面试的时候，如果面试官没有特别要求，应聘者可以尽量多的采用递归方法编程。因为递归实现的代码简洁很多 递归缺点：递归是函数调用自身，而函数调用自身有时间和空间消耗，每一次函数调用，都要在内存占中分配空间以保存参数，返回地址以及临时变量，而且往栈中压入数据和弹出数据都需要时间。除此之外，递归涉及到了大量的重复计算。 通常应用动态规划解决问题时，我们都是采用递归的思路进行分析，但是在实现的时候我们采用从下往上来避免大量的重复计算。 除效率之外，递归还有可能引起更严重的问题：调用栈溢出，因为每个进程的栈容量有限，当递归调用层级太多，会超出栈容量。 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"golang/":{"url":"golang/","title":"Golang学习","keywords":"","body":" 记录Golang学习历程 千峰教育韩茹老师课程：https://www.bilibili.com/video/BV1k4411G7yy?p=42 进度 时间 33-41 7-21 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"golang/break_continue.html":{"url":"golang/break_continue.html","title":"break和continue的使用","keywords":"","body":"break以及continue的使用break以及continue的使用 break 或者 continue 都只是针对于紧挨break 或 continue 的内层循环 如果想要终止外层循环或者跳过可以给外层循环加上标签，之后使用语法：break 外层循环加的标签名 或 goto 外层循环加的标签名 首先要给我们想要中断的外层循环添加标签，之后在break或continue后面加上标签 //continue和break默认结束最里层的循环 //如果我们想要结束外层循环可以贴标签 out:for i := 0; i 打印结果如下： i = 0 j = 0 i = 0 j = 0 i = 1 j = 0 i = 2 j = 0 i = 3 j = 0 i = 4 j = 0 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"golang/goto.html":{"url":"golang/goto.html","title":"goto语句","keywords":"","body":"goto语句应用场景goto语句 程序正常执行时会进入贴上标签的代码，并执行 语法：goto 标签 给代码贴上标签：标签: 代码 a := 10 loop: for a 打印结果如下： 10 11 12 13 14 16 17 18 19 123 应用场景 goto语句应用：统一错误处理 err := firstCheckError() if err != nil { goto onExit } err := secondCheckError() if err != nil { goto onExit } fmt.Println(\"done\") return onExit: fmt.Println(err) exitProcess() 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"golang/randnum.html":{"url":"golang/randnum.html","title":"随机数","keywords":"","body":"随机数随机数 生成随机数需要设置不一样的种子，当我们种子不一样时就会产生不同的随机数，因此如果种子一样生成的随机数也会一样 通过rand.Seed(time.Now().Unix())设置随机数 package main import ( \"fmt\" \"math/rand\" \"time\" ) func main() { //因为随机数是根据种子生成的 rand.Seed(time.Now().Unix()) //种子固定以后就可以生成随机出 //生成[0, 31]的随机数 for i := 0; i 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"golang/array.html":{"url":"golang/array.html","title":"数组","keywords":"","body":"数组的初步使用数组的初步使用 数组的语法定义： var 数组名 = [数组长度] 数据类型 {} var 数组名 = [数组长度] 数据类型 {初始元素(要求个数必须小于等于数组长度)} var 数组名 := [数组长度] 数据类型 {下标:元素值......} 数组名 := [...] 数据类型 {初始元素} 根据初始元素个数决定数据的长度 数组的长度表明了数组实际存放元素的个数，而容量则表示数组存放数字的最大个数 因为数组是固定长度的，数组的长度和容量是相等的。并且需要注意的是长度也是数组的属性，所以[3]int 与 [4]int是两种不同数据类型。因为数组的数据类型由数组的长度以及数组中元素的数据类型决定。 package main import \"fmt\" func main() { var array1 = [3]int {0, 1, 2} fmt.Println(array1) //[0 1 2] var array2 = [3]int {1} fmt.Println(array2) // [1 0 0] var array3 = [4]int {3:123} fmt.Println(array3) //[0 0 0 123] var array4 = [...]int {11, 9, 28, 900, 1332} fmt.Println(array4, len(array4), cap(array4)) //[11 9 28 900 1332] 5 5 } 数组是值类型，也就是当传递的时候会将值传递过去。引用类型是存储数据的内存地址。 值类型：基本数据类型 + 数组 + 结构体。可以使用==比较，前提是==左右两边是一致的数据类型，例如左边是[3]int右边是[4]int将会报错 引用类型：map + 切片 + channel ，也就是用make创建的都是引用类型，如果将另外一个该类型的变量传递过去，将会传递一个地址 num2 := 10 num3 := num2 num3 = 100 fmt.Println(num2, num3) //10, 100 因为基本数据类型都是值类型 //数组也是值类型 array := [3]int{1, 2, 3} array2 := array array2[0] = 100 fmt.Println(array, array2) //[1, 2, 3] [100, 2, 3] fmt.Println([3]int{1, 2, 3} == [4]int{0, 1, 2, 3}) //报错，因为数据类型就不匹配 fmt.Println([3]int{1, 2, 3} == [3]int{0, 1, 2}) //如果数据类型(包括数组长度以及元素的类型一致，才会依次比较下标对应位置的元素是否相同) 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "},"golang/slice.html":{"url":"golang/slice.html","title":"切片","keywords":"","body":"切片切片创建从已有数组创建切片切片尾部添加元素切片遍历切片 切片同数组类似，也叫做变长数组或动态数组。 切片是一个引用类型的容器，因为切片本身不存储数据，是底层数组存取数据，因此指向了一个底层数组。可以使用fmt.Printf(\"%p\",切片名)查看切片指向的地址 切片即使元素个数超过cap也是可以的，因为会进行扩容。一旦扩容就会指向一个新的底层数组。同时每次扩容都会成倍增长。3->6->12->24->48 扩容过程：首先创建一个新的数组，将原来数组的内容拷贝到新的数组，然后添加新元素到新的数组 切片创建 使用make或者直接使用初始元素创建 func make(t Type, size ...IntergeType) Type 第一个参数：类型 第二个参数：长度len，切片实际存储的元素个数 第三个参数：容量cap，最多能够存储元素的个数 nums := make([]int, 4, 8) nums := []int {1, 2, 3, 4, 5} 从已有数组创建切片 此时切片指向该数组的一部分，此时修改数组或者修改切片都会造成另一方的修改。 nums := [10]int{1,2,3,4,5,6,7,8,9,10} //从头开始切片到底5个元素 s1 := nums[:5] //包含头不包含尾相当于从0取到5。，头不写则说明从头开始 fmt.Println(\"我们需要一个世界欢迎你但是我们需啊\") s2 := nums[6:] //如果取到最后则最后可以不写 s3 := s2 //s2存储的是nums[6]的地址，因此会将这个地址赋值一份给s3 案例代码： package main import \"fmt\" func main() { //创建数组 nums := [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10} //创建切片，切片指向的地址与数组的地址一致 s1 := nums[:5] //如果包含数组的头部则开始可以省略 s2 := nums[3:8] s3 := nums[5:] s4 := nums[:] fmt.Printf(\"s1 = %p, s2 = %p, s3 = %p, s4 = %p, nums = %p\\n\", s1, s2, s3, s4, &nums) fmt.Println() //长度和容量 fmt.Println(len(nums), cap(nums)) fmt.Println(len(s1), cap(s1)) fmt.Println(len(s2), cap(s2)) fmt.Println(len(s3), cap(s3)) fmt.Println(len(s4), cap(s4)) //修改数组中的一个元素,切片也会进行修改 nums[4] = 1000 fmt.Println(nums) fmt.Println(s1) fmt.Println(s2) fmt.Println(s3) fmt.Println(s4) //向s1添加元素 s1 = append(s1, 1, 1, 1, 1) //其实会修改数组后面的内容 fmt.Println(nums) fmt.Println(s1) fmt.Println(s2) fmt.Println(s3) //添加元素引起扩容,扩容会创建一个新的底层数组 s1 = append(s1, 99, 22, 33, 44) fmt.Println(nums) fmt.Println(s1) fmt.Println(s2) fmt.Println(s3) } 打印结果： s1 = 0xc00001e050, s2 = 0xc00001e068, s3 = 0xc00001e078, s4 = 0xc00001e050, nums = 0xc00001e050 10 10 5 10 5 7 5 5 10 10 [1 2 3 4 1000 6 7 8 9 10] [1 2 3 4 1000] [4 1000 6 7 8] [6 7 8 9 10] [1 2 3 4 1000 6 7 8 9 10] [1 2 3 4 1000 1 1 1 1 10] [1 2 3 4 1000 1 1 1 1] [4 1000 1 1 1] [1 1 1 1 10] [1 2 3 4 1000 1 1 1 1 10] [1 2 3 4 1000 1 1 1 1 99 22 33 44] [4 1000 1 1 1] [1 1 1 1 10] 切片尾部添加元素 如果要对长度以外的索引赋值需要使用内置函数append()添加，如果在长度以内的直接使用切片名[索引]赋值 由于append()添加后可能引起扩容，会返回一个切片的新地址，因此我们必须用原切片接收 方式1：append()后面可以加多个元素，将多个元素添加到切片中 方式2：append()后面可以加一个切片，将后面切片中的所有元素加入到切片中，并返回 nums = append(nums, 2, 3, 4) nums = append(nums2, nums...) 切片遍历 package main import \"fmt\" func main() { //定义一个切片 nums := []int{99, 18, 239, 109, 11, 3, 45} //遍历切片 //第一种方式遍历切片 for i := 0; i %d\\n\", i, val) } } 版权所有，盗版必究 all right reserved，powered by GitbookLast Modified On： 2020-12-22 17:17:12 "}}
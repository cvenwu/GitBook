# 数组的初步使用


数组的语法定义：
1. `var 数组名 = [数组长度] 数据类型 {}`
2. `var 数组名 = [数组长度] 数据类型 {初始元素(要求个数必须小于等于数组长度)}`
3. `var 数组名 := [数组长度] 数据类型 {下标:元素值......}`
4. `数组名 := [...] 数据类型 {初始元素}` 根据初始元素个数决定数据的长度


数组的长度表明了数组实际存放元素的个数，而容量则表示数组存放数字的最大个数

因为数组是固定长度的，数组的长度和容量是相等的。并且需要注意的是长度也是数组的属性，所以[3]int 与 [4]int是两种不同数据类型。**因为数组的数据类型由数组的长度以及数组中元素的数据类型决定。**

```go
package main

import "fmt"

func main() {
	var array1 = [3]int {0, 1, 2}
	fmt.Println(array1)  //[0 1 2]

	var array2 = [3]int {1}
	fmt.Println(array2)  // [1 0 0]

	var array3 = [4]int {3:123}
	fmt.Println(array3)  //[0 0 0 123]

	var array4 = [...]int {11, 9, 28, 900, 1332}
	fmt.Println(array4, len(array4), cap(array4))  //[11 9 28 900 1332] 5 5

}

```

**数组是值类型，也就是当传递的时候会将值传递过去。引用类型是存储数据的内存地址。**
值类型：基本数据类型 + 数组 + 结构体。可以使用==比较，前提是==左右两边是一致的数据类型，例如左边是[3]int右边是[4]int将会报错
引用类型：map + 切片 + channel ，也就是用make创建的都是引用类型，如果将另外一个该类型的变量传递过去，将会传递一个地址


```go
num2 := 10
num3 := num2
num3 = 100
fmt.Println(num2, num3)  //10, 100 因为基本数据类型都是值类型


//数组也是值类型
array := [3]int{1, 2, 3}
array2 := array

array2[0] = 100
fmt.Println(array, array2)  //[1, 2, 3]   [100, 2, 3]


fmt.Println([3]int{1, 2, 3} == [4]int{0, 1, 2, 3})  //报错，因为数据类型就不匹配
fmt.Println([3]int{1, 2, 3} == [3]int{0, 1, 2})  //如果数据类型(包括数组长度以及元素的类型一致，才会依次比较下标对应位置的元素是否相同)

```




